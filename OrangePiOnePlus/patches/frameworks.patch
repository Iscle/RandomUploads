diff -ur ../aosp/frameworks/av/include/media/IOMX.h ../Desktop/android/frameworks/av/include/media/IOMX.h
--- ../aosp/frameworks/av/include/media/IOMX.h	2018-08-06 15:40:15.111063901 +0200
+++ ../Desktop/android/frameworks/av/include/media/IOMX.h	2017-11-23 05:21:06.000000000 +0100
@@ -232,6 +232,11 @@
             OMX_U32 range_length;
             OMX_U32 flags;
             OMX_TICKS timestamp;
+
+            //* extend for hdr
+            OMX_U32 ext_video_full_range_flag;
+            OMX_U32 ext_transfer_characteristics;
+            OMX_U32 ext_matrix_coeffs;
         } extended_buffer_data;
 
         // if type == FRAME_RENDERED
diff -ur ../aosp/frameworks/av/include/media/mediaplayer.h ../Desktop/android/frameworks/av/include/media/mediaplayer.h
--- ../aosp/frameworks/av/include/media/mediaplayer.h	2018-08-06 15:40:15.115063952 +0200
+++ ../Desktop/android/frameworks/av/include/media/mediaplayer.h	2017-11-23 05:21:06.000000000 +0100
@@ -54,6 +54,9 @@
     MEDIA_INFO              = 200,
     MEDIA_SUBTITLE_DATA     = 201,
     MEDIA_META_DATA         = 202,
+    MEDIA_GET_BUFFER_LENGTH = 300,  //softdetector
+
+    AWEXTEND_MEDIA_INFO     = 1000,
 };
 
 // Generic error codes for the media player framework.  Errors are fatal, the
@@ -83,6 +86,14 @@
     // 2xx
     MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK = 200,
     // 3xx
+
+    // 9xx
+    MEDIA_ERROR_OUT_OF_MEMORY = 900,
+    // 4xx
+    MEDIA_ERROR_IO = -1004,
+    MEDIA_ERROR_MALFORMED = -1007,
+    MEDIA_ERROR_UNSUPPORTED = -1010,
+    MEDIA_ERROR_TIMED_OUT = -110,
 };
 
 
@@ -134,6 +145,14 @@
 
     //9xx
     MEDIA_INFO_TIMED_TEXT_ERROR = 900,
+
+    //4096, aw extend.
+    MEDIA_INFO_AWEXTEND_INDICATE_3D_DOUBLE_STREAM = 4096,
+
+    // add for cmcc wasu
+    MEDIA_INFO_DOWNLOAD_START = 10086,
+    MEDIA_INFO_DOWNLOAD_END   = 10087,
+    MEDIA_INFO_DOWNLOAD_ERROR = 10088,
 };
 
 
@@ -177,7 +196,20 @@
     INVOKE_ID_SELECT_TRACK = 4,
     INVOKE_ID_UNSELECT_TRACK = 5,
     INVOKE_ID_SET_VIDEO_SCALING_MODE = 6,
-    INVOKE_ID_GET_SELECTED_TRACK = 7
+    INVOKE_ID_GET_SELECTED_TRACK = 7,
+
+    INVOKE_ID_SET_3D_MODE = 128,
+    INVOKE_ID_GET_3D_MODE = 129,
+
+    INVOKE_ID_GET_CONTENT_ID = 1000,
+    INVOKE_ID_GET_MIME = 1001,
+    INVOKE_ID_GET_BITRATE = 1002,
+    INVOKE_ID_GET_CACHEBYTES = 1003,
+    // Keep INVOKE_ID_WASABI_DRM in sync with com.intertrust.wasabi.Drm.java!
+    INVOKE_ID_WASABI_DRM = 9876,
+
+    // Keep INVOKE_ID_PLAYREADY_DRM in sync with playready apk
+    INVOKE_ID_PLAYREADY_DRM = 9900,
 };
 
 // Keep MEDIA_TRACK_TYPE_* in sync with MediaPlayer.java.
Only in ../Desktop/android/frameworks/av/include/media: mediaplayerinfo.h
diff -ur ../aosp/frameworks/av/include/media/MediaPlayerInterface.h ../Desktop/android/frameworks/av/include/media/MediaPlayerInterface.h
--- ../aosp/frameworks/av/include/media/MediaPlayerInterface.h	2018-08-06 15:40:15.111063901 +0200
+++ ../Desktop/android/frameworks/av/include/media/MediaPlayerInterface.h	2017-11-23 05:21:06.000000000 +0100
@@ -52,6 +52,8 @@
     // The shared library with the test player is passed passed as an
     // argument to the 'test:' url in the setDataSource call.
     TEST_PLAYER = 5,
+
+    AW_PLAYER = 6,
 };
 
 
diff -ur ../aosp/frameworks/av/include/media/stagefright/ACodec.h ../Desktop/android/frameworks/av/include/media/stagefright/ACodec.h
--- ../aosp/frameworks/av/include/media/stagefright/ACodec.h	2018-08-06 15:40:15.123064056 +0200
+++ ../Desktop/android/frameworks/av/include/media/stagefright/ACodec.h	2017-11-23 05:21:06.000000000 +0100
@@ -200,6 +200,10 @@
         int mFenceFd;
         FrameRenderTracker::Info *mRenderInfo;
 
+        int32_t mMatrixCoeffs;
+        int32_t mVideoFullRange;
+        int32_t mTransferCharacteristics;
+
         // The following field and 4 methods are used for debugging only
         bool mIsReadFence;
         // Store |fenceFd| and set read/write flag. Log error, if there is already a fence stored.
@@ -307,6 +311,9 @@
     OMX_INDEXTYPE mDescribeColorAspectsIndex;
     OMX_INDEXTYPE mDescribeHDRStaticInfoIndex;
 
+    OMX_U32 mExtendFlag;
+    bool mFirstPTS;
+
     status_t setCyclicIntraMacroblockRefresh(const sp<AMessage> &msg, int32_t mode);
     status_t allocateBuffersOnPort(OMX_U32 portIndex);
     status_t freeBuffersOnPort(OMX_U32 portIndex);
diff -ur ../aosp/frameworks/av/include/media/stagefright/MediaDefs.h ../Desktop/android/frameworks/av/include/media/stagefright/MediaDefs.h
--- ../aosp/frameworks/av/include/media/stagefright/MediaDefs.h	2018-08-06 15:40:15.127064107 +0200
+++ ../Desktop/android/frameworks/av/include/media/stagefright/MediaDefs.h	2017-11-23 05:21:06.000000000 +0100
@@ -31,7 +31,19 @@
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG2;
 extern const char *MEDIA_MIMETYPE_VIDEO_RAW;
 extern const char *MEDIA_MIMETYPE_VIDEO_DOLBY_VISION;
-
+extern const char *MEDIA_MIMETYPE_VIDEO_WMV1;
+extern const char *MEDIA_MIMETYPE_VIDEO_WMV2;
+extern const char *MEDIA_MIMETYPE_VIDEO_VC1;
+extern const char *MEDIA_MIMETYPE_VIDEO_VP6;
+extern const char *MEDIA_MIMETYPE_VIDEO_S263;
+extern const char *MEDIA_MIMETYPE_VIDEO_MJPEG;
+extern const char *MEDIA_MIMETYPE_VIDEO_MPEG1;
+extern const char *MEDIA_MIMETYPE_VIDEO_MSMPEG4V1;
+extern const char *MEDIA_MIMETYPE_VIDEO_MSMPEG4V2;
+extern const char *MEDIA_MIMETYPE_VIDEO_DIVX;
+extern const char *MEDIA_MIMETYPE_VIDEO_XVID;
+extern const char *MEDIA_MIMETYPE_VIDEO_RXG2;
+extern const char *MEDIA_MIMETYPE_VIDEO_VPX;
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_NB;
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_WB;
 extern const char *MEDIA_MIMETYPE_AUDIO_MPEG;           // layer III
@@ -65,6 +77,7 @@
 extern const char *MEDIA_MIMETYPE_TEXT_SUBRIP;
 extern const char *MEDIA_MIMETYPE_TEXT_VTT;
 extern const char *MEDIA_MIMETYPE_TEXT_CEA_608;
+extern const char *MEDIA_MIMETYPE_VIDEO_VPX;
 extern const char *MEDIA_MIMETYPE_TEXT_CEA_708;
 extern const char *MEDIA_MIMETYPE_DATA_TIMED_ID3;
 
Only in ../Desktop/android/frameworks/av/media: libcedarc
Only in ../Desktop/android/frameworks/av/media: libcedarx
diff -ur ../aosp/frameworks/av/media/libmedia/AudioTrack.cpp ../Desktop/android/frameworks/av/media/libmedia/AudioTrack.cpp
--- ../aosp/frameworks/av/media/libmedia/AudioTrack.cpp	2018-08-06 15:40:15.227065392 +0200
+++ ../Desktop/android/frameworks/av/media/libmedia/AudioTrack.cpp	2017-11-23 05:21:08.000000000 +0100
@@ -380,6 +380,8 @@
         format = AUDIO_FORMAT_PCM_16_BIT;
     } else if (format == AUDIO_FORMAT_IEC61937) { // HDMI pass-through?
         mAttributes.flags |= AUDIO_OUTPUT_FLAG_IEC958_NONAUDIO;
+        flags = (audio_output_flags_t) (flags | AUDIO_OUTPUT_FLAG_DIRECT);
+        ALOGV("AUDIO_FORMAT_IEC61937 SET AUDIO_OUTPUT_FLAG_DIRECT");
     }
 
     // validate parameters
diff -ur ../aosp/frameworks/av/media/libmedia/ICrypto.cpp ../Desktop/android/frameworks/av/media/libmedia/ICrypto.cpp
--- ../aosp/frameworks/av/media/libmedia/ICrypto.cpp	2018-08-06 15:40:15.231065443 +0200
+++ ../Desktop/android/frameworks/av/media/libmedia/ICrypto.cpp	2017-11-23 05:21:08.000000000 +0100
@@ -315,6 +315,10 @@
             if (dstType == kDestinationTypeNativeHandle) {
                 nativeHandle = data.readNativeHandle();
                 dstPtr = static_cast<void *>(nativeHandle);
+
+                if(nativeHandle->numFds == 0 && nativeHandle->numInts == 1) {
+                    dstPtr = (void*)nativeHandle->data[0];
+                }
             } else if (dstType == kDestinationTypeOpaqueHandle) {
                 secureBufferId = reinterpret_cast<void *>(static_cast<uintptr_t>(data.readInt64()));
                 dstPtr = secureBufferId;
diff -ur ../aosp/frameworks/av/media/libmedia/MediaScanner.cpp ../Desktop/android/frameworks/av/media/libmedia/MediaScanner.cpp
--- ../aosp/frameworks/av/media/libmedia/MediaScanner.cpp	2018-08-06 15:40:15.235065494 +0200
+++ ../Desktop/android/frameworks/av/media/libmedia/MediaScanner.cpp	2017-11-23 05:21:08.000000000 +0100
@@ -128,6 +128,15 @@
     return false;
 }
 
+static bool shouldStopScanner() {
+    char state[PROPERTY_VALUE_MAX] = {0};
+    property_get("mediasw.stopscaner", state, "0");
+    if (state[0] == '1')
+        return true;
+    return false;
+}
+
+
 MediaScanResult MediaScanner::doProcessDirectory(
         char *path, int pathRemaining, MediaScannerClient &client, bool noMedia) {
     // place to copy file or directory name
@@ -232,6 +241,11 @@
         if (status) {
             return MEDIA_SCAN_RESULT_ERROR;
         }
+
+        while (shouldStopScanner()) {
+            sleep(2);
+        }
+
     }
 
     return MEDIA_SCAN_RESULT_OK;
diff -ur ../aosp/frameworks/av/media/libmediaplayerservice/Android.mk ../Desktop/android/frameworks/av/media/libmediaplayerservice/Android.mk
--- ../aosp/frameworks/av/media/libmediaplayerservice/Android.mk	2018-08-06 15:40:15.239065545 +0200
+++ ../Desktop/android/frameworks/av/media/libmediaplayerservice/Android.mk	2017-11-23 05:21:08.000000000 +0100
@@ -5,6 +5,7 @@
 #
 
 include $(CLEAR_VARS)
+include $(LOCAL_PATH)/../libcedarx/config.mk
 
 LOCAL_SRC_FILES:=               \
     ActivityManager.cpp         \
@@ -16,6 +17,7 @@
     RemoteDisplay.cpp           \
     StagefrightRecorder.cpp     \
     TestPlayerStub.cpp          \
+    SimpleMediaFormatProbe.cpp
 
 LOCAL_SHARED_LIBRARIES :=       \
     libbinder                   \
@@ -37,6 +39,11 @@
     libstagefright_wfd          \
     libutils                    \
     libvorbisidec               \
+    libxplayer                  \
+    libaw_output                \
+    libawmetadataretriever      \
+    libawplayer                 \
+    libisomountmanagerservice
 
 LOCAL_STATIC_LIBRARIES :=       \
     libstagefright_nuplayer     \
@@ -54,6 +61,11 @@
     $(TOP)/frameworks/native/include/media/hardware                 \
     $(TOP)/external/tremolo/Tremolo                                 \
     libcore/include                                                 \
+    $(TOP)/frameworks/av/media/libcedarx/android_adapter/awplayer/   \
+    $(TOP)/frameworks/av/media/libcedarx/android_adapter/output/   \
+    $(TOP)/frameworks/av/media/libcedarx/android_adapter/metadataretriever/       \
+    $(TOP)/frameworks/av/media/libcedarc/include  \
+    $(TOP)/hardware/aw/include \
 
 LOCAL_CFLAGS += -Werror -Wno-error=deprecated-declarations -Wall
 LOCAL_CLANG := true
diff -ur ../aosp/frameworks/av/media/libmediaplayerservice/MediaPlayerFactory.cpp ../Desktop/android/frameworks/av/media/libmediaplayerservice/MediaPlayerFactory.cpp
--- ../aosp/frameworks/av/media/libmediaplayerservice/MediaPlayerFactory.cpp	2018-08-06 15:40:15.239065545 +0200
+++ ../Desktop/android/frameworks/av/media/libmediaplayerservice/MediaPlayerFactory.cpp	2017-11-23 05:21:08.000000000 +0100
@@ -24,6 +24,7 @@
 #include <media/stagefright/DataSource.h>
 #include <media/stagefright/FileSource.h>
 #include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/Utils.h>
 #include <utils/Errors.h>
 #include <utils/misc.h>
 #include <../libstagefright/include/WVMExtractor.h>
@@ -33,12 +34,156 @@
 #include "TestPlayerStub.h"
 #include "nuplayer/NuPlayerDriver.h"
 
+#include "SimpleMediaFormatProbe.h"
+#include "awplayer.h"
+
+#include <binder/IPCThreadState.h>
+#include <fcntl.h>
+
 namespace android {
 
 Mutex MediaPlayerFactory::sLock;
 MediaPlayerFactory::tFactoryMap MediaPlayerFactory::sFactoryMap;
 bool MediaPlayerFactory::sInitComplete = false;
 
+// TODO: Temp hack until we can register players
+typedef struct
+{
+    const char *extension;
+    player_type playertype;
+} extmap;
+
+static extmap FILE_EXTS [] =
+{
+	{".ogg",  AW_PLAYER},
+	{".mp3",  AW_PLAYER},
+	{".wav",  AW_PLAYER},
+	{".amr",  AW_PLAYER},
+	{".flac", AW_PLAYER},
+	{".m4a",  AW_PLAYER},
+	{".m4r",  AW_PLAYER},
+	{".3gpp", AW_PLAYER},
+	{".out",  AW_PLAYER},
+	{".3gp",  AW_PLAYER},
+	{".aac",  AW_PLAYER},
+
+	{".mid",  NU_PLAYER},
+	{".midi", NU_PLAYER},
+	{".smf",  NU_PLAYER},
+	{".xmf",  NU_PLAYER},
+	{".mxmf", NU_PLAYER},
+	{".imy",  NU_PLAYER},
+	{".rtttl",NU_PLAYER},
+	{".rtx",  NU_PLAYER},
+	{".ota",  NU_PLAYER},
+	{".wvm",  NU_PLAYER},
+
+	{".ape", AW_PLAYER},
+	{".ac3", AW_PLAYER},
+	{".dts", AW_PLAYER},
+	{".wma", AW_PLAYER},
+	{".aac", AW_PLAYER},
+	{".mp2", AW_PLAYER},
+    {".mp1", AW_PLAYER},
+    {".ra", AW_PLAYER},
+
+};
+
+player_type getPlayerType_l(int fd, int64_t offset, int64_t /*length*/)
+{
+	int r_size;
+	int file_format;
+
+	char buf[4096] = {0};
+	lseek(fd, offset, SEEK_SET);
+	r_size = read(fd, buf, sizeof(buf));
+	lseek(fd, offset, SEEK_SET);
+
+	// Ogg vorbis?
+	if (!memcmp(buf, "OggS", 4)) {
+		return AW_PLAYER;
+	} else if (!memcmp(buf, "MThd", 4)) {
+		return NU_PLAYER;
+	}
+
+	// Modify for CTS
+	if(property_get_bool("media.stagefright.mode", false))
+	{
+		file_format = audio_format_detect((unsigned char*)buf, r_size, fd, offset);
+		ALOGD("cts.media  audio_format_detect[%d]",file_format);
+		if (file_format == MEDIA_FORMAT_MP3 || file_format == MEDIA_FORMAT_M4A ||
+		    file_format == MEDIA_FORMAT_WAV || file_format == MEDIA_FORMAT_STAGEFRIGHT_MIN)
+		{
+			ALOGD("cts.media using NU_PLAYER");
+			return NU_PLAYER;
+		}
+	}
+
+    AString filePath = nameForFd(fd);
+    for (size_t i = 0; i < ARRAY_SIZE(FILE_EXTS); ++i)
+    {
+        if (filePath.endsWithIgnoreCase(FILE_EXTS[i].extension))
+            return FILE_EXTS[i].playertype;
+    }
+
+	return AW_PLAYER;
+}
+
+player_type getPlayerType_l(const char* url)
+{
+	char *strpos;
+
+	if (TestPlayerStub::canBeUsed(url))
+	{
+	        return TEST_PLAYER;
+	}
+
+	if (!strncasecmp("http://", url, 7) || !strncasecmp("https://", url, 8))
+	{
+		if((strpos = strrchr(url,'?')) != NULL)
+		{
+			for (int i = 0; i < NELEM(FILE_EXTS); ++i)
+			{
+				int len = strlen(FILE_EXTS[i].extension);
+				if (!strncasecmp(strpos -len, FILE_EXTS[i].extension, len))
+				{
+					return FILE_EXTS[i].playertype;
+				}
+			}
+		}
+	}
+
+    if (!strncmp("widevine://", url, strlen("widevine://")))
+    {
+        ALOGD("widevine stream using NU_PLAYER");
+        return NU_PLAYER;
+    }
+
+	if (!strncmp("data:;base64", url, strlen("data:;base64")))
+	{
+		return NU_PLAYER;
+	}
+
+	// use MidiFile for MIDI extensions
+	int lenURL = strlen(url);
+	int len;
+	int start;
+	for (int i = 0; i < NELEM(FILE_EXTS); ++i)
+	{
+	    len = strlen(FILE_EXTS[i].extension);
+	    start = lenURL - len;
+	    if (start > 0)
+	    {
+	        if (!strncasecmp(url + start, FILE_EXTS[i].extension, len))
+	        {
+	            return FILE_EXTS[i].playertype;
+	        }
+	    }
+	}
+
+	return AW_PLAYER;
+}
+
 status_t MediaPlayerFactory::registerFactory_l(IFactory* factory,
                                                player_type type) {
     if (NULL == factory) {
@@ -63,7 +208,11 @@
 }
 
 static player_type getDefaultPlayerType() {
+#if 0
     return NU_PLAYER;
+#else
+    return AW_PLAYER;
+#endif
 }
 
 status_t MediaPlayerFactory::registerFactory(IFactory* factory,
@@ -77,10 +226,34 @@
     sFactoryMap.removeItem(type);
 }
 
+#define GET_PLAYER_TYPE_IMPL_ORIGINAL(a...)                      \
+    Mutex::Autolock lock_(&sLock);                      \
+                                                        \
+    player_type ret = NU_PLAYER;                      \
+    float bestScore = 0.0;                              \
+                                                        \
+    for (size_t i = 0; i < sFactoryMap.size(); ++i) {   \
+                                                        \
+        IFactory* v = sFactoryMap.valueAt(i);           \
+        float thisScore;                                \
+        CHECK(v != NULL);                               \
+        thisScore = v->scoreFactory(a, bestScore);      \
+        if (thisScore > bestScore) {                    \
+            ret = sFactoryMap.keyAt(i);                 \
+            bestScore = thisScore;                      \
+        }                                               \
+    }                                                   \
+                                                        \
+    if (0.0 == bestScore) {                             \
+        bestScore = getDefaultPlayerType();             \
+    }                                                   \
+                                                        \
+    return ret;
+
 #define GET_PLAYER_TYPE_IMPL(a...)                      \
     Mutex::Autolock lock_(&sLock);                      \
                                                         \
-    player_type ret = STAGEFRIGHT_PLAYER;               \
+    player_type ret = AW_PLAYER;               \
     float bestScore = 0.0;                              \
                                                         \
     for (size_t i = 0; i < sFactoryMap.size(); ++i) {   \
@@ -101,26 +274,44 @@
                                                         \
     return ret;
 
-player_type MediaPlayerFactory::getPlayerType(const sp<IMediaPlayer>& client,
+player_type MediaPlayerFactory::getPlayerType(const sp<IMediaPlayer>& /*client*/,
                                               const char* url) {
+    ALOGV("MediaPlayerFactory::getPlayerType: url = %s", url);
+
+    return android::getPlayerType_l(url);
+
+#if 0
     GET_PLAYER_TYPE_IMPL(client, url);
+#endif
+
 }
 
-player_type MediaPlayerFactory::getPlayerType(const sp<IMediaPlayer>& client,
+player_type MediaPlayerFactory::getPlayerType(const sp<IMediaPlayer>& /*client*/,
                                               int fd,
                                               int64_t offset,
                                               int64_t length) {
+
+#if 0
     GET_PLAYER_TYPE_IMPL(client, fd, offset, length);
+#else
+    return android::getPlayerType_l(fd, offset, length);
+#endif
 }
 
-player_type MediaPlayerFactory::getPlayerType(const sp<IMediaPlayer>& client,
-                                              const sp<IStreamSource> &source) {
+player_type MediaPlayerFactory::getPlayerType(const sp<IMediaPlayer>& /*client*/,
+                                              const sp<IStreamSource> & /*source*/) {
+#if 0
     GET_PLAYER_TYPE_IMPL(client, source);
+#endif
+    return getDefaultPlayerType(); // default using AW_PLAYER
 }
 
-player_type MediaPlayerFactory::getPlayerType(const sp<IMediaPlayer>& client,
-                                              const sp<DataSource> &source) {
+player_type MediaPlayerFactory::getPlayerType(const sp<IMediaPlayer>& /*client*/,
+                                              const sp<DataSource> & /*source*/) {
+#if 0
     GET_PLAYER_TYPE_IMPL(client, source);
+#endif
+    return NU_PLAYER;
 }
 
 #undef GET_PLAYER_TYPE_IMPL
@@ -240,12 +431,63 @@
     }
 };
 
+class AwPlayerFactory : public MediaPlayerFactory::IFactory {
+  public:
+    virtual float scoreFactory(const sp<IMediaPlayer>& /*client*/,
+                               int /*fd*/,
+                               int64_t /*offset*/,
+                               int64_t /*length*/,
+                               float /*curScore*/) {
+
+        return 0.0;
+    }
+
+    virtual sp<MediaPlayerBase> createPlayer(pid_t /* pid */) {
+        ALOGV(" create AwPlayer");
+        return new AwPlayer();
+    }
+};
+#if 0 // not support in box. (bz)
+class TPlayerFactory : public MediaPlayerFactory::IFactory {
+  public:
+    virtual float scoreFactory(const sp<IMediaPlayer>& client,
+                               int fd,
+                               int64_t offset,
+                               int64_t length,
+                               float curScore) {
+
+        return 0.0;
+    }
+
+    virtual sp<MediaPlayerBase> createPlayer() {
+        ALOGV(" create TPlayer");
+        return new TPlayer();
+    }
+};
+#endif
+
+static void updateFILE_EXTS()
+{
+    if (!property_get_bool("media.stagefright.mode", false))
+        return;
+
+    for (size_t i = 0; i < ARRAY_SIZE(FILE_EXTS); ++i) {
+        if (!strcmp(FILE_EXTS[i].extension, ".mp3"))
+            FILE_EXTS[i].playertype = NU_PLAYER;
+    }
+}
+
 void MediaPlayerFactory::registerBuiltinFactories() {
     Mutex::Autolock lock_(&sLock);
 
     if (sInitComplete)
         return;
 
+    updateFILE_EXTS();
+    registerFactory_l(new AwPlayerFactory(), AW_PLAYER);
+
+//	tplayer not support in box. (bz)
+//	registerFactory_l(new TPlayerFactory(), THUMBNAIL_PLAYER);
     registerFactory_l(new NuPlayerFactory(), NU_PLAYER);
     registerFactory_l(new TestPlayerFactory(), TEST_PLAYER);
 
diff -ur ../aosp/frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp ../Desktop/android/frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp
--- ../aosp/frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp	2018-08-06 15:40:15.239065545 +0200
+++ ../Desktop/android/frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp	2017-11-23 05:21:08.000000000 +0100
@@ -72,6 +72,7 @@
 #include "MediaPlayerService.h"
 #include "MetadataRetrieverClient.h"
 #include "MediaPlayerFactory.h"
+#include <isomount/IISOMountManagerService.h>
 
 #include "TestPlayerStub.h"
 #include "nuplayer/NuPlayerDriver.h"
@@ -238,7 +239,7 @@
             size_t tagSize = realTagSize > AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 ?
                     AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 : realTagSize;
             utf16_to_utf8(tags.string(), tagSize, attributes->tags,
-                    sizeof(attributes->tags) / sizeof(attributes->tags[0]));
+				sizeof(attributes->tags) / sizeof(attributes->tags[0]));
         }
     } else {
         ALOGE("unmarshallAudioAttributes() received unflattened tags, ignoring tag values");
@@ -250,6 +251,76 @@
 
 namespace android {
 
+#define ISO_MOUNT_PATH "/mnt/bluray"
+static const char *BDMV_URL = "bdmv://" ISO_MOUNT_PATH;
+
+static int isoMount(sp<IBinder> binder, const char *isoPath)
+{
+    sp<IISOMountManagerService> isoManager;
+
+    if (binder.get() == NULL) {
+        const sp<IServiceManager> sm(defaultServiceManager());
+        binder = sm->getService(String16("softwinner.isomountmanager"));
+        if (binder != 0) {
+            isoManager =interface_cast<IISOMountManagerService>(binder);
+        }
+    } else {
+        isoManager =interface_cast<IISOMountManagerService>(binder);
+    }
+
+    if (isoManager.get() != NULL) {
+        isoManager->umountAll();
+
+        if (isoManager->isoMount(ISO_MOUNT_PATH, isoPath) < 0)
+        {
+            ALOGE("mount iso failed!");
+            return -1;
+        }
+        return 0;
+    }
+
+    ALOGE("isoManager is null");
+    return -1;
+}
+
+static int isoUmount(sp<IBinder> binder)
+{
+    sp<IISOMountManagerService> isoManager;
+
+    if (binder.get() == NULL) {
+        const sp<IServiceManager> sm(defaultServiceManager());
+        binder = sm->getService(String16("softwinner.isomountmanager"));
+        if (binder != 0) {
+            isoManager =interface_cast<IISOMountManagerService>(binder);
+        }
+    } else {
+        isoManager =interface_cast<IISOMountManagerService>(binder);
+    }
+
+    if (isoManager.get() != NULL) {
+        return isoManager->umountAll();
+    }
+
+    return -1;
+}
+
+uint32_t MediaPlayerService::Client::checkAndMountISO(const char *filePath)
+{
+    if (strncasecmp(filePath + strlen(filePath) - 4, ".iso", 4))
+        return 'pass';
+
+    if (isoMount(isoManager, filePath) < 0)
+        return 'fail';
+
+    if (access(ISO_MOUNT_PATH "/BDMV/STREAM", R_OK)) {
+        ALOGW("not looks like bluray");
+        isoUmount(isoManager);
+        return 'fail';
+    }
+
+    return 'good';
+}
+
 extern ALooperRoster gLooperRoster;
 
 
@@ -264,11 +335,61 @@
 /* static */ int MediaPlayerService::AudioOutput::mMinBufferCount = 4;
 /* static */ bool MediaPlayerService::AudioOutput::mIsOnEmulator = false;
 
+static MediaPlayerService *gMediaPlayerService;
 void MediaPlayerService::instantiate() {
+    gMediaPlayerService = new MediaPlayerService();
     defaultServiceManager()->addService(
-            String16("media.player"), new MediaPlayerService());
+            String16("media.player"), gMediaPlayerService);
 }
 
+// Previous signal handler state, restored after first hit.
+static struct sigaction gOrigSigactionINT;
+static struct sigaction gOrigSigactionHUP;
+static struct sigaction gOrigSigactionQUIT;
+static struct sigaction gOrigSigactionTERM;
+
+static void handleSignal(int signo)
+{
+    ALOGD("handleSignal signo=%d, gMediaPlayerService=%p", signo, gMediaPlayerService);
+    gMediaPlayerService->removeResource();
+    switch (signo) {
+    case SIGHUP:
+    case SIGINT:
+    case SIGQUIT:
+    case SIGTERM:
+        sigaction(SIGHUP, &gOrigSigactionHUP, NULL);
+        sigaction(SIGINT, &gOrigSigactionINT, NULL);
+        sigaction(SIGQUIT, &gOrigSigactionQUIT, NULL);
+        sigaction(SIGTERM, &gOrigSigactionTERM, NULL);
+        kill(getpid(), signo);
+        break;
+    default:
+        break;
+    }
+}
+
+static void registerSigHandler()
+{
+    struct sigaction sa;
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = 0;
+    sa.sa_handler = handleSignal;
+    if (sigaction(SIGHUP, &sa, &gOrigSigactionHUP) != 0) {
+        ALOGE("Unable to configure SIGHUP handler: %s", strerror(errno));
+    }
+    if (sigaction(SIGINT, &sa, &gOrigSigactionINT) != 0) {
+        ALOGE("Unable to configure SIGINT handler: %s", strerror(errno));
+    }
+    if (sigaction(SIGQUIT, &sa, &gOrigSigactionQUIT) != 0) {
+        ALOGE("Unable to configure SIGQUIT handler: %s", strerror(errno));
+    }
+    if (sigaction(SIGTERM, &sa, &gOrigSigactionTERM) != 0) {
+        ALOGE("Unable to configure SIGTERM handler: %s", strerror(errno));
+    }
+    ALOGD("MediaPlayerService registerSigHandler");
+}
+
+
 MediaPlayerService::MediaPlayerService()
 {
     ALOGV("MediaPlayerService created");
@@ -289,6 +410,8 @@
     BatteryNotifier::getInstance().noteResetVideo();
 
     MediaPlayerFactory::registerBuiltinFactories();
+
+    registerSigHandler();
 }
 
 MediaPlayerService::~MediaPlayerService()
@@ -416,6 +539,12 @@
     return NO_ERROR;
 }
 
+void MediaPlayerService::Client::removeResource()
+{
+    mPlayer->stop();
+    mPlayer = NULL;
+}
+
 /**
  * The only arguments this understands right now are -c, -von and -voff,
  * which are parsed by ALooperRoster::dump()
@@ -564,6 +693,15 @@
     return mClients.indexOf(client) != NAME_NOT_FOUND;
 }
 
+void MediaPlayerService::removeResource()
+{
+    Mutex::Autolock lock(mLock);
+    for (int i = 0, n = mClients.size(); i < n; ++i) {
+        sp<Client> c = mClients[i].promote();
+        if (c != 0) c->removeResource();
+    }
+}
+
 MediaPlayerService::Client::Client(
         const sp<MediaPlayerService>& service, pid_t pid,
         int32_t connId, const sp<IMediaPlayerClient>& client,
@@ -580,6 +718,7 @@
     mUID = uid;
     mRetransmitEndpointValid = false;
     mAudioAttributes = NULL;
+    isBlurayISO = false;
 
 #if CALLBACK_ANTAGONIZER
     ALOGD("create Antagonizer");
@@ -742,6 +881,19 @@
         }
     }
 
+    if (strncasecmp(url, "file://", 7) == 0) {
+        switch (checkAndMountISO(url + 7)) {
+            case 'pass':
+                break;
+            case 'good':
+                isBlurayISO = true;
+                url = BDMV_URL;
+                break;
+            case 'fail':
+                return UNKNOWN_ERROR;
+        }
+    }
+
     if (strncmp(url, "content://", 10) == 0) {
         // get a filedescriptor for the content Uri and
         // pass it to the setDataSource(fd) method
@@ -794,6 +946,26 @@
         ALOGV("calculated length = %lld", (long long)length);
     }
 
+    // check if it is bluray
+    {
+        char fdInProc[128] = {0};
+        snprintf(fdInProc, sizeof(fdInProc), "proc/self/fd/%d", fd);
+        char filePath[1024] = {0};
+        ssize_t len = readlink(fdInProc, filePath, sizeof(filePath) - 1);
+        ALOGV("file path %s", filePath);
+        if (len > 0) {
+            switch (checkAndMountISO(filePath)) {
+                case 'pass':
+                    break;
+                case 'good':
+                    isBlurayISO = true;
+                    return setDataSource(NULL, BDMV_URL, NULL);
+                case 'fail':
+                    return UNKNOWN_ERROR;
+            }
+        }
+    }
+
     player_type playerType = MediaPlayerFactory::getPlayerType(this,
                                                                fd,
                                                                offset,
@@ -991,7 +1163,13 @@
     ALOGV("[%d] stop", mConnId);
     sp<MediaPlayerBase> p = getPlayer();
     if (p == 0) return UNKNOWN_ERROR;
-    return p->stop();
+
+    status_t ret = p->stop();
+
+    if (isBlurayISO)
+        isoUmount(isoManager);
+
+    return ret;
 }
 
 status_t MediaPlayerService::Client::pause()
@@ -1127,7 +1305,13 @@
     mRetransmitEndpointValid = false;
     sp<MediaPlayerBase> p = getPlayer();
     if (p == 0) return UNKNOWN_ERROR;
-    return p->reset();
+
+    status_t ret = p->reset();
+
+    if (isBlurayISO)
+        isoUmount(isoManager);
+
+    return ret;
 }
 
 status_t MediaPlayerService::Client::setAudioStreamType(audio_stream_type_t type)
diff -ur ../aosp/frameworks/av/media/libmediaplayerservice/MediaPlayerService.h ../Desktop/android/frameworks/av/media/libmediaplayerservice/MediaPlayerService.h
--- ../aosp/frameworks/av/media/libmediaplayerservice/MediaPlayerService.h	2018-08-06 15:40:15.239065545 +0200
+++ ../Desktop/android/frameworks/av/media/libmediaplayerservice/MediaPlayerService.h	2017-11-23 05:21:08.000000000 +0100
@@ -227,6 +227,7 @@
 
             void                removeClient(wp<Client> client);
             bool                hasClient(wp<Client> client);
+            void                removeResource();
 
     enum {
         MEDIASERVER_PROCESS_DEATH = 0,
@@ -341,6 +342,7 @@
         virtual status_t        dump(int fd, const Vector<String16>& args);
 
                 audio_session_t getAudioSessionId() { return mAudioSessionId; }
+                void            removeResource();
 
     private:
         class ServiceDeathNotifier: public IBinder::DeathRecipient
@@ -390,6 +392,8 @@
 
         status_t setAudioAttributes_l(const Parcel &request);
 
+        uint32_t checkAndMountISO(const char *filePath);
+
         mutable     Mutex                       mLock;
                     sp<MediaPlayerBase>         mPlayer;
                     sp<MediaPlayerService>      mService;
@@ -420,6 +424,10 @@
 
         sp<IBinder::DeathRecipient> mExtractorDeathListener;
         sp<IBinder::DeathRecipient> mCodecDeathListener;
+
+        sp<IBinder> isoManager;
+        bool isBlurayISO;
+
 #if CALLBACK_ANTAGONIZER
                     Antagonizer*                mAntagonizer;
 #endif
diff -ur ../aosp/frameworks/av/media/libmediaplayerservice/MetadataRetrieverClient.cpp ../Desktop/android/frameworks/av/media/libmediaplayerservice/MetadataRetrieverClient.cpp
--- ../aosp/frameworks/av/media/libmediaplayerservice/MetadataRetrieverClient.cpp	2018-08-06 15:40:15.239065545 +0200
+++ ../Desktop/android/frameworks/av/media/libmediaplayerservice/MetadataRetrieverClient.cpp	2017-11-23 05:21:08.000000000 +0100
@@ -40,6 +40,7 @@
 #include "MetadataRetrieverClient.h"
 #include "StagefrightMetadataRetriever.h"
 #include "MediaPlayerFactory.h"
+#include "awmetadataretriever.h"
 
 namespace android {
 
@@ -91,6 +92,11 @@
             p = new StagefrightMetadataRetriever;
             break;
         }
+        case AW_PLAYER:
+        {
+            p = new AwMetadataRetriever;
+            break;
+        }
         default:
             // TODO:
             // support for TEST_PLAYER
Only in ../Desktop/android/frameworks/av/media/libmediaplayerservice: SimpleMediaFormatProbe.cpp
Only in ../Desktop/android/frameworks/av/media/libmediaplayerservice: SimpleMediaFormatProbe.h
diff -ur ../aosp/frameworks/av/media/libstagefright/ACodec.cpp ../Desktop/android/frameworks/av/media/libstagefright/ACodec.cpp
--- ../aosp/frameworks/av/media/libstagefright/ACodec.cpp	2018-08-06 15:40:15.271065956 +0200
+++ ../Desktop/android/frameworks/av/media/libstagefright/ACodec.cpp	2017-11-23 05:21:08.000000000 +0100
@@ -55,6 +55,11 @@
 #include "include/DataConverter.h"
 #include "omx/OMXUtils.h"
 
+#include <hardware/sunxi_metadata_def.h>
+
+#include "vdecoder.h"
+
+
 namespace android {
 
 enum {
@@ -182,6 +187,19 @@
                             omx_msg.u.extended_buffer_data.timestamp);
                     msg->setInt32(
                             "fence_fd", omx_msg.fenceFd);
+
+                    //extend for hdr
+                    msg->setInt32("matrix_coeffs",
+                                   omx_msg.u.extended_buffer_data.ext_matrix_coeffs);
+                    msg->setInt32("video_full_range",
+                                   omx_msg.u.extended_buffer_data.ext_video_full_range_flag);
+                    msg->setInt32("transfer_characteristics",
+                                   omx_msg.u.extended_buffer_data.ext_transfer_characteristics);
+
+                    ALOGV("*** ACODEC-observer: %d, %d, %d",
+                          omx_msg.u.extended_buffer_data.ext_matrix_coeffs,
+                          omx_msg.u.extended_buffer_data.ext_video_full_range_flag,
+                          omx_msg.u.extended_buffer_data.ext_transfer_characteristics);
                     break;
                 }
 
@@ -524,7 +542,9 @@
       mCreateInputBuffersSuspended(false),
       mTunneled(false),
       mDescribeColorAspectsIndex((OMX_INDEXTYPE)0),
-      mDescribeHDRStaticInfoIndex((OMX_INDEXTYPE)0) {
+      mDescribeHDRStaticInfoIndex((OMX_INDEXTYPE)0),
+      mExtendFlag(0),
+      mFirstPTS(false) {
     mUninitializedState = new UninitializedState(this);
     mLoadedState = new LoadedState(this);
     mLoadedToIdleState = new LoadedToIdleState(this);
@@ -863,6 +883,9 @@
                 info.mFenceFd = -1;
                 info.mRenderInfo = NULL;
                 info.mNativeHandle = NULL;
+                info.mTransferCharacteristics = 0;
+                info.mMatrixCoeffs = 0;
+                info.mVideoFullRange = 0;
 
                 uint32_t requiresAllocateBufferBit =
                     (portIndex == kPortIndexInput)
@@ -888,8 +911,15 @@
                     // because Widevine source only receives these base addresses.
                     const native_handle_t *native_handle_ptr =
                         native_handle == NULL ? NULL : native_handle->handle();
+                    void* dataPtr = (void *)(native_handle_ptr);
+                    if(native_handle_ptr != NULL)
+                    {
+                        if(native_handle_ptr->numFds == 0 && native_handle_ptr->numInts == 1) {
+                            dataPtr = (void*)(uintptr_t)native_handle_ptr->data[0];
+                        }
+                    }
                     info.mData = new ABuffer(
-                            ptr != NULL ? ptr : (void *)native_handle_ptr, bufSize);
+                            ptr != NULL ? ptr : (void *)dataPtr, bufSize);
                     info.mNativeHandle = native_handle;
                     info.mCodecData = info.mData;
                 } else if (mQuirks & requiresAllocateBufferBit) {
@@ -978,17 +1008,66 @@
     }
 
     usage |= kVideoGrallocUsage;
+
+    OMX_U32 nExtendFlag = 0;
+    OMX_INDEXTYPE index = OMX_IndexComponentStartUnused;
+    err = mOMX->getExtensionIndex(
+            mNode,
+            "OMX.google.android.index.getAfbcHdrFlag",
+            &index);
+
+    ALOGD("** get afbchdr index: %d, %d, %x",err, OK, index);
+    if(err == OK)
+    {
+        OMX_U32 tmpExtendFlag[2]= {0};
+        err = mOMX->getParameter(
+                mNode, index,
+                &tmpExtendFlag, sizeof(OMX_U32)*2);
+        ALOGD("** get afbchdr nExtendFlag: %d, %d, %x, %x",err, OK,
+                 tmpExtendFlag[0], tmpExtendFlag[1]);
+
+        if(err == OK)
+            nExtendFlag = tmpExtendFlag[0];
+    }
+
+    int nPiexlFormat = 0;
+
+    if((nExtendFlag & AW_VIDEO_HDR_FLAG) || (nExtendFlag & AW_VIDEO_AFBC_FLAG))
+    {
+        ALOGD("**** set the usage :  GRALLOC_USAGE_METADATA_BUF");
+        usage |= GRALLOC_USAGE_METADATA_BUF;
+    }
+
+    if(nExtendFlag & AW_VIDEO_AFBC_FLAG)
+    {
+        ALOGD("**** set the usage :  GRALLOC_USAGE_AFBC_MODE");
+        usage |= GRALLOC_USAGE_AFBC_MODE;
+    }
+
+    if((nExtendFlag & AW_VIDEO_10BIT_FLAG)
+       && def.format.video.eColorFormat == OMX_COLOR_FormatYUV420Planar)
+    {
+        ALOGD("**** set the format :  HAL_PIXEL_FORMAT_AW_YV12_10bit");
+        nPiexlFormat = HAL_PIXEL_FORMAT_AW_YV12_10bit;
+    }
+
+    mExtendFlag = nExtendFlag;
+
     *finalUsage = usage;
 
     memset(&mLastNativeWindowCrop, 0, sizeof(mLastNativeWindowCrop));
     mLastNativeWindowDataSpace = HAL_DATASPACE_UNKNOWN;
 
     ALOGV("gralloc usage: %#x(OMX) => %#x(ACodec)", omxUsage, usage);
+
+    if(nPiexlFormat == 0)
+        nPiexlFormat = def.format.video.eColorFormat;
+
     return setNativeWindowSizeFormatAndUsage(
             nativeWindow,
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
-            def.format.video.eColorFormat,
+            nPiexlFormat,
             mRotationDegrees,
             usage,
             reconnect);
@@ -1122,6 +1201,10 @@
         info.mData = new ABuffer(NULL /* data */, bufferSize /* capacity */);
         info.mCodecData = info.mData;
         info.mGraphicBuffer = graphicBuffer;
+        info.mTransferCharacteristics = 0;
+        info.mMatrixCoeffs = 0;
+        info.mVideoFullRange = 0;
+
         mBuffers[kPortIndexOutput].push(info);
 
         IOMX::buffer_id bufferId;
@@ -1197,6 +1280,9 @@
         info.mRenderInfo = NULL;
         info.mGraphicBuffer = NULL;
         info.mDequeuedAt = mDequeueCounter;
+        info.mTransferCharacteristics = 0;
+        info.mMatrixCoeffs = 0;
+        info.mVideoFullRange = 0;
 
         sp<IMemory> mem = mDealer[kPortIndexOutput]->allocate(bufSize);
         if (mem == NULL || mem->pointer() == NULL) {
@@ -1669,6 +1755,30 @@
             "audio_decoder.flac", "audio_encoder.flac" },
         { MEDIA_MIMETYPE_AUDIO_MSGSM,
             "audio_decoder.gsm", "audio_encoder.gsm" },
+        { MEDIA_MIMETYPE_VIDEO_WMV1,
+            "video_decoder.wmv1", "video_encoder.wmv1" },
+        { MEDIA_MIMETYPE_VIDEO_WMV2,
+            "video_decoder.wmv2", "video_encoder.wmv2" },
+        { MEDIA_MIMETYPE_VIDEO_VC1,
+            "video_decoder.vc1", "video_encoder.vc1" },
+        { MEDIA_MIMETYPE_VIDEO_VP6,
+            "video_decoder.vp6", "video_encoder.vp6" },
+        { MEDIA_MIMETYPE_VIDEO_S263,
+            "video_decoder.s263", "video_encoder.s263" },
+        { MEDIA_MIMETYPE_VIDEO_MJPEG,
+            "video_decoder.mjpeg", "video_encoder.mjpeg" },
+        { MEDIA_MIMETYPE_VIDEO_MPEG1,
+            "video_decoder.mpeg1", "video_encoder.mpeg1" },
+        { MEDIA_MIMETYPE_VIDEO_MSMPEG4V1,
+            "video_decoder.msmpeg4v1", "video_encoder.msmpeg4v1" },
+        { MEDIA_MIMETYPE_VIDEO_MSMPEG4V2,
+            "video_decoder.msmpeg4v2", "video_encoder.msmpeg4v2" },
+        { MEDIA_MIMETYPE_VIDEO_DIVX,
+            "video_decoder.divx", "video_encoder.divx" },
+        { MEDIA_MIMETYPE_VIDEO_XVID,
+            "video_decoder.xvid", "video_encoder.xvid" },
+        { MEDIA_MIMETYPE_VIDEO_RXG2,
+            "video_decoder.rxg2", "video_encoder.rxg2" },
         { MEDIA_MIMETYPE_VIDEO_MPEG2,
             "video_decoder.mpeg2", "video_encoder.mpeg2" },
         { MEDIA_MIMETYPE_AUDIO_AC3,
@@ -3112,6 +3222,18 @@
     { MEDIA_MIMETYPE_VIDEO_VP8, OMX_VIDEO_CodingVP8 },
     { MEDIA_MIMETYPE_VIDEO_VP9, OMX_VIDEO_CodingVP9 },
     { MEDIA_MIMETYPE_VIDEO_DOLBY_VISION, OMX_VIDEO_CodingDolbyVision },
+    { MEDIA_MIMETYPE_VIDEO_WMV1, OMX_VIDEO_CodingWMV1},
+    { MEDIA_MIMETYPE_VIDEO_WMV2, OMX_VIDEO_CodingWMV2},
+    { MEDIA_MIMETYPE_VIDEO_VC1, OMX_VIDEO_CodingWMV},
+    { MEDIA_MIMETYPE_VIDEO_VP6, OMX_VIDEO_CodingVP6},
+    { MEDIA_MIMETYPE_VIDEO_S263, OMX_VIDEO_CodingS263},
+    { MEDIA_MIMETYPE_VIDEO_MJPEG, OMX_VIDEO_CodingMJPEG},
+    { MEDIA_MIMETYPE_VIDEO_MPEG1, OMX_VIDEO_CodingMPEG1},
+    { MEDIA_MIMETYPE_VIDEO_MSMPEG4V1, OMX_VIDEO_CodingMSMPEG4V1},
+    { MEDIA_MIMETYPE_VIDEO_MSMPEG4V2, OMX_VIDEO_CodingMSMPEG4V2},
+    { MEDIA_MIMETYPE_VIDEO_DIVX, OMX_VIDEO_CodingDIVX},
+    { MEDIA_MIMETYPE_VIDEO_XVID, OMX_VIDEO_CodingXVID},
+    { MEDIA_MIMETYPE_VIDEO_RXG2, OMX_VIDEO_CodingRXG2},
 };
 
 static status_t GetVideoCodingTypeFromMime(
@@ -5513,6 +5635,7 @@
             IOMX::buffer_id bufferID;
             CHECK(msg->findInt32("buffer", (int32_t*)&bufferID));
 
+            int32_t matrix_coeffs, video_full_range, transfer_characteristics;
             int32_t rangeOffset, rangeLength, flags, fenceFd;
             int64_t timeUs;
 
@@ -5522,6 +5645,24 @@
             CHECK(msg->findInt64("timestamp", &timeUs));
             CHECK(msg->findInt32("fence_fd", &fenceFd));
 
+            CHECK(msg->findInt32("matrix_coeffs", &matrix_coeffs));
+            CHECK(msg->findInt32("video_full_range", &video_full_range));
+            CHECK(msg->findInt32("transfer_characteristics", &transfer_characteristics));
+
+            ALOGV("** ACODEC-message: %d, %d, %d",
+                matrix_coeffs,  video_full_range, transfer_characteristics);
+
+            int32_t index;
+            BufferInfo *info =
+                mCodec->findBufferByID(kPortIndexOutput, bufferID, &index);
+
+            if(info)
+            {
+                info->mMatrixCoeffs = matrix_coeffs;
+                info->mVideoFullRange = video_full_range;
+                info->mTransferCharacteristics = transfer_characteristics;
+            }
+
             return onOMXFillBufferDone(
                     bufferID,
                     (size_t)rangeOffset, (size_t)rangeLength,
@@ -5724,6 +5865,15 @@
                 int64_t timeUs;
                 CHECK(buffer->meta()->findInt64("timeUs", &timeUs));
 
+                if ((!mCodec->mFirstPTS) && (timeUs > 0) && mCodec->mIsVideo) {
+                    mCodec->mFirstPTS = true;
+                }
+
+                if (mCodec->mFirstPTS && timeUs == 0 && mCodec->mIsVideo) {
+                   timeUs = -1;
+                   buffer->meta()->setInt64("timeUs", timeUs);
+                }
+
                 OMX_U32 flags = OMX_BUFFERFLAG_ENDOFFRAME;
 
                 MetadataBufferType metaType = mCodec->mInputMetadataType;
@@ -5798,6 +5948,8 @@
                 info->checkReadFence("onInputBufferFilled");
 
                 status_t err2 = OK;
+//by zhengjiangwei for Recorder in  Android N
+#if 1
                 switch (metaType) {
                 case kMetadataBufferTypeInvalid:
                     break;
@@ -5829,7 +5981,8 @@
                     err2 = ERROR_UNSUPPORTED;
                     break;
                 }
-
+//by zhengjiangwei for Recorder in Android N
+#endif
                 if (err2 == OK) {
                     err2 = mCodec->mOMX->emptyBuffer(
                         mCodec->mNode,
@@ -6111,6 +6264,123 @@
     return true;
 }
 
+static uint32_t getDataspace(int32_t mTransferCharacteristics,
+                                            int32_t mMatrixCoeffs,
+                                            int32_t mVideoFullRange)
+{
+    uint32_t space = HAL_DATASPACE_UNKNOWN;
+
+    switch (mTransferCharacteristics)
+    {
+        case VIDEO_TRANSFER_RESERVED_0:
+        case VIDEO_TRANSFER_BT1361:
+        case VIDEO_TRANSFER_UNSPECIFIED:
+        case VIDEO_TRANSFER_RESERVED_1:
+            space |= HAL_DATASPACE_TRANSFER_UNSPECIFIED;
+            break;
+        case VIDEO_TRANSFER_GAMMA2_2:
+            space |= HAL_DATASPACE_TRANSFER_GAMMA2_2;
+            break;
+        case VIDEO_TRANSFER_GAMMA2_8:
+            space |= HAL_DATASPACE_TRANSFER_GAMMA2_8;
+            break;
+        case VIDEO_TRANSFER_SMPTE_170M:
+            space |= HAL_DATASPACE_TRANSFER_SMPTE_170M;
+            break;
+        case VIDEO_TRANSFER_SMPTE_240M:
+            space |= HAL_DATASPACE_TRANSFER_UNSPECIFIED;
+            break;
+        case VIDEO_TRANSFER_LINEAR:
+            space |= HAL_DATASPACE_TRANSFER_LINEAR;
+            break;
+        case VIDEO_TRANSFER_LOGARITHMIC_0:
+        case VIDEO_TRANSFER_LOGARITHMIC_1:
+        case VIDEO_TRANSFER_IEC61966:
+        case VIDEO_TRANSFER_BT1361_EXTENDED:
+            space |= HAL_DATASPACE_TRANSFER_UNSPECIFIED;
+            break;
+        case VIDEO_TRANSFER_SRGB:
+            space |= HAL_DATASPACE_TRANSFER_SRGB;
+            break;
+        case VIDEO_TRANSFER_BT2020_0:
+        case VIDEO_TRANSFER_BT2020_1:
+            space |= HAL_DATASPACE_TRANSFER_UNSPECIFIED;
+            break;
+        case VIDEO_TRANSFER_ST2084:
+            space |= HAL_DATASPACE_TRANSFER_ST2084;
+            break;
+        case VIDEO_TRANSFER_ST428_1:
+            space |= HAL_DATASPACE_TRANSFER_UNSPECIFIED;
+            break;
+        case VIDEO_TRANSFER_HLG:
+            space |= HAL_DATASPACE_TRANSFER_HLG;
+            break;
+        default:
+            space |= HAL_DATASPACE_TRANSFER_UNSPECIFIED;
+            break;
+    }
+
+    switch (mMatrixCoeffs)
+    {
+        case VIDEO_MATRIX_COEFFS_IDENTITY:
+            space |= HAL_DATASPACE_STANDARD_UNSPECIFIED;
+            break;
+        case VIDEO_MATRIX_COEFFS_BT709:
+            space |= HAL_DATASPACE_STANDARD_BT709;
+            break;
+        case VIDEO_MATRIX_COEFFS_UNSPECIFIED_0:
+        case VIDEO_MATRIX_COEFFS_RESERVED_0:
+            space |= HAL_DATASPACE_STANDARD_UNSPECIFIED;
+            break;
+        case VIDEO_MATRIX_COEFFS_BT470M:
+            space |= HAL_DATASPACE_STANDARD_BT470M;
+            break;
+        case VIDEO_MATRIX_COEFFS_BT601_625_0:
+            space |= HAL_DATASPACE_BT601_625;
+            break;
+        case VIDEO_MATRIX_COEFFS_BT601_625_1:
+            space |= HAL_DATASPACE_BT601_525;
+            break;
+        case VIDEO_MATRIX_COEFFS_SMPTE_240M:
+        case VIDEO_MATRIX_COEFFS_YCGCO:
+            space |= HAL_DATASPACE_STANDARD_UNSPECIFIED;
+            break;
+        case VIDEO_MATRIX_COEFFS_BT2020:
+            space |= HAL_DATASPACE_STANDARD_BT2020;
+            break;
+        case VIDEO_MATRIX_COEFFS_BT2020_CONSTANT_LUMINANCE:
+            space |= HAL_DATASPACE_STANDARD_BT2020_CONSTANT_LUMINANCE;
+            break;
+        case VIDEO_MATRIX_COEFFS_SOMPATE:
+        case VIDEO_MATRIX_COEFFS_CD_NON_CONSTANT_LUMINANCE:
+        case VIDEO_MATRIX_COEFFS_CD_CONSTANT_LUMINANCE:
+        case VIDEO_MATRIX_COEFFS_BTICC:
+            space |= HAL_DATASPACE_STANDARD_UNSPECIFIED;
+            break;
+        default:
+            space |= HAL_DATASPACE_STANDARD_UNSPECIFIED;
+            break;
+    }
+
+    switch (mVideoFullRange)
+    {
+        case VIDEO_FULL_RANGE_LIMITED:
+            space |= HAL_DATASPACE_RANGE_LIMITED;
+            break;
+        case VIDEO_FULL_RANGE_FULL:
+            space |= HAL_DATASPACE_RANGE_FULL;
+            break;
+        default:
+        {
+            ALOGE("should not be here, mVideoFullRange = %d", mVideoFullRange);
+            //abort();
+        }
+    }
+
+    return space;
+}
+
+
 void ACodec::BaseState::onOutputBufferDrained(const sp<AMessage> &msg) {
     IOMX::buffer_id bufferID;
     CHECK(msg->findInt32("buffer-id", (int32_t*)&bufferID));
@@ -6132,12 +6402,28 @@
         ALOGW_IF(err != NO_ERROR, "failed to set crop: %d", err);
     }
 
-    int32_t dataSpace;
-    if (msg->findInt32("dataspace", &dataSpace)
-            && dataSpace != mCodec->mLastNativeWindowDataSpace) {
+    uint32_t dataSpace = 0;
+    if (mCodec->mExtendFlag & AW_VIDEO_HDR_FLAG) {
+        uint32_t hdr_dataspace = getDataspace(info->mTransferCharacteristics,
+                                                         info->mMatrixCoeffs,
+                                                         info->mVideoFullRange);
+        dataSpace |= hdr_dataspace;
+        ALOGV("*** hdr_dataspace = %x, %d, %d, %d", hdr_dataspace,
+               info->mMatrixCoeffs,
+               info->mVideoFullRange,
+               info->mTransferCharacteristics);
+    } else {
+        int32_t msgDataSpace;
+        if (msg->findInt32("dataspace", &msgDataSpace)) {
+            dataSpace |= (uint32_t)msgDataSpace;
+        }
+    }
+
+
+    if (dataSpace != 0 && dataSpace != (uint32_t)mCodec->mLastNativeWindowDataSpace) {
         status_t err = native_window_set_buffers_data_space(
                 mCodec->mNativeWindow.get(), (android_dataspace)dataSpace);
-        mCodec->mLastNativeWindowDataSpace = dataSpace;
+        mCodec->mLastNativeWindowDataSpace = (int32_t)dataSpace;
         ALOGW_IF(err != NO_ERROR, "failed to set dataspace: %d", err);
     }
 
@@ -6368,6 +6654,24 @@
     uint32_t quirks = 0;
     int32_t encoder = false;
     if (msg->findString("componentName", &componentName)) {
+        // for youtube choice the hw video decoder
+        if (componentName.startsWith("OMX.google")) {
+            ALOGV("OMX.google change to hw video decoder!");
+            if (componentName.find("h264.decoder") >= 0) {
+                componentName = "OMX.allwinner.video.decoder.avc";
+            } else if (componentName.find("hevc.decoder")>= 0) {
+                componentName = "OMX.allwinner.video.decoder.hevc";
+            } else if (componentName.find("mpeg4.decoder")>= 0) {
+                componentName = "OMX.allwinner.video.decoder.mpeg4";
+            } else if (componentName.find("h263.decoder")>= 0) {
+                componentName = "OMX.allwinner.video.decoder.h263";
+            } else if (componentName.find("vp8.decoder")>= 0) {
+                componentName = "OMX.allwinner.video.decoder.vp8";
+            } else if (componentName.find("vp9.decoder")>= 0) {
+                componentName = "OMX.allwinner.video.decoder.vp9";
+            }
+        }
+
         sp<IMediaCodecList> list = MediaCodecList::getInstance();
         if (list != NULL && list->findCodecByName(componentName.c_str()) >= 0) {
             matchingCodecs.add(componentName);
@@ -7144,6 +7448,9 @@
             if (err != OK) {
                 mCodec->signalError(OMX_ErrorUndefined, FAILED_TRANSACTION);
             } else {
+                if (mCodec->mIsVideo) {
+                    mCodec->mFirstPTS = false;
+                }
                 mCodec->changeState(mCodec->mFlushingState);
             }
 
diff -ur ../aosp/frameworks/av/media/libstagefright/Android.mk ../Desktop/android/frameworks/av/media/libstagefright/Android.mk
--- ../aosp/frameworks/av/media/libstagefright/Android.mk	2018-08-06 15:40:15.271065956 +0200
+++ ../Desktop/android/frameworks/av/media/libstagefright/Android.mk	2017-11-23 05:21:08.000000000 +0100
@@ -66,6 +66,7 @@
 
 LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/include/media/ \
+        $(TOP)/frameworks/av/media/libcedarc/include/ \
         $(TOP)/frameworks/av/include/media/stagefright/timedtext \
         $(TOP)/frameworks/native/include/media/hardware \
         $(TOP)/frameworks/native/include/media/openmax \
diff -ur ../aosp/frameworks/av/media/libstagefright/CameraSource.cpp ../Desktop/android/frameworks/av/media/libstagefright/CameraSource.cpp
--- ../aosp/frameworks/av/media/libstagefright/CameraSource.cpp	2018-08-06 15:40:15.275066008 +0200
+++ ../Desktop/android/frameworks/av/media/libstagefright/CameraSource.cpp	2017-11-23 05:21:08.000000000 +0100
@@ -866,7 +866,8 @@
             token = IPCThreadState::self()->clearCallingIdentity();
             isTokenValid = true;
         }
-        releaseQueuedFrames();
+        stopCameraRecording();
+
         while (!mFramesBeingEncoded.empty()) {
             if (NO_ERROR !=
                 mFrameCompleteCondition.waitRelative(mLock,
@@ -875,7 +876,7 @@
                     mFramesBeingEncoded.size());
             }
         }
-        stopCameraRecording();
+
         if (isTokenValid) {
             IPCThreadState::self()->restoreCallingIdentity(token);
         }
@@ -889,6 +890,7 @@
         if (mNumGlitches > 0) {
             ALOGW("%d long delays between neighboring video frames", mNumGlitches);
         }
+        releaseQueuedFrames();
 
         CHECK_EQ(mNumFramesReceived, mNumFramesEncoded + mNumFramesDropped);
     }
@@ -1035,6 +1037,7 @@
         if (!mStarted) {
             return OK;
         }
+
         frame = *mFramesReceived.begin();
         mFramesReceived.erase(mFramesReceived.begin());
 
@@ -1251,7 +1254,9 @@
     // buffer queue.
     switch (mVideoBufferMode) {
         case hardware::ICamera::VIDEO_BUFFER_MODE_DATA_CALLBACK_METADATA:
+            //by zhengjiangwei for Recorder in Android N
             return kMetadataBufferTypeNativeHandleSource;
+            //return kMetadataBufferTypeCameraSource;
         case hardware::ICamera::VIDEO_BUFFER_MODE_BUFFER_QUEUE:
             return kMetadataBufferTypeANWBuffer;
         default:
diff -ur ../aosp/frameworks/av/media/libstagefright/data/media_codecs_google_video.xml ../Desktop/android/frameworks/av/media/libstagefright/data/media_codecs_google_video.xml
--- ../aosp/frameworks/av/media/libstagefright/data/media_codecs_google_video.xml	2018-08-06 15:40:15.543069450 +0200
+++ ../Desktop/android/frameworks/av/media/libstagefright/data/media_codecs_google_video.xml	2017-11-23 05:21:09.000000000 +0100
@@ -79,7 +79,7 @@
         </MediaCodec>
         <MediaCodec name="OMX.google.h264.encoder" type="video/avc">
             <!-- profiles and levels:  ProfileBaseline : Level41 -->
-            <Limit name="size" min="16x16" max="1920x1088" />
+            <Limit name="size" min="16x16" max="1280x720" />
             <Limit name="alignment" value="2x2" />
             <Limit name="block-size" value="16x16" />
             <Limit name="blocks-per-second" range="1-244800" />
diff -ur ../aosp/frameworks/av/media/libstagefright/MediaDefs.cpp ../Desktop/android/frameworks/av/media/libstagefright/MediaDefs.cpp
--- ../aosp/frameworks/av/media/libstagefright/MediaDefs.cpp	2018-08-06 15:40:15.279066058 +0200
+++ ../Desktop/android/frameworks/av/media/libstagefright/MediaDefs.cpp	2017-11-23 05:21:09.000000000 +0100
@@ -29,7 +29,21 @@
 const char *MEDIA_MIMETYPE_VIDEO_MPEG2 = "video/mpeg2";
 const char *MEDIA_MIMETYPE_VIDEO_RAW = "video/raw";
 const char *MEDIA_MIMETYPE_VIDEO_DOLBY_VISION = "video/dolby-vision";
-
+const char *MEDIA_MIMETYPE_VIDEO_WMV1 = "video/wmv1";
+const char *MEDIA_MIMETYPE_VIDEO_WMV2 = "video/wmv2";
+const char *MEDIA_MIMETYPE_VIDEO_VC1 = "video/wvc1";
+//const char *MEDIA_MIMETYPE_VIDEO_VC1 = "video/x-ms-wmv";
+//const char *MEDIA_MIMETYPE_VIDEO_VP6 = "video/x-vp6";
+const char *MEDIA_MIMETYPE_VIDEO_VP6 = "video/x-vnd.on2.vp6";
+const char *MEDIA_MIMETYPE_VIDEO_S263 = "video/flv1";
+const char *MEDIA_MIMETYPE_VIDEO_MJPEG = "video/jpeg";
+const char *MEDIA_MIMETYPE_VIDEO_MPEG1 = "video/mpeg1";
+const char *MEDIA_MIMETYPE_VIDEO_MSMPEG4V1 = "video/x-ms-mpeg4v1";
+const char *MEDIA_MIMETYPE_VIDEO_MSMPEG4V2 = "video/x-ms-mpeg4v2";
+const char *MEDIA_MIMETYPE_VIDEO_DIVX = "video/divx";
+const char *MEDIA_MIMETYPE_VIDEO_XVID = "video/xvid";
+const char *MEDIA_MIMETYPE_VIDEO_RXG2 = "video/rvg2";
+const char *MEDIA_MIMETYPE_VIDEO_VPX = "video/x-vnd.on2.vp8";
 const char *MEDIA_MIMETYPE_AUDIO_AMR_NB = "audio/3gpp";
 const char *MEDIA_MIMETYPE_AUDIO_AMR_WB = "audio/amr-wb";
 const char *MEDIA_MIMETYPE_AUDIO_MPEG = "audio/mpeg";
diff -ur ../aosp/frameworks/av/media/libstagefright/omx/OMX.cpp ../Desktop/android/frameworks/av/media/libstagefright/omx/OMX.cpp
--- ../aosp/frameworks/av/media/libstagefright/omx/OMX.cpp	2018-08-06 15:40:15.555069603 +0200
+++ ../Desktop/android/frameworks/av/media/libstagefright/omx/OMX.cpp	2017-11-23 05:21:09.000000000 +0100
@@ -120,8 +120,25 @@
 
 void OMX::CallbackDispatcher::post(const omx_message &msg, bool realTime) {
     Mutex::Autolock autoLock(mLock);
+    // fill_buffer_done message first process than empty_buffer_done  message
+    if ((msg.type == omx_message::FILL_BUFFER_DONE) && (!(mQueue.empty()))) {
+      std::list<omx_message>::iterator it = mQueue.end();
+      do {
+        --it;
+        if ((*it).type != omx_message::EMPTY_BUFFER_DONE)
+            break;
+      } while (it != mQueue.begin());
+
+      if (it == mQueue.begin() && (*it).type == omx_message::EMPTY_BUFFER_DONE) {
+        mQueue.push_front(msg);
+      } else {
+        ++it;
+        mQueue.insert(it,msg);
+      }
+    } else {
+        mQueue.push_back(msg);
+    }
 
-    mQueue.push_back(msg);
     if (realTime) {
         mQueueChanged.signal();
     }
@@ -702,6 +719,7 @@
     return OMX_ErrorNone;
 }
 
+
 OMX_ERRORTYPE OMX::OnFillBufferDone(
         node_id node, buffer_id buffer, OMX_IN OMX_BUFFERHEADERTYPE *pBuffer, int fenceFd) {
     ALOGV("OnFillBufferDone buffer=%p", pBuffer);
@@ -716,6 +734,28 @@
     msg.u.extended_buffer_data.flags = pBuffer->nFlags;
     msg.u.extended_buffer_data.timestamp = pBuffer->nTimeStamp;
 
+    //extend for hdr
+    if(pBuffer->pOutputPortPrivate != NULL)
+    {
+
+        AW_OMX_VIDEO_HDR_INFO* pHdrInfo
+                        = (AW_OMX_VIDEO_HDR_INFO*)pBuffer->pOutputPortPrivate;
+        msg.u.extended_buffer_data.ext_matrix_coeffs            = pHdrInfo->nExtMatrixCoeffs;
+        msg.u.extended_buffer_data.ext_video_full_range_flag    = pHdrInfo->nExtVideoFullRangeFlag;
+        msg.u.extended_buffer_data.ext_transfer_characteristics
+            = pHdrInfo->nExtTransferCharacteristics;
+    }
+    else
+    {
+        msg.u.extended_buffer_data.ext_matrix_coeffs            = 0;
+        msg.u.extended_buffer_data.ext_video_full_range_flag    = 0;
+        msg.u.extended_buffer_data.ext_transfer_characteristics = 0;
+    }
+    ALOGV("*** OMX-HDR: %d, %d, %d",
+           msg.u.extended_buffer_data.ext_matrix_coeffs,
+           msg.u.extended_buffer_data.ext_video_full_range_flag,
+           msg.u.extended_buffer_data.ext_transfer_characteristics );
+
     findDispatcher(node)->post(msg);
 
     return OMX_ErrorNone;
diff -ur ../aosp/frameworks/av/media/libstagefright/omx/OMXNodeInstance.cpp ../Desktop/android/frameworks/av/media/libstagefright/omx/OMXNodeInstance.cpp
--- ../aosp/frameworks/av/media/libstagefright/omx/OMXNodeInstance.cpp	2018-08-06 15:40:15.555069603 +0200
+++ ../Desktop/android/frameworks/av/media/libstagefright/omx/OMXNodeInstance.cpp	2017-11-23 05:21:09.000000000 +0100
@@ -132,7 +132,9 @@
 
     void CopyToOMX(const OMX_BUFFERHEADERTYPE *header) {
         if (!mCopyToOmx) {
+            //add by fuqiang for camerasource encoding path,start
             return;
+            //add by fuqiang for camerasource encoding path,end
         }
 
         memcpy(header->pBuffer + header->nOffset,
diff -ur ../aosp/frameworks/av/media/libstagefright/StagefrightMediaScanner.cpp ../Desktop/android/frameworks/av/media/libstagefright/StagefrightMediaScanner.cpp
--- ../aosp/frameworks/av/media/libstagefright/StagefrightMediaScanner.cpp	2018-08-06 15:40:15.291066213 +0200
+++ ../Desktop/android/frameworks/av/media/libstagefright/StagefrightMediaScanner.cpp	2017-11-23 05:21:09.000000000 +0100
@@ -40,7 +40,10 @@
         ".mpeg", ".ogg", ".mid", ".smf", ".imy", ".wma", ".aac",
         ".wav", ".amr", ".midi", ".xmf", ".rtttl", ".rtx", ".ota",
         ".mkv", ".mka", ".webm", ".ts", ".fl", ".flac", ".mxmf",
-        ".avi", ".mpeg", ".mpg", ".awb", ".mpga"
+        ".avi", ".mpeg", ".mpg", ".awb", ".mpga",
+        ".rmvb", ".rm", ".mov", ".flv", ".f4v", ".mp1", ".mp2",
+        ".oga", ".ape", ".omg", ".oma", ".m4v", ".wmv", ".asf",
+        ".vob", ".pmp", ".m4r", ".ra", ".m2ts", ".ac3", ".ec3", ".eac3"
     };
     static const size_t kNumValidExtensions =
         sizeof(kValidExtensions) / sizeof(kValidExtensions[0]);
diff -ur ../aosp/frameworks/av/media/libstagefright/SurfaceUtils.cpp ../Desktop/android/frameworks/av/media/libstagefright/SurfaceUtils.cpp
--- ../aosp/frameworks/av/media/libstagefright/SurfaceUtils.cpp	2018-08-06 15:40:15.303066368 +0200
+++ ../Desktop/android/frameworks/av/media/libstagefright/SurfaceUtils.cpp	2017-11-23 05:21:09.000000000 +0100
@@ -22,6 +22,8 @@
 
 #include <gui/Surface.h>
 
+#include <media/openmax/OMX_IVCommon.h>
+
 namespace android {
 
 status_t setNativeWindowSizeFormatAndUsage(
@@ -50,11 +52,21 @@
         return err;
     }
 
-    err = native_window_set_buffers_format(nativeWindow, format);
-    if (err != NO_ERROR) {
-        ALOGE("native_window_set_buffers_format failed: %s (%d)", strerror(-err), -err);
-        return err;
-    }
+	if(format == OMX_COLOR_FormatYUV420Planar) {
+	    err = native_window_set_buffers_format(nativeWindow, HAL_PIXEL_FORMAT_YV12);
+	    if (err != NO_ERROR) {
+	        ALOGE("native_window_set_buffers_format failed: %s (%d)", strerror(-err), -err);
+	        return err;
+	    }
+
+	} else {
+	    err = native_window_set_buffers_format(nativeWindow, format);
+	    if (err != NO_ERROR) {
+	        ALOGE("native_window_set_buffers_format failed: %s (%d)", strerror(-err), -err);
+	        return err;
+	    }
+
+	}
 
     int transform = 0;
     if ((rotation % 90) == 0) {
diff -ur ../aosp/frameworks/av/media/mediaserver/mediaserver.rc ../Desktop/android/frameworks/av/media/mediaserver/mediaserver.rc
--- ../aosp/frameworks/av/media/mediaserver/mediaserver.rc	2018-08-06 15:40:15.571069809 +0200
+++ ../Desktop/android/frameworks/av/media/mediaserver/mediaserver.rc	2017-11-23 05:21:09.000000000 +0100
@@ -1,6 +1,6 @@
 service media /system/bin/mediaserver
     class main
     user media
-    group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm
+    group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm sdcard_rw
     ioprio rt 4
     writepid /dev/cpuset/foreground/tasks
diff -ur ../aosp/frameworks/av/services/audioflinger/AudioFlinger.cpp ../Desktop/android/frameworks/av/services/audioflinger/AudioFlinger.cpp
--- ../aosp/frameworks/av/services/audioflinger/AudioFlinger.cpp	2018-08-06 15:40:15.579069912 +0200
+++ ../Desktop/android/frameworks/av/services/audioflinger/AudioFlinger.cpp	2017-11-23 05:21:09.000000000 +0100
@@ -132,6 +132,7 @@
     case AUDIO_FORMAT_AC3: return "ac-3";
     case AUDIO_FORMAT_E_AC3: return "e-ac-3";
     case AUDIO_FORMAT_IEC61937: return "iec61937";
+	case AUDIO_FORMAT_DTS: return "dts";
     default:
         break;
     }
@@ -1145,6 +1146,21 @@
                 AudioFlinger::mScreenState = ((AudioFlinger::mScreenState & ~1) + 2) | isOff;
             }
         }
+        /* add set param for AUDIO_PARAMETER_DEVICES_OUT_ACTIVE
+         */
+        if (param.get(String8(AUDIO_PARAMETER_STREAM_ROUTING), value) == NO_ERROR
+            || param.get(String8(AUDIO_PARAMETER_RAW_DATA_OUT), value) == NO_ERROR
+            || param.get(String8(AUDIO_PARAMETER_DEVICES_OUT_ACTIVE), value) == NO_ERROR) {
+                for (uint32_t i = 0; i < mPlaybackThreads.size(); i++) {
+                    mPlaybackThreads.valueAt(i)->setParameters(keyValuePairs);
+                }
+        }
+
+        if (param.get(String8(AUDIO_PARAMETER_DEVICES_IN_ACTIVE), value) == NO_ERROR) {
+            for (uint32_t i = 0; i < mRecordThreads.size(); i++) {
+                mRecordThreads.valueAt(i)->setParameters(keyValuePairs);
+            }
+        }
         return final_result;
     }
 
diff -ur ../aosp/frameworks/av/services/audiopolicy/enginedefault/src/Engine.cpp ../Desktop/android/frameworks/av/services/audiopolicy/enginedefault/src/Engine.cpp
--- ../aosp/frameworks/av/services/audiopolicy/enginedefault/src/Engine.cpp	2018-08-06 15:40:15.615070374 +0200
+++ ../Desktop/android/frameworks/av/services/audiopolicy/enginedefault/src/Engine.cpp	2017-11-23 05:21:09.000000000 +0100
@@ -545,6 +545,18 @@
     return device;
 }
 
+#include <fcntl.h>
+static int pt71600_get_num_remotes()
+{
+    int num_remotes = 0;
+    int fd = open("/proc/pt71600-num-remotes", O_RDONLY);
+    if (fd == -1)
+        return 0;
+    if (read(fd, &num_remotes, sizeof(num_remotes)) != sizeof(num_remotes))
+        num_remotes = 0;
+    close(fd);
+    return num_remotes;
+}
 
 audio_devices_t Engine::getDeviceForInputSource(audio_source_t inputSource) const
 {
@@ -555,6 +567,16 @@
 
     uint32_t device = AUDIO_DEVICE_NONE;
 
+    if (availableDeviceTypes & AUDIO_DEVICE_IN_PT71600_REMOTE) {
+        if (inputSource == AUDIO_SOURCE_DEFAULT || inputSource == AUDIO_SOURCE_MIC
+            || inputSource == AUDIO_SOURCE_VOICE_RECOGNITION || inputSource == AUDIO_SOURCE_HOTWORD) {
+            if (pt71600_get_num_remotes() > 0) {
+                ALOGV("AUDIO_DEVICE_IN_PT71600_REMOTE");
+                return AUDIO_DEVICE_IN_PT71600_REMOTE;
+            }
+        }
+    }
+
     switch (inputSource) {
     case AUDIO_SOURCE_VOICE_UPLINK:
       if (availableDeviceTypes & AUDIO_DEVICE_IN_VOICE_CALL) {
diff -ur ../aosp/frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp ../Desktop/android/frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp
--- ../aosp/frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp	2018-08-06 15:40:15.619070425 +0200
+++ ../Desktop/android/frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp	2017-11-23 05:21:09.000000000 +0100
@@ -823,7 +823,7 @@
     sp<CameraClient> client = static_cast<CameraClient*>(getClientFromCookie(user).get());
     if (client.get() == nullptr) return;
 
-    if (!client->lockIfMessageWanted(msgType)) return;
+    //if (!client->lockIfMessageWanted(msgType)) return;
 
     if (dataPtr == 0) {
         ALOGE("Null data returned in data with timestamp callback");
diff -ur ../aosp/frameworks/av/services/camera/libcameraservice/CameraService.cpp ../Desktop/android/frameworks/av/services/camera/libcameraservice/CameraService.cpp
--- ../aosp/frameworks/av/services/camera/libcameraservice/CameraService.cpp	2018-08-06 15:40:15.619070425 +0200
+++ ../Desktop/android/frameworks/av/services/camera/libcameraservice/CameraService.cpp	2017-11-23 05:21:09.000000000 +0100
@@ -428,6 +428,67 @@
 
 Status CameraService::getNumberOfCameras(int32_t type, int32_t* numCameras) {
     ATRACE_CALL();
+    //add by fuqiang for init when calling getNumberOfCameras, start
+    mNumberOfCameras = mModule->getNumberOfCameras();
+    mNumberOfNormalCameras = mNumberOfCameras;
+    int latestStrangeCameraId = INT_MAX;
+    for (int i = 0; i < mNumberOfCameras; i++) {
+        String8 cameraId = String8::format("%d", i);
+
+        // Get camera info
+
+        struct camera_info info;
+        bool haveInfo = true;
+        status_t rc = mModule->getCameraInfo(i, &info);
+        if (rc != NO_ERROR) {
+            ALOGE("%s: Received error loading camera info for device %d, cost and"
+                    " conflicting devices fields set to defaults for this device.",
+                    __FUNCTION__, i);
+            haveInfo = false;
+        }
+
+        // Check for backwards-compatibility support
+        if (haveInfo) {
+            if (checkCameraCapabilities(i, info, &latestStrangeCameraId) != OK) {
+                delete mModule;
+                mModule = nullptr;
+                 ALOGW("%s: mModule is null !!!!!!!!!!!!!!!!!!!!!!!!!",
+                    __FUNCTION__);
+                return STATUS_ERROR(ERROR_DISCONNECTED,
+                    "mModule is null !!!!!!!!!!!!!!!!!!!!!!!!!");
+            }
+        }
+
+        // Defaults to use for cost and conflicting devices
+        int cost = 100;
+        char** conflicting_devices = nullptr;
+        size_t conflicting_devices_length = 0;
+
+        // If using post-2.4 module version, query the cost + conflicting devices from the HAL
+        if (mModule->getModuleApiVersion() >= CAMERA_MODULE_API_VERSION_2_4 && haveInfo) {
+            cost = info.resource_cost;
+            conflicting_devices = info.conflicting_devices;
+            conflicting_devices_length = info.conflicting_devices_length;
+        }
+
+        std::set<String8> conflicting;
+        for (size_t i = 0; i < conflicting_devices_length; i++) {
+            conflicting.emplace(String8(conflicting_devices[i]));
+        }
+
+        // Initialize state for each camera device
+        {
+            Mutex::Autolock lock(mCameraStatesLock);
+            mCameraStates.emplace(cameraId, std::make_shared<CameraState>(cameraId, cost,
+                    conflicting));
+        }
+
+        if (mFlashlight->hasFlashUnit(cameraId)) {
+            mTorchStatusMap.add(cameraId,
+                    ICameraServiceListener::TORCH_STATUS_AVAILABLE_OFF);
+        }
+    }
+    //add by fuqiang for init when calling getNumberOfCameras, end
     switch (type) {
         case CAMERA_TYPE_BACKWARD_COMPATIBLE:
             *numCameras = mNumberOfNormalCameras;
diff -ur ../aosp/frameworks/av/services/mediacodec/minijail/seccomp_policy/mediacodec-seccomp-arm.policy ../Desktop/android/frameworks/av/services/mediacodec/minijail/seccomp_policy/mediacodec-seccomp-arm.policy
--- ../aosp/frameworks/av/services/mediacodec/minijail/seccomp_policy/mediacodec-seccomp-arm.policy	2018-08-06 15:40:15.627070528 +0200
+++ ../Desktop/android/frameworks/av/services/mediacodec/minijail/seccomp_policy/mediacodec-seccomp-arm.policy	2017-11-23 05:21:09.000000000 +0100
@@ -49,3 +49,6 @@
 connect: 1
 fcntl64: 1
 rt_tgsigqueueinfo: 1
+getdents64: 1
+pselect6: 1
+sysinfo: 1
diff -ur ../aosp/frameworks/base/Android.mk ../Desktop/android/frameworks/base/Android.mk
--- ../aosp/frameworks/base/Android.mk	2018-08-06 15:40:20.947138849 +0200
+++ ../Desktop/android/frameworks/base/Android.mk	2017-11-23 05:21:11.000000000 +0100
@@ -125,6 +125,7 @@
 	core/java/android/bluetooth/IBluetoothGatt.aidl \
 	core/java/android/bluetooth/IBluetoothGattCallback.aidl \
 	core/java/android/bluetooth/IBluetoothGattServerCallback.aidl \
+	core/java/android/bluetooth/IBluetoothRtkbt.aidl \
 	core/java/android/content/IClipboard.aidl \
 	core/java/android/content/IContentService.aidl \
 	core/java/android/content/IIntentReceiver.aidl \
@@ -199,6 +200,7 @@
 	core/java/android/net/IConnectivityManager.aidl \
 	core/java/android/net/IConnectivityMetricsLogger.aidl \
 	core/java/android/net/IEthernetManager.aidl \
+	core/java/android/net/IPppoeManager.aidl \
 	core/java/android/net/IEthernetServiceListener.aidl \
 	core/java/android/net/INetworkManagementEventObserver.aidl \
 	core/java/android/net/INetworkPolicyListener.aidl \
@@ -220,6 +222,7 @@
 	core/java/android/os/IBatteryPropertiesRegistrar.aidl \
 	core/java/android/os/ICancellationSignal.aidl \
 	core/java/android/os/IDeviceIdleController.aidl \
+        core/java/android/os/IDisplayOutputManager.aidl \
 	core/java/android/os/IHardwarePropertiesManager.aidl \
 	core/java/android/os/IMaintenanceActivityListener.aidl \
 	core/java/android/os/IMessenger.aidl \
diff -ur ../aosp/frameworks/base/api/current.txt ../Desktop/android/frameworks/base/api/current.txt
--- ../aosp/frameworks/base/api/current.txt	2018-08-06 15:40:21.095140749 +0200
+++ ../Desktop/android/frameworks/base/api/current.txt	2017-11-23 05:21:11.000000000 +0100
@@ -7389,6 +7389,18 @@
     field public static final int TYPE_SCO = 2; // 0x2
   }
 
+  public abstract interface IBluetoothRtkbt implements android.os.IInterface {
+    method public abstract int GenericCommand(int, int, byte[], int) throws android.os.RemoteException;
+    method public abstract int GetFeature(int) throws android.os.RemoteException;
+  }
+
+  public static abstract class IBluetoothRtkbt.Stub extends android.os.Binder implements android.bluetooth.IBluetoothRtkbt {
+    ctor public IBluetoothRtkbt.Stub();
+    method public android.os.IBinder asBinder();
+    method public static android.bluetooth.IBluetoothRtkbt asInterface(android.os.IBinder);
+    method public boolean onTransact(int, android.os.Parcel, android.os.Parcel, int) throws android.os.RemoteException;
+  }
+
 }
 
 package android.bluetooth.le {
@@ -8159,6 +8171,7 @@
     field public static final int CONTEXT_INCLUDE_CODE = 1; // 0x1
     field public static final int CONTEXT_RESTRICTED = 4; // 0x4
     field public static final java.lang.String DEVICE_POLICY_SERVICE = "device_policy";
+    field public static final java.lang.String DISPLAYOUTPUT_SERVICE = "display_output";
     field public static final java.lang.String DISPLAY_SERVICE = "display";
     field public static final java.lang.String DOWNLOAD_SERVICE = "download";
     field public static final java.lang.String DROPBOX_SERVICE = "dropbox";
@@ -8521,6 +8534,7 @@
     field public static final java.lang.String ACTION_APP_ERROR = "android.intent.action.APP_ERROR";
     field public static final java.lang.String ACTION_ASSIST = "android.intent.action.ASSIST";
     field public static final java.lang.String ACTION_ATTACH_DATA = "android.intent.action.ATTACH_DATA";
+    field public static final java.lang.String ACTION_AUDIO_PLUG_IN_OUT = "android.intent.action.AUDIO_PLUG_IN_OUT";
     field public static final java.lang.String ACTION_BATTERY_CHANGED = "android.intent.action.BATTERY_CHANGED";
     field public static final java.lang.String ACTION_BATTERY_LOW = "android.intent.action.BATTERY_LOW";
     field public static final java.lang.String ACTION_BATTERY_OKAY = "android.intent.action.BATTERY_OKAY";
@@ -8551,6 +8565,8 @@
     field public static final java.lang.String ACTION_GET_RESTRICTION_ENTRIES = "android.intent.action.GET_RESTRICTION_ENTRIES";
     field public static final java.lang.String ACTION_GTALK_SERVICE_CONNECTED = "android.intent.action.GTALK_CONNECTED";
     field public static final java.lang.String ACTION_GTALK_SERVICE_DISCONNECTED = "android.intent.action.GTALK_DISCONNECTED";
+    field public static final java.lang.String ACTION_HDMISTATUS_CHANGED = "android.intent.action.HDMISTATUS_CHANGED";
+    field public static final java.lang.String ACTION_HDMI_PLUGGED = "android.intent.action.HDMI_PLUGGED";
     field public static final java.lang.String ACTION_HEADSET_PLUG = "android.intent.action.HEADSET_PLUG";
     field public static final java.lang.String ACTION_INPUT_METHOD_CHANGED = "android.intent.action.INPUT_METHOD_CHANGED";
     field public static final java.lang.String ACTION_INSERT = "android.intent.action.INSERT";
@@ -9807,6 +9823,7 @@
     field public static final java.lang.String FEATURE_NFC_HOST_CARD_EMULATION_NFCF = "android.hardware.nfc.hcef";
     field public static final java.lang.String FEATURE_OPENGLES_EXTENSION_PACK = "android.hardware.opengles.aep";
     field public static final java.lang.String FEATURE_PICTURE_IN_PICTURE = "android.software.picture_in_picture";
+    field public static final java.lang.String FEATURE_PPPOE = "android.software.pppoe";
     field public static final java.lang.String FEATURE_PRINTING = "android.software.print";
     field public static final java.lang.String FEATURE_SCREEN_LANDSCAPE = "android.hardware.screen.landscape";
     field public static final java.lang.String FEATURE_SCREEN_PORTRAIT = "android.hardware.screen.portrait";
@@ -14537,6 +14554,17 @@
     field public static final android.os.Parcelable.Creator<android.hardware.usb.UsbAccessory> CREATOR;
   }
 
+  public class UsbCameraManager {
+    ctor public UsbCameraManager();
+    field public static final java.lang.String ACTION_USB_CAMERA_PLUG_IN_OUT = "android.hardware.usb.action.USB_CAMERA_PLUG_IN_OUT";
+    field public static final java.lang.String EXTRA_MNG = "extral_mng";
+    field public static final int PLUG_IN = 1; // 0x1
+    field public static final int PLUG_OUT = 0; // 0x0
+    field public static final java.lang.String USB_CAMERA_NAME = "UsbCameraName";
+    field public static final java.lang.String USB_CAMERA_STATE = "UsbCameraState";
+    field public static final java.lang.String USB_CAMERA_TOTAL_NUMBER = "UsbCameraTotalNumber";
+  }
+
   public class UsbConfiguration implements android.os.Parcelable {
     method public int describeContents();
     method public int getId();
@@ -21146,6 +21174,7 @@
     field public static final int MEDIA_INFO_UNSUPPORTED_SUBTITLE = 901; // 0x385
     field public static final int MEDIA_INFO_VIDEO_RENDERING_START = 3; // 0x3
     field public static final int MEDIA_INFO_VIDEO_TRACK_LAGGING = 700; // 0x2bc
+    field public static final java.lang.String[] MEDIA_MIMETYPE;
     field public static final java.lang.String MEDIA_MIMETYPE_TEXT_SUBRIP = "application/x-subrip";
     field public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT = 1; // 0x1
     field public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING = 2; // 0x2
@@ -21727,8 +21756,48 @@
   }
 
   public final class TimedText {
+    method public android.graphics.Bitmap AWExtend_getBitmap();
+    method public int AWExtend_getBitmapSubtitleFlag();
+    method public int AWExtend_getHideSubFlag();
+    method public int AWExtend_getReferenceVideoHeight();
+    method public int AWExtend_getReferenceVideoWidth();
+    method public java.util.List<android.media.TimedText.Style> AWExtend_getStyleList();
+    method public int AWExtend_getSubDispPos();
+    method public int AWExtend_getSubtitleID();
+    method public android.graphics.Rect AWExtend_getTextScreenBounds();
     method public android.graphics.Rect getBounds();
     method public java.lang.String getText();
+    field public static final int SUB_DISPPOS_BOT_LEFT = 49; // 0x31
+    field public static final int SUB_DISPPOS_BOT_MID = 50; // 0x32
+    field public static final int SUB_DISPPOS_BOT_RIGHT = 51; // 0x33
+    field public static final int SUB_DISPPOS_DEFAULT = 0; // 0x0
+    field public static final int SUB_DISPPOS_MID_LEFT = 33; // 0x21
+    field public static final int SUB_DISPPOS_MID_MID = 34; // 0x22
+    field public static final int SUB_DISPPOS_MID_RIGHT = 35; // 0x23
+    field public static final int SUB_DISPPOS_TOP_LEFT = 17; // 0x11
+    field public static final int SUB_DISPPOS_TOP_MID = 18; // 0x12
+    field public static final int SUB_DISPPOS_TOP_RIGHT = 19; // 0x13
+    field public static final int SUB_RENDER_ALIGN_NONE = 0; // 0x0
+    field public static final int SUB_RENDER_HALIGN_CENTER = 2; // 0x2
+    field public static final int SUB_RENDER_HALIGN_LEFT = 1; // 0x1
+    field public static final int SUB_RENDER_HALIGN_RIGHT = 3; // 0x3
+    field public static final int SUB_RENDER_VALIGN_BOTTOM = 48; // 0x30
+    field public static final int SUB_RENDER_VALIGN_CENTER = 32; // 0x20
+    field public static final int SUB_RENDER_VALIGN_TOP = 16; // 0x10
+    field public static final int SUN_RENDER_HALIGN_MASK = 15; // 0xf
+    field public static final int SUN_RENDER_VALIGN_MASK = 240; // 0xf0
+  }
+
+  public static final class TimedText.Style {
+    ctor public TimedText.Style(int, int, int, boolean, boolean, boolean, int, int);
+    field public final int colorRGBA;
+    field public final int endChar;
+    field public final int fontID;
+    field public final int fontSize;
+    field public final boolean isBold;
+    field public final boolean isItalic;
+    field public final boolean isUnderlined;
+    field public final int startChar;
   }
 
   public class ToneGenerator {
@@ -23607,6 +23676,7 @@
     field public static final int TRANSPORT_BLUETOOTH = 2; // 0x2
     field public static final int TRANSPORT_CELLULAR = 0; // 0x0
     field public static final int TRANSPORT_ETHERNET = 3; // 0x3
+    field public static final int TRANSPORT_PPPOE = 5; // 0x5
     field public static final int TRANSPORT_VPN = 4; // 0x4
     field public static final int TRANSPORT_WIFI = 1; // 0x1
   }
@@ -28490,6 +28560,103 @@
     field public int otherSharedDirty;
   }
 
+  public class DisplayOutputManager {
+    method public int getDisplayBright(int);
+    method public int getDisplayContrast(int);
+    method public int getDisplayDenoise(int);
+    method public int getDisplayDetail(int);
+    method public int getDisplayEdge(int);
+    method public int getDisplayEnhanceMode(int);
+    method public int[] getDisplayMargin(int);
+    method public static int getDisplayModeFromFormat(int);
+    method public int[] getDisplayOffset(int);
+    method public int getDisplayOutput(int);
+    method public int getDisplayOutputCurDataspaceMode(int);
+    method public int getDisplayOutputDataspaceMode(int);
+    method public int getDisplayOutputMode(int);
+    method public int getDisplayOutputPixelFormat(int);
+    method public int getDisplayOutputType(int);
+    method public int getDisplaySaturation(int);
+    method public int getDisplaySupport3DMode(int);
+    method public static int getDisplayTypeFromFormat(int);
+    method public int[] getSupportModes(int, int);
+    method public boolean isCurrent3Doutput(int);
+    method public boolean isSupportHdmiMode(int, int);
+    method public int makeDisplayFormat(int, int);
+    method public int setDisplay3DLayerOffset(int, int);
+    method public int setDisplay3DMode(int, int);
+    method public int setDisplay3DMode(int, int, int);
+    method public int setDisplayBright(int, int);
+    method public int setDisplayContrast(int, int);
+    method public int setDisplayDenoise(int, int);
+    method public int setDisplayDetail(int, int);
+    method public int setDisplayEdge(int, int);
+    method public int setDisplayEnhanceMode(int, int);
+    method public int setDisplayMargin(int, int, int);
+    method public int setDisplayOffset(int, int, int);
+    method public int setDisplayOutput(int, int);
+    method public int setDisplayOutputDataspaceMode(int, int);
+    method public int setDisplayOutputMode(int, int);
+    method public int setDisplayOutputPixelFormat(int, int);
+    method public int setDisplaySaturation(int, int);
+    field public static final int DISPLAY_2D_DUAL_STREAM = 5; // 0x5
+    field public static final int DISPLAY_2D_LEFT = 1; // 0x1
+    field public static final int DISPLAY_2D_ORIGINAL = 0; // 0x0
+    field public static final int DISPLAY_2D_TOP = 2; // 0x2
+    field public static final int DISPLAY_3D_DUAL_STREAM = 6; // 0x6
+    field public static final int DISPLAY_3D_LEFT_RIGHT_HDMI = 3; // 0x3
+    field public static final int DISPLAY_3D_TOP_BOTTOM_HDMI = 4; // 0x4
+    field public static final int DISPLAY_OUTPUT_MODE_MASK = 255; // 0xff
+    field public static final int DISPLAY_OUTPUT_TYPE_HDMI = 4; // 0x4
+    field public static final int DISPLAY_OUTPUT_TYPE_LCD = 1; // 0x1
+    field public static final int DISPLAY_OUTPUT_TYPE_MASK = 65280; // 0xff00
+    field public static final int DISPLAY_OUTPUT_TYPE_NONE = 0; // 0x0
+    field public static final int DISPLAY_OUTPUT_TYPE_TV = 2; // 0x2
+    field public static final int DISPLAY_OUTPUT_TYPE_VGA = 8; // 0x8
+    field public static final int DISPLAY_TVFORMAT_1080I_50HZ = 6; // 0x6
+    field public static final int DISPLAY_TVFORMAT_1080I_60HZ = 7; // 0x7
+    field public static final int DISPLAY_TVFORMAT_1080P_24HZ = 8; // 0x8
+    field public static final int DISPLAY_TVFORMAT_1080P_25HZ = 26; // 0x1a
+    field public static final int DISPLAY_TVFORMAT_1080P_24HZ_3D_FP = 23; // 0x17
+    field public static final int DISPLAY_TVFORMAT_1080P_50HZ = 9; // 0x9
+    field public static final int DISPLAY_TVFORMAT_1080P_60HZ = 10; // 0xa
+    field public static final int DISPLAY_TVFORMAT_3840_2160P_24HZ = 30; // 0x1e
+    field public static final int DISPLAY_TVFORMAT_3840_2160P_25HZ = 29; // 0x1d
+    field public static final int DISPLAY_TVFORMAT_3840_2160P_30HZ = 28; // 0x1c
+    field public static final int DISPLAY_TVFORMAT_3840_2160P_60HZ = 34; // 0x22
+    field public static final int DISPLAY_TVFORMAT_4096_2160P_24HZ = 31; // 0x1f
+    field public static final int DISPLAY_TVFORMAT_4096_2160P_25HZ = 32; // 0x20
+    field public static final int DISPLAY_TVFORMAT_4096_2160P_30HZ = 33; // 0x21
+    field public static final int DISPLAY_TVFORMAT_4096_2160P_60HZ = 35; // 0x23
+    field public static final int DISPLAY_TVFORMAT_480I = 0; // 0x0
+    field public static final int DISPLAY_TVFORMAT_480P = 2; // 0x2
+    field public static final int DISPLAY_TVFORMAT_576I = 1; // 0x1
+    field public static final int DISPLAY_TVFORMAT_576P = 3; // 0x3
+    field public static final int DISPLAY_TVFORMAT_720P_50HZ = 4; // 0x4
+    field public static final int DISPLAY_TVFORMAT_720P_60HZ = 5; // 0x5
+    field public static final int DISPLAY_TVFORMAT_NTSC = 14; // 0xe
+    field public static final int DISPLAY_TVFORMAT_NTSC_CVBS_SVIDEO = 16; // 0x10
+    field public static final int DISPLAY_TVFORMAT_NTSC_SVIDEO = 15; // 0xf
+    field public static final int DISPLAY_TVFORMAT_PAL = 11; // 0xb
+    field public static final int DISPLAY_TVFORMAT_PAL_CVBS_SVIDEO = 13; // 0xd
+    field public static final int DISPLAY_TVFORMAT_PAL_M = 17; // 0x11
+    field public static final int DISPLAY_TVFORMAT_PAL_M_CVBS_SVIDEO = 19; // 0x13
+    field public static final int DISPLAY_TVFORMAT_PAL_M_SVIDEO = 18; // 0x12
+    field public static final int DISPLAY_TVFORMAT_PAL_NC = 20; // 0x14
+    field public static final int DISPLAY_TVFORMAT_PAL_NC_CVBS_SVIDEO = 22; // 0x16
+    field public static final int DISPLAY_TVFORMAT_PAL_NC_SVIDEO = 21; // 0x15
+    field public static final int DISPLAY_TVFORMAT_PAL_SVIDEO = 12; // 0xc
+    field public static final int DISPLAY_VGA_FORMAT_1024x768P_60HZ = 2; // 0x2
+    field public static final int DISPLAY_VGA_FORMAT_1280x768P_60HZ = 3; // 0x3
+    field public static final int DISPLAY_VGA_FORMAT_1280x800P_60HZ = 4; // 0x4
+    field public static final int DISPLAY_VGA_FORMAT_1366x768P_60HZ = 5; // 0x5
+    field public static final int DISPLAY_VGA_FORMAT_1440x900P_60HZ = 6; // 0x6
+    field public static final int DISPLAY_VGA_FORMAT_1920x1080P_60HZ = 7; // 0x7
+    field public static final int DISPLAY_VGA_FORMAT_1920x1200P_60HZ = 8; // 0x8
+    field public static final int DISPLAY_VGA_FORMAT_640x480P_60HZ = 0; // 0x0
+    field public static final int DISPLAY_VGA_FORMAT_800x600P_60HZ = 1; // 0x1
+  }
+
   public class DropBoxManager {
     ctor protected DropBoxManager();
     method public void addData(java.lang.String, byte[], int);
@@ -32372,6 +32539,7 @@
     field public static final deprecated java.lang.String INSTALL_NON_MARKET_APPS = "install_non_market_apps";
     field public static final java.lang.String MODE_RINGER = "mode_ringer";
     field public static final java.lang.String NETWORK_PREFERENCE = "network_preference";
+    field public static final java.lang.String PPPOE_ENABLED = "pppoe_enabled";
     field public static final java.lang.String RADIO_BLUETOOTH = "bluetooth";
     field public static final java.lang.String RADIO_CELL = "cell";
     field public static final java.lang.String RADIO_NFC = "nfc";
@@ -32433,10 +32601,18 @@
     field public static final android.net.Uri CONTENT_URI;
     field public static final deprecated java.lang.String DATA_ROAMING = "data_roaming";
     field public static final java.lang.String DEFAULT_INPUT_METHOD = "default_input_method";
+    field public static final java.lang.String DEFAULT_PLAYER_QUALITY = "default_player_quality";
+    field public static final java.lang.String DEFAULT_SCREEN_RATIO = "default_screen_ratio";
     field public static final deprecated java.lang.String DEVELOPMENT_SETTINGS_ENABLED = "development_settings_enabled";
     field public static final deprecated java.lang.String DEVICE_PROVISIONED = "device_provisioned";
+    field public static final java.lang.String DHCP_IPVER = "dhcp_ipver";
+    field public static final java.lang.String DHCP_OPTION = "dhcp_option";
+    field public static final java.lang.String DHCP_PSWD = "dhcp_pswd";
+    field public static final java.lang.String DHCP_USER = "dhcp_user";
+    field public static final java.lang.String DISPLAY_AREA = "display_area";
     field public static final java.lang.String ENABLED_ACCESSIBILITY_SERVICES = "enabled_accessibility_services";
     field public static final java.lang.String ENABLED_INPUT_METHODS = "enabled_input_methods";
+    field public static final java.lang.String HOME_PAGE = "home_page";
     field public static final deprecated java.lang.String HTTP_PROXY = "http_proxy";
     field public static final java.lang.String INPUT_METHOD_SELECTOR_VISIBILITY = "input_method_selector_visibility";
     field public static final java.lang.String INSTALL_NON_MARKET_APPS = "install_non_market_apps";
@@ -32451,12 +32627,20 @@
     field public static final deprecated java.lang.String LOCK_PATTERN_VISIBLE = "lock_pattern_visible_pattern";
     field public static final deprecated java.lang.String LOGGING_ID = "logging_id";
     field public static final deprecated java.lang.String NETWORK_PREFERENCE = "network_preference";
+    field public static final java.lang.String NTP_SERVER = "ntp_server";
+    field public static final java.lang.String NTP_SERVER2 = "ntp_server2";
+    field public static final java.lang.String NTVUSERACCOUNT = "ntvuseraccount";
+    field public static final java.lang.String NTVUSERPASSWORD = "ntvuserpassword";
+    field public static final java.lang.String NTVUSERSUFFIX = "ntvusersuffix";
     field public static final java.lang.String PARENTAL_CONTROL_ENABLED = "parental_control_enabled";
     field public static final java.lang.String PARENTAL_CONTROL_LAST_UPDATE = "parental_control_last_update";
     field public static final java.lang.String PARENTAL_CONTROL_REDIRECT_URL = "parental_control_redirect_url";
+    field public static final java.lang.String PPPOE_PSWD = "pppoe_pswd";
+    field public static final java.lang.String PPPOE_USERNAME = "pppoe_username";
     field public static final java.lang.String SELECTED_INPUT_METHOD_SUBTYPE = "selected_input_method_subtype";
     field public static final java.lang.String SETTINGS_CLASSNAME = "settings_classname";
     field public static final java.lang.String SKIP_FIRST_USE_HINTS = "skip_first_use_hints";
+    field public static final java.lang.String SQM_START_MODE = "sqm_start_mode";
     field public static final java.lang.String TOUCH_EXPLORATION_ENABLED = "touch_exploration_enabled";
     field public static final deprecated java.lang.String TTS_DEFAULT_COUNTRY = "tts_default_country";
     field public static final deprecated java.lang.String TTS_DEFAULT_LANG = "tts_default_lang";
@@ -32466,6 +32650,8 @@
     field public static final deprecated java.lang.String TTS_DEFAULT_VARIANT = "tts_default_variant";
     field public static final java.lang.String TTS_ENABLED_PLUGINS = "tts_enabled_plugins";
     field public static final deprecated java.lang.String TTS_USE_DEFAULTS = "tts_use_defaults";
+    field public static final java.lang.String UPGRADE_PATH = "upgrade_path";
+    field public static final java.lang.String UPGRADE_URL = "upgrade_url";
     field public static final deprecated java.lang.String USB_MASS_STORAGE_ENABLED = "usb_mass_storage_enabled";
     field public static final deprecated java.lang.String USE_GOOGLE_MAIL = "use_google_mail";
     field public static final deprecated java.lang.String WIFI_MAX_DHCP_RETRY_COUNT = "wifi_max_dhcp_retry_count";
@@ -32547,6 +32733,7 @@
     field public static final deprecated java.lang.String LOGGING_ID = "logging_id";
     field public static final deprecated java.lang.String MODE_RINGER = "mode_ringer";
     field public static final java.lang.String MODE_RINGER_STREAMS_AFFECTED = "mode_ringer_streams_affected";
+    field public static final java.lang.String MOUSE_ADVANCE = "mouse_advance";
     field public static final java.lang.String MUTE_STREAMS_AFFECTED = "mute_streams_affected";
     field public static final deprecated java.lang.String NETWORK_PREFERENCE = "network_preference";
     field public static final deprecated java.lang.String NEXT_ALARM_FORMATTED = "next_alarm_formatted";
@@ -41212,9 +41399,11 @@
     field public static final int KEYCODE_ALT_LEFT = 57; // 0x39
     field public static final int KEYCODE_ALT_RIGHT = 58; // 0x3a
     field public static final int KEYCODE_APOSTROPHE = 75; // 0x4b
+    field public static final int KEYCODE_APPS = 10011; // 0x271b
     field public static final int KEYCODE_APP_SWITCH = 187; // 0xbb
     field public static final int KEYCODE_ASSIST = 219; // 0xdb
     field public static final int KEYCODE_AT = 77; // 0x4d
+    field public static final int KEYCODE_AUDIO = 10003; // 0x2713
     field public static final int KEYCODE_AVR_INPUT = 182; // 0xb6
     field public static final int KEYCODE_AVR_POWER = 181; // 0xb5
     field public static final int KEYCODE_B = 30; // 0x1e
@@ -41224,6 +41413,7 @@
     field public static final int KEYCODE_BREAK = 121; // 0x79
     field public static final int KEYCODE_BRIGHTNESS_DOWN = 220; // 0xdc
     field public static final int KEYCODE_BRIGHTNESS_UP = 221; // 0xdd
+    field public static final int KEYCODE_BROWSER = 10012; // 0x271c
     field public static final int KEYCODE_BUTTON_1 = 188; // 0xbc
     field public static final int KEYCODE_BUTTON_10 = 197; // 0xc5
     field public static final int KEYCODE_BUTTON_11 = 198; // 0xc6
@@ -41290,6 +41480,7 @@
     field public static final int KEYCODE_ENVELOPE = 65; // 0x41
     field public static final int KEYCODE_EQUALS = 70; // 0x46
     field public static final int KEYCODE_ESCAPE = 111; // 0x6f
+    field public static final int KEYCODE_EXPAND = 10008; // 0x2718
     field public static final int KEYCODE_EXPLORER = 64; // 0x40
     field public static final int KEYCODE_F = 34; // 0x22
     field public static final int KEYCODE_F1 = 131; // 0x83
@@ -41304,11 +41495,13 @@
     field public static final int KEYCODE_F7 = 137; // 0x89
     field public static final int KEYCODE_F8 = 138; // 0x8a
     field public static final int KEYCODE_F9 = 139; // 0x8b
+    field public static final int KEYCODE_FAVOURITE = 10006; // 0x2716
     field public static final int KEYCODE_FOCUS = 80; // 0x50
     field public static final int KEYCODE_FORWARD = 125; // 0x7d
     field public static final int KEYCODE_FORWARD_DEL = 112; // 0x70
     field public static final int KEYCODE_FUNCTION = 119; // 0x77
     field public static final int KEYCODE_G = 35; // 0x23
+    field public static final int KEYCODE_GOTO = 10001; // 0x2711
     field public static final int KEYCODE_GRAVE = 68; // 0x44
     field public static final int KEYCODE_GUIDE = 172; // 0xac
     field public static final int KEYCODE_H = 36; // 0x24
@@ -41327,6 +41520,7 @@
     field public static final int KEYCODE_LANGUAGE_SWITCH = 204; // 0xcc
     field public static final int KEYCODE_LAST_CHANNEL = 229; // 0xe5
     field public static final int KEYCODE_LEFT_BRACKET = 71; // 0x47
+    field public static final int KEYCODE_LOOP = 10007; // 0x2717
     field public static final int KEYCODE_M = 41; // 0x29
     field public static final int KEYCODE_MANNER_MODE = 205; // 0xcd
     field public static final int KEYCODE_MEDIA_AUDIO_TRACK = 222; // 0xde
@@ -41350,8 +41544,10 @@
     field public static final int KEYCODE_META_LEFT = 117; // 0x75
     field public static final int KEYCODE_META_RIGHT = 118; // 0x76
     field public static final int KEYCODE_MINUS = 69; // 0x45
+    field public static final int KEYCODE_MOUSE = 10009; // 0x2719
     field public static final int KEYCODE_MOVE_END = 123; // 0x7b
     field public static final int KEYCODE_MOVE_HOME = 122; // 0x7a
+    field public static final int KEYCODE_MOVIE = 10010; // 0x271a
     field public static final int KEYCODE_MUHENKAN = 213; // 0xd5
     field public static final int KEYCODE_MUSIC = 209; // 0xd1
     field public static final int KEYCODE_MUTE = 91; // 0x5b
@@ -41403,6 +41599,7 @@
     field public static final int KEYCODE_RIGHT_BRACKET = 72; // 0x48
     field public static final int KEYCODE_RO = 217; // 0xd9
     field public static final int KEYCODE_S = 47; // 0x2f
+    field public static final int KEYCODE_SCREENSHOT = 10013; // 0x271d
     field public static final int KEYCODE_SCROLL_LOCK = 116; // 0x74
     field public static final int KEYCODE_SEARCH = 84; // 0x54
     field public static final int KEYCODE_SEMICOLON = 74; // 0x4a
@@ -41422,6 +41619,7 @@
     field public static final int KEYCODE_STEM_2 = 266; // 0x10a
     field public static final int KEYCODE_STEM_3 = 267; // 0x10b
     field public static final int KEYCODE_STEM_PRIMARY = 264; // 0x108
+    field public static final int KEYCODE_SUBTITLE = 10002; // 0x2712
     field public static final int KEYCODE_SWITCH_CHARSET = 95; // 0x5f
     field public static final int KEYCODE_SYM = 63; // 0x3f
     field public static final int KEYCODE_SYSRQ = 120; // 0x78
@@ -41453,6 +41651,7 @@
     field public static final int KEYCODE_TV_SATELLITE_BS = 238; // 0xee
     field public static final int KEYCODE_TV_SATELLITE_CS = 239; // 0xef
     field public static final int KEYCODE_TV_SATELLITE_SERVICE = 240; // 0xf0
+    field public static final int KEYCODE_TV_SYSTEM = 10000; // 0x2710
     field public static final int KEYCODE_TV_TELETEXT = 233; // 0xe9
     field public static final int KEYCODE_TV_TERRESTRIAL_ANALOG = 235; // 0xeb
     field public static final int KEYCODE_TV_TERRESTRIAL_DIGITAL = 236; // 0xec
@@ -41473,6 +41672,7 @@
     field public static final int KEYCODE_YEN = 216; // 0xd8
     field public static final int KEYCODE_Z = 54; // 0x36
     field public static final int KEYCODE_ZENKAKU_HANKAKU = 211; // 0xd3
+    field public static final int KEYCODE_ZOOM = 10004; // 0x2714
     field public static final int KEYCODE_ZOOM_IN = 168; // 0xa8
     field public static final int KEYCODE_ZOOM_OUT = 169; // 0xa9
     field public static final deprecated int MAX_KEYCODE = 84; // 0x54
diff -ur ../aosp/frameworks/base/api/system-current.txt ../Desktop/android/frameworks/base/api/system-current.txt
--- ../aosp/frameworks/base/api/system-current.txt	2018-08-06 15:40:21.175141776 +0200
+++ ../Desktop/android/frameworks/base/api/system-current.txt	2017-11-23 05:21:11.000000000 +0100
@@ -7681,6 +7681,18 @@
     field public static final int TYPE_SCO = 2; // 0x2
   }
 
+  public abstract interface IBluetoothRtkbt implements android.os.IInterface {
+    method public abstract int GenericCommand(int, int, byte[], int) throws android.os.RemoteException;
+    method public abstract int GetFeature(int) throws android.os.RemoteException;
+  }
+
+  public static abstract class IBluetoothRtkbt.Stub extends android.os.Binder implements android.bluetooth.IBluetoothRtkbt {
+    ctor public IBluetoothRtkbt.Stub();
+    method public android.os.IBinder asBinder();
+    method public static android.bluetooth.IBluetoothRtkbt asInterface(android.os.IBinder);
+    method public boolean onTransact(int, android.os.Parcel, android.os.Parcel, int) throws android.os.RemoteException;
+  }
+
 }
 
 package android.bluetooth.le {
@@ -8480,6 +8492,7 @@
     field public static final int CONTEXT_INCLUDE_CODE = 1; // 0x1
     field public static final int CONTEXT_RESTRICTED = 4; // 0x4
     field public static final java.lang.String DEVICE_POLICY_SERVICE = "device_policy";
+    field public static final java.lang.String DISPLAYOUTPUT_SERVICE = "display_output";
     field public static final java.lang.String DISPLAY_SERVICE = "display";
     field public static final java.lang.String DOWNLOAD_SERVICE = "download";
     field public static final java.lang.String DROPBOX_SERVICE = "dropbox";
@@ -8851,6 +8864,7 @@
     field public static final java.lang.String ACTION_APP_ERROR = "android.intent.action.APP_ERROR";
     field public static final java.lang.String ACTION_ASSIST = "android.intent.action.ASSIST";
     field public static final java.lang.String ACTION_ATTACH_DATA = "android.intent.action.ATTACH_DATA";
+    field public static final java.lang.String ACTION_AUDIO_PLUG_IN_OUT = "android.intent.action.AUDIO_PLUG_IN_OUT";
     field public static final java.lang.String ACTION_BATTERY_CHANGED = "android.intent.action.BATTERY_CHANGED";
     field public static final java.lang.String ACTION_BATTERY_LOW = "android.intent.action.BATTERY_LOW";
     field public static final java.lang.String ACTION_BATTERY_OKAY = "android.intent.action.BATTERY_OKAY";
@@ -8881,6 +8895,8 @@
     field public static final java.lang.String ACTION_GET_RESTRICTION_ENTRIES = "android.intent.action.GET_RESTRICTION_ENTRIES";
     field public static final java.lang.String ACTION_GTALK_SERVICE_CONNECTED = "android.intent.action.GTALK_CONNECTED";
     field public static final java.lang.String ACTION_GTALK_SERVICE_DISCONNECTED = "android.intent.action.GTALK_DISCONNECTED";
+    field public static final java.lang.String ACTION_HDMISTATUS_CHANGED = "android.intent.action.HDMISTATUS_CHANGED";
+    field public static final java.lang.String ACTION_HDMI_PLUGGED = "android.intent.action.HDMI_PLUGGED";
     field public static final java.lang.String ACTION_HEADSET_PLUG = "android.intent.action.HEADSET_PLUG";
     field public static final java.lang.String ACTION_INPUT_METHOD_CHANGED = "android.intent.action.INPUT_METHOD_CHANGED";
     field public static final java.lang.String ACTION_INSERT = "android.intent.action.INSERT";
@@ -10178,6 +10194,7 @@
     field public static final java.lang.String FEATURE_NFC_HOST_CARD_EMULATION_NFCF = "android.hardware.nfc.hcef";
     field public static final java.lang.String FEATURE_OPENGLES_EXTENSION_PACK = "android.hardware.opengles.aep";
     field public static final java.lang.String FEATURE_PICTURE_IN_PICTURE = "android.software.picture_in_picture";
+    field public static final java.lang.String FEATURE_PPPOE = "android.software.pppoe";
     field public static final java.lang.String FEATURE_PRINTING = "android.software.print";
     field public static final java.lang.String FEATURE_SCREEN_LANDSCAPE = "android.hardware.screen.landscape";
     field public static final java.lang.String FEATURE_SCREEN_PORTRAIT = "android.hardware.screen.portrait";
@@ -15738,6 +15755,17 @@
     field public static final android.os.Parcelable.Creator<android.hardware.usb.UsbAccessory> CREATOR;
   }
 
+  public class UsbCameraManager {
+    ctor public UsbCameraManager();
+    field public static final java.lang.String ACTION_USB_CAMERA_PLUG_IN_OUT = "android.hardware.usb.action.USB_CAMERA_PLUG_IN_OUT";
+    field public static final java.lang.String EXTRA_MNG = "extral_mng";
+    field public static final int PLUG_IN = 1; // 0x1
+    field public static final int PLUG_OUT = 0; // 0x0
+    field public static final java.lang.String USB_CAMERA_NAME = "UsbCameraName";
+    field public static final java.lang.String USB_CAMERA_STATE = "UsbCameraState";
+    field public static final java.lang.String USB_CAMERA_TOTAL_NUMBER = "UsbCameraTotalNumber";
+  }
+
   public class UsbConfiguration implements android.os.Parcelable {
     method public int describeContents();
     method public int getId();
@@ -22666,6 +22694,7 @@
     field public static final int MEDIA_INFO_UNSUPPORTED_SUBTITLE = 901; // 0x385
     field public static final int MEDIA_INFO_VIDEO_RENDERING_START = 3; // 0x3
     field public static final int MEDIA_INFO_VIDEO_TRACK_LAGGING = 700; // 0x2bc
+    field public static final java.lang.String[] MEDIA_MIMETYPE;
     field public static final java.lang.String MEDIA_MIMETYPE_TEXT_SUBRIP = "application/x-subrip";
     field public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT = 1; // 0x1
     field public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING = 2; // 0x2
@@ -23249,8 +23278,48 @@
   }
 
   public final class TimedText {
+    method public android.graphics.Bitmap AWExtend_getBitmap();
+    method public int AWExtend_getBitmapSubtitleFlag();
+    method public int AWExtend_getHideSubFlag();
+    method public int AWExtend_getReferenceVideoHeight();
+    method public int AWExtend_getReferenceVideoWidth();
+    method public java.util.List<android.media.TimedText.Style> AWExtend_getStyleList();
+    method public int AWExtend_getSubDispPos();
+    method public int AWExtend_getSubtitleID();
+    method public android.graphics.Rect AWExtend_getTextScreenBounds();
     method public android.graphics.Rect getBounds();
     method public java.lang.String getText();
+    field public static final int SUB_DISPPOS_BOT_LEFT = 49; // 0x31
+    field public static final int SUB_DISPPOS_BOT_MID = 50; // 0x32
+    field public static final int SUB_DISPPOS_BOT_RIGHT = 51; // 0x33
+    field public static final int SUB_DISPPOS_DEFAULT = 0; // 0x0
+    field public static final int SUB_DISPPOS_MID_LEFT = 33; // 0x21
+    field public static final int SUB_DISPPOS_MID_MID = 34; // 0x22
+    field public static final int SUB_DISPPOS_MID_RIGHT = 35; // 0x23
+    field public static final int SUB_DISPPOS_TOP_LEFT = 17; // 0x11
+    field public static final int SUB_DISPPOS_TOP_MID = 18; // 0x12
+    field public static final int SUB_DISPPOS_TOP_RIGHT = 19; // 0x13
+    field public static final int SUB_RENDER_ALIGN_NONE = 0; // 0x0
+    field public static final int SUB_RENDER_HALIGN_CENTER = 2; // 0x2
+    field public static final int SUB_RENDER_HALIGN_LEFT = 1; // 0x1
+    field public static final int SUB_RENDER_HALIGN_RIGHT = 3; // 0x3
+    field public static final int SUB_RENDER_VALIGN_BOTTOM = 48; // 0x30
+    field public static final int SUB_RENDER_VALIGN_CENTER = 32; // 0x20
+    field public static final int SUB_RENDER_VALIGN_TOP = 16; // 0x10
+    field public static final int SUN_RENDER_HALIGN_MASK = 15; // 0xf
+    field public static final int SUN_RENDER_VALIGN_MASK = 240; // 0xf0
+  }
+
+  public static final class TimedText.Style {
+    ctor public TimedText.Style(int, int, int, boolean, boolean, boolean, int, int);
+    field public final int colorRGBA;
+    field public final int endChar;
+    field public final int fontID;
+    field public final int fontSize;
+    field public final boolean isBold;
+    field public final boolean isItalic;
+    field public final boolean isUnderlined;
+    field public final int startChar;
   }
 
   public class ToneGenerator {
@@ -25431,6 +25500,7 @@
     field public static final int TRANSPORT_BLUETOOTH = 2; // 0x2
     field public static final int TRANSPORT_CELLULAR = 0; // 0x0
     field public static final int TRANSPORT_ETHERNET = 3; // 0x3
+    field public static final int TRANSPORT_PPPOE = 5; // 0x5
     field public static final int TRANSPORT_VPN = 4; // 0x4
     field public static final int TRANSPORT_WIFI = 1; // 0x1
   }
@@ -30931,6 +31001,103 @@
     field public int otherSharedDirty;
   }
 
+  public class DisplayOutputManager {
+    method public int getDisplayBright(int);
+    method public int getDisplayContrast(int);
+    method public int getDisplayDenoise(int);
+    method public int getDisplayDetail(int);
+    method public int getDisplayEdge(int);
+    method public int getDisplayEnhanceMode(int);
+    method public int[] getDisplayMargin(int);
+    method public static int getDisplayModeFromFormat(int);
+    method public int[] getDisplayOffset(int);
+    method public int getDisplayOutput(int);
+    method public int getDisplayOutputCurDataspaceMode(int);
+    method public int getDisplayOutputDataspaceMode(int);
+    method public int getDisplayOutputMode(int);
+    method public int getDisplayOutputPixelFormat(int);
+    method public int getDisplayOutputType(int);
+    method public int getDisplaySaturation(int);
+    method public int getDisplaySupport3DMode(int);
+    method public static int getDisplayTypeFromFormat(int);
+    method public int[] getSupportModes(int, int);
+    method public boolean isCurrent3Doutput(int);
+    method public boolean isSupportHdmiMode(int, int);
+    method public int makeDisplayFormat(int, int);
+    method public int setDisplay3DLayerOffset(int, int);
+    method public int setDisplay3DMode(int, int);
+    method public int setDisplay3DMode(int, int, int);
+    method public int setDisplayBright(int, int);
+    method public int setDisplayContrast(int, int);
+    method public int setDisplayDenoise(int, int);
+    method public int setDisplayDetail(int, int);
+    method public int setDisplayEdge(int, int);
+    method public int setDisplayEnhanceMode(int, int);
+    method public int setDisplayMargin(int, int, int);
+    method public int setDisplayOffset(int, int, int);
+    method public int setDisplayOutput(int, int);
+    method public int setDisplayOutputDataspaceMode(int, int);
+    method public int setDisplayOutputMode(int, int);
+    method public int setDisplayOutputPixelFormat(int, int);
+    method public int setDisplaySaturation(int, int);
+    field public static final int DISPLAY_2D_DUAL_STREAM = 5; // 0x5
+    field public static final int DISPLAY_2D_LEFT = 1; // 0x1
+    field public static final int DISPLAY_2D_ORIGINAL = 0; // 0x0
+    field public static final int DISPLAY_2D_TOP = 2; // 0x2
+    field public static final int DISPLAY_3D_DUAL_STREAM = 6; // 0x6
+    field public static final int DISPLAY_3D_LEFT_RIGHT_HDMI = 3; // 0x3
+    field public static final int DISPLAY_3D_TOP_BOTTOM_HDMI = 4; // 0x4
+    field public static final int DISPLAY_OUTPUT_MODE_MASK = 255; // 0xff
+    field public static final int DISPLAY_OUTPUT_TYPE_HDMI = 4; // 0x4
+    field public static final int DISPLAY_OUTPUT_TYPE_LCD = 1; // 0x1
+    field public static final int DISPLAY_OUTPUT_TYPE_MASK = 65280; // 0xff00
+    field public static final int DISPLAY_OUTPUT_TYPE_NONE = 0; // 0x0
+    field public static final int DISPLAY_OUTPUT_TYPE_TV = 2; // 0x2
+    field public static final int DISPLAY_OUTPUT_TYPE_VGA = 8; // 0x8
+    field public static final int DISPLAY_TVFORMAT_1080I_50HZ = 6; // 0x6
+    field public static final int DISPLAY_TVFORMAT_1080I_60HZ = 7; // 0x7
+    field public static final int DISPLAY_TVFORMAT_1080P_24HZ = 8; // 0x8
+    field public static final int DISPLAY_TVFORMAT_1080P_25HZ = 26; // 0x1a
+    field public static final int DISPLAY_TVFORMAT_1080P_24HZ_3D_FP = 23; // 0x17
+    field public static final int DISPLAY_TVFORMAT_1080P_50HZ = 9; // 0x9
+    field public static final int DISPLAY_TVFORMAT_1080P_60HZ = 10; // 0xa
+    field public static final int DISPLAY_TVFORMAT_3840_2160P_24HZ = 30; // 0x1e
+    field public static final int DISPLAY_TVFORMAT_3840_2160P_25HZ = 29; // 0x1d
+    field public static final int DISPLAY_TVFORMAT_3840_2160P_30HZ = 28; // 0x1c
+    field public static final int DISPLAY_TVFORMAT_3840_2160P_60HZ = 34; // 0x22
+    field public static final int DISPLAY_TVFORMAT_4096_2160P_24HZ = 31; // 0x1f
+    field public static final int DISPLAY_TVFORMAT_4096_2160P_25HZ = 32; // 0x20
+    field public static final int DISPLAY_TVFORMAT_4096_2160P_30HZ = 33; // 0x21
+    field public static final int DISPLAY_TVFORMAT_4096_2160P_60HZ = 35; // 0x23
+    field public static final int DISPLAY_TVFORMAT_480I = 0; // 0x0
+    field public static final int DISPLAY_TVFORMAT_480P = 2; // 0x2
+    field public static final int DISPLAY_TVFORMAT_576I = 1; // 0x1
+    field public static final int DISPLAY_TVFORMAT_576P = 3; // 0x3
+    field public static final int DISPLAY_TVFORMAT_720P_50HZ = 4; // 0x4
+    field public static final int DISPLAY_TVFORMAT_720P_60HZ = 5; // 0x5
+    field public static final int DISPLAY_TVFORMAT_NTSC = 14; // 0xe
+    field public static final int DISPLAY_TVFORMAT_NTSC_CVBS_SVIDEO = 16; // 0x10
+    field public static final int DISPLAY_TVFORMAT_NTSC_SVIDEO = 15; // 0xf
+    field public static final int DISPLAY_TVFORMAT_PAL = 11; // 0xb
+    field public static final int DISPLAY_TVFORMAT_PAL_CVBS_SVIDEO = 13; // 0xd
+    field public static final int DISPLAY_TVFORMAT_PAL_M = 17; // 0x11
+    field public static final int DISPLAY_TVFORMAT_PAL_M_CVBS_SVIDEO = 19; // 0x13
+    field public static final int DISPLAY_TVFORMAT_PAL_M_SVIDEO = 18; // 0x12
+    field public static final int DISPLAY_TVFORMAT_PAL_NC = 20; // 0x14
+    field public static final int DISPLAY_TVFORMAT_PAL_NC_CVBS_SVIDEO = 22; // 0x16
+    field public static final int DISPLAY_TVFORMAT_PAL_NC_SVIDEO = 21; // 0x15
+    field public static final int DISPLAY_TVFORMAT_PAL_SVIDEO = 12; // 0xc
+    field public static final int DISPLAY_VGA_FORMAT_1024x768P_60HZ = 2; // 0x2
+    field public static final int DISPLAY_VGA_FORMAT_1280x768P_60HZ = 3; // 0x3
+    field public static final int DISPLAY_VGA_FORMAT_1280x800P_60HZ = 4; // 0x4
+    field public static final int DISPLAY_VGA_FORMAT_1366x768P_60HZ = 5; // 0x5
+    field public static final int DISPLAY_VGA_FORMAT_1440x900P_60HZ = 6; // 0x6
+    field public static final int DISPLAY_VGA_FORMAT_1920x1080P_60HZ = 7; // 0x7
+    field public static final int DISPLAY_VGA_FORMAT_1920x1200P_60HZ = 8; // 0x8
+    field public static final int DISPLAY_VGA_FORMAT_640x480P_60HZ = 0; // 0x0
+    field public static final int DISPLAY_VGA_FORMAT_800x600P_60HZ = 1; // 0x1
+  }
+
   public class DropBoxManager {
     ctor protected DropBoxManager();
     method public void addData(java.lang.String, byte[], int);
@@ -35078,6 +35245,7 @@
     field public static final java.lang.String MODE_RINGER = "mode_ringer";
     field public static final java.lang.String NETWORK_PREFERENCE = "network_preference";
     field public static final java.lang.String OTA_DISABLE_AUTOMATIC_UPDATE = "ota_disable_automatic_update";
+    field public static final java.lang.String PPPOE_ENABLED = "pppoe_enabled";
     field public static final java.lang.String RADIO_BLUETOOTH = "bluetooth";
     field public static final java.lang.String RADIO_CELL = "cell";
     field public static final java.lang.String RADIO_NFC = "nfc";
@@ -35141,10 +35309,18 @@
     field public static final android.net.Uri CONTENT_URI;
     field public static final deprecated java.lang.String DATA_ROAMING = "data_roaming";
     field public static final java.lang.String DEFAULT_INPUT_METHOD = "default_input_method";
+    field public static final java.lang.String DEFAULT_PLAYER_QUALITY = "default_player_quality";
+    field public static final java.lang.String DEFAULT_SCREEN_RATIO = "default_screen_ratio";
     field public static final deprecated java.lang.String DEVELOPMENT_SETTINGS_ENABLED = "development_settings_enabled";
     field public static final deprecated java.lang.String DEVICE_PROVISIONED = "device_provisioned";
+    field public static final java.lang.String DHCP_IPVER = "dhcp_ipver";
+    field public static final java.lang.String DHCP_OPTION = "dhcp_option";
+    field public static final java.lang.String DHCP_PSWD = "dhcp_pswd";
+    field public static final java.lang.String DHCP_USER = "dhcp_user";
+    field public static final java.lang.String DISPLAY_AREA = "display_area";
     field public static final java.lang.String ENABLED_ACCESSIBILITY_SERVICES = "enabled_accessibility_services";
     field public static final java.lang.String ENABLED_INPUT_METHODS = "enabled_input_methods";
+    field public static final java.lang.String HOME_PAGE = "home_page";
     field public static final deprecated java.lang.String HTTP_PROXY = "http_proxy";
     field public static final java.lang.String INPUT_METHOD_SELECTOR_VISIBILITY = "input_method_selector_visibility";
     field public static final java.lang.String INSTALL_NON_MARKET_APPS = "install_non_market_apps";
@@ -35159,12 +35335,20 @@
     field public static final deprecated java.lang.String LOCK_PATTERN_VISIBLE = "lock_pattern_visible_pattern";
     field public static final deprecated java.lang.String LOGGING_ID = "logging_id";
     field public static final deprecated java.lang.String NETWORK_PREFERENCE = "network_preference";
+    field public static final java.lang.String NTP_SERVER = "ntp_server";
+    field public static final java.lang.String NTP_SERVER2 = "ntp_server2";
+    field public static final java.lang.String NTVUSERACCOUNT = "ntvuseraccount";
+    field public static final java.lang.String NTVUSERPASSWORD = "ntvuserpassword";
+    field public static final java.lang.String NTVUSERSUFFIX = "ntvusersuffix";
     field public static final java.lang.String PARENTAL_CONTROL_ENABLED = "parental_control_enabled";
     field public static final java.lang.String PARENTAL_CONTROL_LAST_UPDATE = "parental_control_last_update";
     field public static final java.lang.String PARENTAL_CONTROL_REDIRECT_URL = "parental_control_redirect_url";
+    field public static final java.lang.String PPPOE_PSWD = "pppoe_pswd";
+    field public static final java.lang.String PPPOE_USERNAME = "pppoe_username";
     field public static final java.lang.String SELECTED_INPUT_METHOD_SUBTYPE = "selected_input_method_subtype";
     field public static final java.lang.String SETTINGS_CLASSNAME = "settings_classname";
     field public static final java.lang.String SKIP_FIRST_USE_HINTS = "skip_first_use_hints";
+    field public static final java.lang.String SQM_START_MODE = "sqm_start_mode";
     field public static final java.lang.String TOUCH_EXPLORATION_ENABLED = "touch_exploration_enabled";
     field public static final deprecated java.lang.String TTS_DEFAULT_COUNTRY = "tts_default_country";
     field public static final deprecated java.lang.String TTS_DEFAULT_LANG = "tts_default_lang";
@@ -35174,6 +35358,8 @@
     field public static final deprecated java.lang.String TTS_DEFAULT_VARIANT = "tts_default_variant";
     field public static final java.lang.String TTS_ENABLED_PLUGINS = "tts_enabled_plugins";
     field public static final deprecated java.lang.String TTS_USE_DEFAULTS = "tts_use_defaults";
+    field public static final java.lang.String UPGRADE_PATH = "upgrade_path";
+    field public static final java.lang.String UPGRADE_URL = "upgrade_url";
     field public static final deprecated java.lang.String USB_MASS_STORAGE_ENABLED = "usb_mass_storage_enabled";
     field public static final deprecated java.lang.String USE_GOOGLE_MAIL = "use_google_mail";
     field public static final deprecated java.lang.String WIFI_MAX_DHCP_RETRY_COUNT = "wifi_max_dhcp_retry_count";
@@ -35255,6 +35441,7 @@
     field public static final deprecated java.lang.String LOGGING_ID = "logging_id";
     field public static final deprecated java.lang.String MODE_RINGER = "mode_ringer";
     field public static final java.lang.String MODE_RINGER_STREAMS_AFFECTED = "mode_ringer_streams_affected";
+    field public static final java.lang.String MOUSE_ADVANCE = "mouse_advance";
     field public static final java.lang.String MUTE_STREAMS_AFFECTED = "mute_streams_affected";
     field public static final deprecated java.lang.String NETWORK_PREFERENCE = "network_preference";
     field public static final deprecated java.lang.String NEXT_ALARM_FORMATTED = "next_alarm_formatted";
@@ -44212,9 +44399,11 @@
     field public static final int KEYCODE_ALT_LEFT = 57; // 0x39
     field public static final int KEYCODE_ALT_RIGHT = 58; // 0x3a
     field public static final int KEYCODE_APOSTROPHE = 75; // 0x4b
+    field public static final int KEYCODE_APPS = 10011; // 0x271b
     field public static final int KEYCODE_APP_SWITCH = 187; // 0xbb
     field public static final int KEYCODE_ASSIST = 219; // 0xdb
     field public static final int KEYCODE_AT = 77; // 0x4d
+    field public static final int KEYCODE_AUDIO = 10003; // 0x2713
     field public static final int KEYCODE_AVR_INPUT = 182; // 0xb6
     field public static final int KEYCODE_AVR_POWER = 181; // 0xb5
     field public static final int KEYCODE_B = 30; // 0x1e
@@ -44224,6 +44413,7 @@
     field public static final int KEYCODE_BREAK = 121; // 0x79
     field public static final int KEYCODE_BRIGHTNESS_DOWN = 220; // 0xdc
     field public static final int KEYCODE_BRIGHTNESS_UP = 221; // 0xdd
+    field public static final int KEYCODE_BROWSER = 10012; // 0x271c
     field public static final int KEYCODE_BUTTON_1 = 188; // 0xbc
     field public static final int KEYCODE_BUTTON_10 = 197; // 0xc5
     field public static final int KEYCODE_BUTTON_11 = 198; // 0xc6
@@ -44290,6 +44480,7 @@
     field public static final int KEYCODE_ENVELOPE = 65; // 0x41
     field public static final int KEYCODE_EQUALS = 70; // 0x46
     field public static final int KEYCODE_ESCAPE = 111; // 0x6f
+    field public static final int KEYCODE_EXPAND = 10008; // 0x2718
     field public static final int KEYCODE_EXPLORER = 64; // 0x40
     field public static final int KEYCODE_F = 34; // 0x22
     field public static final int KEYCODE_F1 = 131; // 0x83
@@ -44304,11 +44495,13 @@
     field public static final int KEYCODE_F7 = 137; // 0x89
     field public static final int KEYCODE_F8 = 138; // 0x8a
     field public static final int KEYCODE_F9 = 139; // 0x8b
+    field public static final int KEYCODE_FAVOURITE = 10006; // 0x2716
     field public static final int KEYCODE_FOCUS = 80; // 0x50
     field public static final int KEYCODE_FORWARD = 125; // 0x7d
     field public static final int KEYCODE_FORWARD_DEL = 112; // 0x70
     field public static final int KEYCODE_FUNCTION = 119; // 0x77
     field public static final int KEYCODE_G = 35; // 0x23
+    field public static final int KEYCODE_GOTO = 10001; // 0x2711
     field public static final int KEYCODE_GRAVE = 68; // 0x44
     field public static final int KEYCODE_GUIDE = 172; // 0xac
     field public static final int KEYCODE_H = 36; // 0x24
@@ -44327,6 +44520,7 @@
     field public static final int KEYCODE_LANGUAGE_SWITCH = 204; // 0xcc
     field public static final int KEYCODE_LAST_CHANNEL = 229; // 0xe5
     field public static final int KEYCODE_LEFT_BRACKET = 71; // 0x47
+    field public static final int KEYCODE_LOOP = 10007; // 0x2717
     field public static final int KEYCODE_M = 41; // 0x29
     field public static final int KEYCODE_MANNER_MODE = 205; // 0xcd
     field public static final int KEYCODE_MEDIA_AUDIO_TRACK = 222; // 0xde
@@ -44350,8 +44544,10 @@
     field public static final int KEYCODE_META_LEFT = 117; // 0x75
     field public static final int KEYCODE_META_RIGHT = 118; // 0x76
     field public static final int KEYCODE_MINUS = 69; // 0x45
+    field public static final int KEYCODE_MOUSE = 10009; // 0x2719
     field public static final int KEYCODE_MOVE_END = 123; // 0x7b
     field public static final int KEYCODE_MOVE_HOME = 122; // 0x7a
+    field public static final int KEYCODE_MOVIE = 10010; // 0x271a
     field public static final int KEYCODE_MUHENKAN = 213; // 0xd5
     field public static final int KEYCODE_MUSIC = 209; // 0xd1
     field public static final int KEYCODE_MUTE = 91; // 0x5b
@@ -44403,6 +44599,7 @@
     field public static final int KEYCODE_RIGHT_BRACKET = 72; // 0x48
     field public static final int KEYCODE_RO = 217; // 0xd9
     field public static final int KEYCODE_S = 47; // 0x2f
+    field public static final int KEYCODE_SCREENSHOT = 10013; // 0x271d
     field public static final int KEYCODE_SCROLL_LOCK = 116; // 0x74
     field public static final int KEYCODE_SEARCH = 84; // 0x54
     field public static final int KEYCODE_SEMICOLON = 74; // 0x4a
@@ -44422,6 +44619,7 @@
     field public static final int KEYCODE_STEM_2 = 266; // 0x10a
     field public static final int KEYCODE_STEM_3 = 267; // 0x10b
     field public static final int KEYCODE_STEM_PRIMARY = 264; // 0x108
+    field public static final int KEYCODE_SUBTITLE = 10002; // 0x2712
     field public static final int KEYCODE_SWITCH_CHARSET = 95; // 0x5f
     field public static final int KEYCODE_SYM = 63; // 0x3f
     field public static final int KEYCODE_SYSRQ = 120; // 0x78
@@ -44453,6 +44651,7 @@
     field public static final int KEYCODE_TV_SATELLITE_BS = 238; // 0xee
     field public static final int KEYCODE_TV_SATELLITE_CS = 239; // 0xef
     field public static final int KEYCODE_TV_SATELLITE_SERVICE = 240; // 0xf0
+    field public static final int KEYCODE_TV_SYSTEM = 10000; // 0x2710
     field public static final int KEYCODE_TV_TELETEXT = 233; // 0xe9
     field public static final int KEYCODE_TV_TERRESTRIAL_ANALOG = 235; // 0xeb
     field public static final int KEYCODE_TV_TERRESTRIAL_DIGITAL = 236; // 0xec
@@ -44473,6 +44672,7 @@
     field public static final int KEYCODE_YEN = 216; // 0xd8
     field public static final int KEYCODE_Z = 54; // 0x36
     field public static final int KEYCODE_ZENKAKU_HANKAKU = 211; // 0xd3
+    field public static final int KEYCODE_ZOOM = 10004; // 0x2714
     field public static final int KEYCODE_ZOOM_IN = 168; // 0xa8
     field public static final int KEYCODE_ZOOM_OUT = 169; // 0xa9
     field public static final deprecated int MAX_KEYCODE = 84; // 0x54
diff -ur ../aosp/frameworks/base/api/test-current.txt ../Desktop/android/frameworks/base/api/test-current.txt
--- ../aosp/frameworks/base/api/test-current.txt	2018-08-06 15:40:21.219142341 +0200
+++ ../Desktop/android/frameworks/base/api/test-current.txt	2017-11-23 05:21:11.000000000 +0100
@@ -7395,6 +7395,18 @@
     field public static final int TYPE_SCO = 2; // 0x2
   }
 
+  public abstract interface IBluetoothRtkbt implements android.os.IInterface {
+    method public abstract int GenericCommand(int, int, byte[], int) throws android.os.RemoteException;
+    method public abstract int GetFeature(int) throws android.os.RemoteException;
+  }
+
+  public static abstract class IBluetoothRtkbt.Stub extends android.os.Binder implements android.bluetooth.IBluetoothRtkbt {
+    ctor public IBluetoothRtkbt.Stub();
+    method public android.os.IBinder asBinder();
+    method public static android.bluetooth.IBluetoothRtkbt asInterface(android.os.IBinder);
+    method public boolean onTransact(int, android.os.Parcel, android.os.Parcel, int) throws android.os.RemoteException;
+  }
+
 }
 
 package android.bluetooth.le {
@@ -8167,6 +8179,7 @@
     field public static final int CONTEXT_INCLUDE_CODE = 1; // 0x1
     field public static final int CONTEXT_RESTRICTED = 4; // 0x4
     field public static final java.lang.String DEVICE_POLICY_SERVICE = "device_policy";
+    field public static final java.lang.String DISPLAYOUTPUT_SERVICE = "display_output";
     field public static final java.lang.String DISPLAY_SERVICE = "display";
     field public static final java.lang.String DOWNLOAD_SERVICE = "download";
     field public static final java.lang.String DROPBOX_SERVICE = "dropbox";
@@ -8530,6 +8543,7 @@
     field public static final java.lang.String ACTION_APP_ERROR = "android.intent.action.APP_ERROR";
     field public static final java.lang.String ACTION_ASSIST = "android.intent.action.ASSIST";
     field public static final java.lang.String ACTION_ATTACH_DATA = "android.intent.action.ATTACH_DATA";
+    field public static final java.lang.String ACTION_AUDIO_PLUG_IN_OUT = "android.intent.action.AUDIO_PLUG_IN_OUT";
     field public static final java.lang.String ACTION_BATTERY_CHANGED = "android.intent.action.BATTERY_CHANGED";
     field public static final java.lang.String ACTION_BATTERY_LOW = "android.intent.action.BATTERY_LOW";
     field public static final java.lang.String ACTION_BATTERY_OKAY = "android.intent.action.BATTERY_OKAY";
@@ -8560,6 +8574,8 @@
     field public static final java.lang.String ACTION_GET_RESTRICTION_ENTRIES = "android.intent.action.GET_RESTRICTION_ENTRIES";
     field public static final java.lang.String ACTION_GTALK_SERVICE_CONNECTED = "android.intent.action.GTALK_CONNECTED";
     field public static final java.lang.String ACTION_GTALK_SERVICE_DISCONNECTED = "android.intent.action.GTALK_DISCONNECTED";
+    field public static final java.lang.String ACTION_HDMISTATUS_CHANGED = "android.intent.action.HDMISTATUS_CHANGED";
+    field public static final java.lang.String ACTION_HDMI_PLUGGED = "android.intent.action.HDMI_PLUGGED";
     field public static final java.lang.String ACTION_HEADSET_PLUG = "android.intent.action.HEADSET_PLUG";
     field public static final java.lang.String ACTION_INPUT_METHOD_CHANGED = "android.intent.action.INPUT_METHOD_CHANGED";
     field public static final java.lang.String ACTION_INSERT = "android.intent.action.INSERT";
@@ -9820,6 +9836,7 @@
     field public static final java.lang.String FEATURE_NFC_HOST_CARD_EMULATION_NFCF = "android.hardware.nfc.hcef";
     field public static final java.lang.String FEATURE_OPENGLES_EXTENSION_PACK = "android.hardware.opengles.aep";
     field public static final java.lang.String FEATURE_PICTURE_IN_PICTURE = "android.software.picture_in_picture";
+    field public static final java.lang.String FEATURE_PPPOE = "android.software.pppoe";
     field public static final java.lang.String FEATURE_PRINTING = "android.software.print";
     field public static final java.lang.String FEATURE_SCREEN_LANDSCAPE = "android.hardware.screen.landscape";
     field public static final java.lang.String FEATURE_SCREEN_PORTRAIT = "android.hardware.screen.portrait";
@@ -14550,6 +14567,17 @@
     field public static final android.os.Parcelable.Creator<android.hardware.usb.UsbAccessory> CREATOR;
   }
 
+  public class UsbCameraManager {
+    ctor public UsbCameraManager();
+    field public static final java.lang.String ACTION_USB_CAMERA_PLUG_IN_OUT = "android.hardware.usb.action.USB_CAMERA_PLUG_IN_OUT";
+    field public static final java.lang.String EXTRA_MNG = "extral_mng";
+    field public static final int PLUG_IN = 1; // 0x1
+    field public static final int PLUG_OUT = 0; // 0x0
+    field public static final java.lang.String USB_CAMERA_NAME = "UsbCameraName";
+    field public static final java.lang.String USB_CAMERA_STATE = "UsbCameraState";
+    field public static final java.lang.String USB_CAMERA_TOTAL_NUMBER = "UsbCameraTotalNumber";
+  }
+
   public class UsbConfiguration implements android.os.Parcelable {
     method public int describeContents();
     method public int getId();
@@ -21215,6 +21243,7 @@
     field public static final int MEDIA_INFO_UNSUPPORTED_SUBTITLE = 901; // 0x385
     field public static final int MEDIA_INFO_VIDEO_RENDERING_START = 3; // 0x3
     field public static final int MEDIA_INFO_VIDEO_TRACK_LAGGING = 700; // 0x2bc
+    field public static final java.lang.String[] MEDIA_MIMETYPE;
     field public static final java.lang.String MEDIA_MIMETYPE_TEXT_SUBRIP = "application/x-subrip";
     field public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT = 1; // 0x1
     field public static final int VIDEO_SCALING_MODE_SCALE_TO_FIT_WITH_CROPPING = 2; // 0x2
@@ -21796,8 +21825,48 @@
   }
 
   public final class TimedText {
+    method public android.graphics.Bitmap AWExtend_getBitmap();
+    method public int AWExtend_getBitmapSubtitleFlag();
+    method public int AWExtend_getHideSubFlag();
+    method public int AWExtend_getReferenceVideoHeight();
+    method public int AWExtend_getReferenceVideoWidth();
+    method public java.util.List<android.media.TimedText.Style> AWExtend_getStyleList();
+    method public int AWExtend_getSubDispPos();
+    method public int AWExtend_getSubtitleID();
+    method public android.graphics.Rect AWExtend_getTextScreenBounds();
     method public android.graphics.Rect getBounds();
     method public java.lang.String getText();
+    field public static final int SUB_DISPPOS_BOT_LEFT = 49; // 0x31
+    field public static final int SUB_DISPPOS_BOT_MID = 50; // 0x32
+    field public static final int SUB_DISPPOS_BOT_RIGHT = 51; // 0x33
+    field public static final int SUB_DISPPOS_DEFAULT = 0; // 0x0
+    field public static final int SUB_DISPPOS_MID_LEFT = 33; // 0x21
+    field public static final int SUB_DISPPOS_MID_MID = 34; // 0x22
+    field public static final int SUB_DISPPOS_MID_RIGHT = 35; // 0x23
+    field public static final int SUB_DISPPOS_TOP_LEFT = 17; // 0x11
+    field public static final int SUB_DISPPOS_TOP_MID = 18; // 0x12
+    field public static final int SUB_DISPPOS_TOP_RIGHT = 19; // 0x13
+    field public static final int SUB_RENDER_ALIGN_NONE = 0; // 0x0
+    field public static final int SUB_RENDER_HALIGN_CENTER = 2; // 0x2
+    field public static final int SUB_RENDER_HALIGN_LEFT = 1; // 0x1
+    field public static final int SUB_RENDER_HALIGN_RIGHT = 3; // 0x3
+    field public static final int SUB_RENDER_VALIGN_BOTTOM = 48; // 0x30
+    field public static final int SUB_RENDER_VALIGN_CENTER = 32; // 0x20
+    field public static final int SUB_RENDER_VALIGN_TOP = 16; // 0x10
+    field public static final int SUN_RENDER_HALIGN_MASK = 15; // 0xf
+    field public static final int SUN_RENDER_VALIGN_MASK = 240; // 0xf0
+  }
+
+  public static final class TimedText.Style {
+    ctor public TimedText.Style(int, int, int, boolean, boolean, boolean, int, int);
+    field public final int colorRGBA;
+    field public final int endChar;
+    field public final int fontID;
+    field public final int fontSize;
+    field public final boolean isBold;
+    field public final boolean isItalic;
+    field public final boolean isUnderlined;
+    field public final int startChar;
   }
 
   public class ToneGenerator {
@@ -23676,6 +23745,7 @@
     field public static final int TRANSPORT_BLUETOOTH = 2; // 0x2
     field public static final int TRANSPORT_CELLULAR = 0; // 0x0
     field public static final int TRANSPORT_ETHERNET = 3; // 0x3
+    field public static final int TRANSPORT_PPPOE = 5; // 0x5
     field public static final int TRANSPORT_VPN = 4; // 0x4
     field public static final int TRANSPORT_WIFI = 1; // 0x1
   }
@@ -28559,6 +28629,103 @@
     field public int otherSharedDirty;
   }
 
+  public class DisplayOutputManager {
+    method public int getDisplayBright(int);
+    method public int getDisplayContrast(int);
+    method public int getDisplayDenoise(int);
+    method public int getDisplayDetail(int);
+    method public int getDisplayEdge(int);
+    method public int getDisplayEnhanceMode(int);
+    method public int[] getDisplayMargin(int);
+    method public static int getDisplayModeFromFormat(int);
+    method public int[] getDisplayOffset(int);
+    method public int getDisplayOutput(int);
+    method public int getDisplayOutputCurDataspaceMode(int);
+    method public int getDisplayOutputDataspaceMode(int);
+    method public int getDisplayOutputMode(int);
+    method public int getDisplayOutputPixelFormat(int);
+    method public int getDisplayOutputType(int);
+    method public int getDisplaySaturation(int);
+    method public int getDisplaySupport3DMode(int);
+    method public static int getDisplayTypeFromFormat(int);
+    method public int[] getSupportModes(int, int);
+    method public boolean isCurrent3Doutput(int);
+    method public boolean isSupportHdmiMode(int, int);
+    method public int makeDisplayFormat(int, int);
+    method public int setDisplay3DLayerOffset(int, int);
+    method public int setDisplay3DMode(int, int);
+    method public int setDisplay3DMode(int, int, int);
+    method public int setDisplayBright(int, int);
+    method public int setDisplayContrast(int, int);
+    method public int setDisplayDenoise(int, int);
+    method public int setDisplayDetail(int, int);
+    method public int setDisplayEdge(int, int);
+    method public int setDisplayEnhanceMode(int, int);
+    method public int setDisplayMargin(int, int, int);
+    method public int setDisplayOffset(int, int, int);
+    method public int setDisplayOutput(int, int);
+    method public int setDisplayOutputDataspaceMode(int, int);
+    method public int setDisplayOutputMode(int, int);
+    method public int setDisplayOutputPixelFormat(int, int);
+    method public int setDisplaySaturation(int, int);
+    field public static final int DISPLAY_2D_DUAL_STREAM = 5; // 0x5
+    field public static final int DISPLAY_2D_LEFT = 1; // 0x1
+    field public static final int DISPLAY_2D_ORIGINAL = 0; // 0x0
+    field public static final int DISPLAY_2D_TOP = 2; // 0x2
+    field public static final int DISPLAY_3D_DUAL_STREAM = 6; // 0x6
+    field public static final int DISPLAY_3D_LEFT_RIGHT_HDMI = 3; // 0x3
+    field public static final int DISPLAY_3D_TOP_BOTTOM_HDMI = 4; // 0x4
+    field public static final int DISPLAY_OUTPUT_MODE_MASK = 255; // 0xff
+    field public static final int DISPLAY_OUTPUT_TYPE_HDMI = 4; // 0x4
+    field public static final int DISPLAY_OUTPUT_TYPE_LCD = 1; // 0x1
+    field public static final int DISPLAY_OUTPUT_TYPE_MASK = 65280; // 0xff00
+    field public static final int DISPLAY_OUTPUT_TYPE_NONE = 0; // 0x0
+    field public static final int DISPLAY_OUTPUT_TYPE_TV = 2; // 0x2
+    field public static final int DISPLAY_OUTPUT_TYPE_VGA = 8; // 0x8
+    field public static final int DISPLAY_TVFORMAT_1080I_50HZ = 6; // 0x6
+    field public static final int DISPLAY_TVFORMAT_1080I_60HZ = 7; // 0x7
+    field public static final int DISPLAY_TVFORMAT_1080P_24HZ = 8; // 0x8
+    field public static final int DISPLAY_TVFORMAT_1080P_25HZ = 26; // 0x1a
+    field public static final int DISPLAY_TVFORMAT_1080P_24HZ_3D_FP = 23; // 0x17
+    field public static final int DISPLAY_TVFORMAT_1080P_50HZ = 9; // 0x9
+    field public static final int DISPLAY_TVFORMAT_1080P_60HZ = 10; // 0xa
+    field public static final int DISPLAY_TVFORMAT_3840_2160P_24HZ = 30; // 0x1e
+    field public static final int DISPLAY_TVFORMAT_3840_2160P_25HZ = 29; // 0x1d
+    field public static final int DISPLAY_TVFORMAT_3840_2160P_30HZ = 28; // 0x1c
+    field public static final int DISPLAY_TVFORMAT_3840_2160P_60HZ = 34; // 0x22
+    field public static final int DISPLAY_TVFORMAT_4096_2160P_24HZ = 31; // 0x1f
+    field public static final int DISPLAY_TVFORMAT_4096_2160P_25HZ = 32; // 0x20
+    field public static final int DISPLAY_TVFORMAT_4096_2160P_30HZ = 33; // 0x21
+    field public static final int DISPLAY_TVFORMAT_4096_2160P_60HZ = 35; // 0x23
+    field public static final int DISPLAY_TVFORMAT_480I = 0; // 0x0
+    field public static final int DISPLAY_TVFORMAT_480P = 2; // 0x2
+    field public static final int DISPLAY_TVFORMAT_576I = 1; // 0x1
+    field public static final int DISPLAY_TVFORMAT_576P = 3; // 0x3
+    field public static final int DISPLAY_TVFORMAT_720P_50HZ = 4; // 0x4
+    field public static final int DISPLAY_TVFORMAT_720P_60HZ = 5; // 0x5
+    field public static final int DISPLAY_TVFORMAT_NTSC = 14; // 0xe
+    field public static final int DISPLAY_TVFORMAT_NTSC_CVBS_SVIDEO = 16; // 0x10
+    field public static final int DISPLAY_TVFORMAT_NTSC_SVIDEO = 15; // 0xf
+    field public static final int DISPLAY_TVFORMAT_PAL = 11; // 0xb
+    field public static final int DISPLAY_TVFORMAT_PAL_CVBS_SVIDEO = 13; // 0xd
+    field public static final int DISPLAY_TVFORMAT_PAL_M = 17; // 0x11
+    field public static final int DISPLAY_TVFORMAT_PAL_M_CVBS_SVIDEO = 19; // 0x13
+    field public static final int DISPLAY_TVFORMAT_PAL_M_SVIDEO = 18; // 0x12
+    field public static final int DISPLAY_TVFORMAT_PAL_NC = 20; // 0x14
+    field public static final int DISPLAY_TVFORMAT_PAL_NC_CVBS_SVIDEO = 22; // 0x16
+    field public static final int DISPLAY_TVFORMAT_PAL_NC_SVIDEO = 21; // 0x15
+    field public static final int DISPLAY_TVFORMAT_PAL_SVIDEO = 12; // 0xc
+    field public static final int DISPLAY_VGA_FORMAT_1024x768P_60HZ = 2; // 0x2
+    field public static final int DISPLAY_VGA_FORMAT_1280x768P_60HZ = 3; // 0x3
+    field public static final int DISPLAY_VGA_FORMAT_1280x800P_60HZ = 4; // 0x4
+    field public static final int DISPLAY_VGA_FORMAT_1366x768P_60HZ = 5; // 0x5
+    field public static final int DISPLAY_VGA_FORMAT_1440x900P_60HZ = 6; // 0x6
+    field public static final int DISPLAY_VGA_FORMAT_1920x1080P_60HZ = 7; // 0x7
+    field public static final int DISPLAY_VGA_FORMAT_1920x1200P_60HZ = 8; // 0x8
+    field public static final int DISPLAY_VGA_FORMAT_640x480P_60HZ = 0; // 0x0
+    field public static final int DISPLAY_VGA_FORMAT_800x600P_60HZ = 1; // 0x1
+  }
+
   public class DropBoxManager {
     ctor protected DropBoxManager();
     method public void addData(java.lang.String, byte[], int);
@@ -32445,6 +32612,7 @@
     field public static final deprecated java.lang.String INSTALL_NON_MARKET_APPS = "install_non_market_apps";
     field public static final java.lang.String MODE_RINGER = "mode_ringer";
     field public static final java.lang.String NETWORK_PREFERENCE = "network_preference";
+    field public static final java.lang.String PPPOE_ENABLED = "pppoe_enabled";
     field public static final java.lang.String RADIO_BLUETOOTH = "bluetooth";
     field public static final java.lang.String RADIO_CELL = "cell";
     field public static final java.lang.String RADIO_NFC = "nfc";
@@ -32506,11 +32674,19 @@
     field public static final android.net.Uri CONTENT_URI;
     field public static final deprecated java.lang.String DATA_ROAMING = "data_roaming";
     field public static final java.lang.String DEFAULT_INPUT_METHOD = "default_input_method";
+    field public static final java.lang.String DEFAULT_PLAYER_QUALITY = "default_player_quality";
+    field public static final java.lang.String DEFAULT_SCREEN_RATIO = "default_screen_ratio";
     field public static final deprecated java.lang.String DEVELOPMENT_SETTINGS_ENABLED = "development_settings_enabled";
     field public static final deprecated java.lang.String DEVICE_PROVISIONED = "device_provisioned";
+    field public static final java.lang.String DHCP_IPVER = "dhcp_ipver";
+    field public static final java.lang.String DHCP_OPTION = "dhcp_option";
+    field public static final java.lang.String DHCP_PSWD = "dhcp_pswd";
+    field public static final java.lang.String DHCP_USER = "dhcp_user";
+    field public static final java.lang.String DISPLAY_AREA = "display_area";
     field public static final java.lang.String ENABLED_ACCESSIBILITY_SERVICES = "enabled_accessibility_services";
     field public static final java.lang.String ENABLED_INPUT_METHODS = "enabled_input_methods";
     field public static final java.lang.String ENABLED_NOTIFICATION_POLICY_ACCESS_PACKAGES = "enabled_notification_policy_access_packages";
+    field public static final java.lang.String HOME_PAGE = "home_page";
     field public static final deprecated java.lang.String HTTP_PROXY = "http_proxy";
     field public static final java.lang.String INPUT_METHOD_SELECTOR_VISIBILITY = "input_method_selector_visibility";
     field public static final java.lang.String INSTALL_NON_MARKET_APPS = "install_non_market_apps";
@@ -32525,12 +32701,20 @@
     field public static final deprecated java.lang.String LOCK_PATTERN_VISIBLE = "lock_pattern_visible_pattern";
     field public static final deprecated java.lang.String LOGGING_ID = "logging_id";
     field public static final deprecated java.lang.String NETWORK_PREFERENCE = "network_preference";
+    field public static final java.lang.String NTP_SERVER = "ntp_server";
+    field public static final java.lang.String NTP_SERVER2 = "ntp_server2";
+    field public static final java.lang.String NTVUSERACCOUNT = "ntvuseraccount";
+    field public static final java.lang.String NTVUSERPASSWORD = "ntvuserpassword";
+    field public static final java.lang.String NTVUSERSUFFIX = "ntvusersuffix";
     field public static final java.lang.String PARENTAL_CONTROL_ENABLED = "parental_control_enabled";
     field public static final java.lang.String PARENTAL_CONTROL_LAST_UPDATE = "parental_control_last_update";
     field public static final java.lang.String PARENTAL_CONTROL_REDIRECT_URL = "parental_control_redirect_url";
+    field public static final java.lang.String PPPOE_PSWD = "pppoe_pswd";
+    field public static final java.lang.String PPPOE_USERNAME = "pppoe_username";
     field public static final java.lang.String SELECTED_INPUT_METHOD_SUBTYPE = "selected_input_method_subtype";
     field public static final java.lang.String SETTINGS_CLASSNAME = "settings_classname";
     field public static final java.lang.String SKIP_FIRST_USE_HINTS = "skip_first_use_hints";
+    field public static final java.lang.String SQM_START_MODE = "sqm_start_mode";
     field public static final java.lang.String TOUCH_EXPLORATION_ENABLED = "touch_exploration_enabled";
     field public static final deprecated java.lang.String TTS_DEFAULT_COUNTRY = "tts_default_country";
     field public static final deprecated java.lang.String TTS_DEFAULT_LANG = "tts_default_lang";
@@ -32540,6 +32724,8 @@
     field public static final deprecated java.lang.String TTS_DEFAULT_VARIANT = "tts_default_variant";
     field public static final java.lang.String TTS_ENABLED_PLUGINS = "tts_enabled_plugins";
     field public static final deprecated java.lang.String TTS_USE_DEFAULTS = "tts_use_defaults";
+    field public static final java.lang.String UPGRADE_PATH = "upgrade_path";
+    field public static final java.lang.String UPGRADE_URL = "upgrade_url";
     field public static final deprecated java.lang.String USB_MASS_STORAGE_ENABLED = "usb_mass_storage_enabled";
     field public static final deprecated java.lang.String USE_GOOGLE_MAIL = "use_google_mail";
     field public static final java.lang.String VOICE_INTERACTION_SERVICE = "voice_interaction_service";
@@ -32622,6 +32808,7 @@
     field public static final deprecated java.lang.String LOGGING_ID = "logging_id";
     field public static final deprecated java.lang.String MODE_RINGER = "mode_ringer";
     field public static final java.lang.String MODE_RINGER_STREAMS_AFFECTED = "mode_ringer_streams_affected";
+    field public static final java.lang.String MOUSE_ADVANCE = "mouse_advance";
     field public static final java.lang.String MUTE_STREAMS_AFFECTED = "mute_streams_affected";
     field public static final deprecated java.lang.String NETWORK_PREFERENCE = "network_preference";
     field public static final deprecated java.lang.String NEXT_ALARM_FORMATTED = "next_alarm_formatted";
@@ -41291,9 +41478,11 @@
     field public static final int KEYCODE_ALT_LEFT = 57; // 0x39
     field public static final int KEYCODE_ALT_RIGHT = 58; // 0x3a
     field public static final int KEYCODE_APOSTROPHE = 75; // 0x4b
+    field public static final int KEYCODE_APPS = 10011; // 0x271b
     field public static final int KEYCODE_APP_SWITCH = 187; // 0xbb
     field public static final int KEYCODE_ASSIST = 219; // 0xdb
     field public static final int KEYCODE_AT = 77; // 0x4d
+    field public static final int KEYCODE_AUDIO = 10003; // 0x2713
     field public static final int KEYCODE_AVR_INPUT = 182; // 0xb6
     field public static final int KEYCODE_AVR_POWER = 181; // 0xb5
     field public static final int KEYCODE_B = 30; // 0x1e
@@ -41303,6 +41492,7 @@
     field public static final int KEYCODE_BREAK = 121; // 0x79
     field public static final int KEYCODE_BRIGHTNESS_DOWN = 220; // 0xdc
     field public static final int KEYCODE_BRIGHTNESS_UP = 221; // 0xdd
+    field public static final int KEYCODE_BROWSER = 10012; // 0x271c
     field public static final int KEYCODE_BUTTON_1 = 188; // 0xbc
     field public static final int KEYCODE_BUTTON_10 = 197; // 0xc5
     field public static final int KEYCODE_BUTTON_11 = 198; // 0xc6
@@ -41369,6 +41559,7 @@
     field public static final int KEYCODE_ENVELOPE = 65; // 0x41
     field public static final int KEYCODE_EQUALS = 70; // 0x46
     field public static final int KEYCODE_ESCAPE = 111; // 0x6f
+    field public static final int KEYCODE_EXPAND = 10008; // 0x2718
     field public static final int KEYCODE_EXPLORER = 64; // 0x40
     field public static final int KEYCODE_F = 34; // 0x22
     field public static final int KEYCODE_F1 = 131; // 0x83
@@ -41383,11 +41574,13 @@
     field public static final int KEYCODE_F7 = 137; // 0x89
     field public static final int KEYCODE_F8 = 138; // 0x8a
     field public static final int KEYCODE_F9 = 139; // 0x8b
+    field public static final int KEYCODE_FAVOURITE = 10006; // 0x2716
     field public static final int KEYCODE_FOCUS = 80; // 0x50
     field public static final int KEYCODE_FORWARD = 125; // 0x7d
     field public static final int KEYCODE_FORWARD_DEL = 112; // 0x70
     field public static final int KEYCODE_FUNCTION = 119; // 0x77
     field public static final int KEYCODE_G = 35; // 0x23
+    field public static final int KEYCODE_GOTO = 10001; // 0x2711
     field public static final int KEYCODE_GRAVE = 68; // 0x44
     field public static final int KEYCODE_GUIDE = 172; // 0xac
     field public static final int KEYCODE_H = 36; // 0x24
@@ -41406,6 +41599,7 @@
     field public static final int KEYCODE_LANGUAGE_SWITCH = 204; // 0xcc
     field public static final int KEYCODE_LAST_CHANNEL = 229; // 0xe5
     field public static final int KEYCODE_LEFT_BRACKET = 71; // 0x47
+    field public static final int KEYCODE_LOOP = 10007; // 0x2717
     field public static final int KEYCODE_M = 41; // 0x29
     field public static final int KEYCODE_MANNER_MODE = 205; // 0xcd
     field public static final int KEYCODE_MEDIA_AUDIO_TRACK = 222; // 0xde
@@ -41429,8 +41623,10 @@
     field public static final int KEYCODE_META_LEFT = 117; // 0x75
     field public static final int KEYCODE_META_RIGHT = 118; // 0x76
     field public static final int KEYCODE_MINUS = 69; // 0x45
+    field public static final int KEYCODE_MOUSE = 10009; // 0x2719
     field public static final int KEYCODE_MOVE_END = 123; // 0x7b
     field public static final int KEYCODE_MOVE_HOME = 122; // 0x7a
+    field public static final int KEYCODE_MOVIE = 10010; // 0x271a
     field public static final int KEYCODE_MUHENKAN = 213; // 0xd5
     field public static final int KEYCODE_MUSIC = 209; // 0xd1
     field public static final int KEYCODE_MUTE = 91; // 0x5b
@@ -41482,6 +41678,7 @@
     field public static final int KEYCODE_RIGHT_BRACKET = 72; // 0x48
     field public static final int KEYCODE_RO = 217; // 0xd9
     field public static final int KEYCODE_S = 47; // 0x2f
+    field public static final int KEYCODE_SCREENSHOT = 10013; // 0x271d
     field public static final int KEYCODE_SCROLL_LOCK = 116; // 0x74
     field public static final int KEYCODE_SEARCH = 84; // 0x54
     field public static final int KEYCODE_SEMICOLON = 74; // 0x4a
@@ -41501,6 +41698,7 @@
     field public static final int KEYCODE_STEM_2 = 266; // 0x10a
     field public static final int KEYCODE_STEM_3 = 267; // 0x10b
     field public static final int KEYCODE_STEM_PRIMARY = 264; // 0x108
+    field public static final int KEYCODE_SUBTITLE = 10002; // 0x2712
     field public static final int KEYCODE_SWITCH_CHARSET = 95; // 0x5f
     field public static final int KEYCODE_SYM = 63; // 0x3f
     field public static final int KEYCODE_SYSRQ = 120; // 0x78
@@ -41532,6 +41730,7 @@
     field public static final int KEYCODE_TV_SATELLITE_BS = 238; // 0xee
     field public static final int KEYCODE_TV_SATELLITE_CS = 239; // 0xef
     field public static final int KEYCODE_TV_SATELLITE_SERVICE = 240; // 0xf0
+    field public static final int KEYCODE_TV_SYSTEM = 10000; // 0x2710
     field public static final int KEYCODE_TV_TELETEXT = 233; // 0xe9
     field public static final int KEYCODE_TV_TERRESTRIAL_ANALOG = 235; // 0xeb
     field public static final int KEYCODE_TV_TERRESTRIAL_DIGITAL = 236; // 0xec
@@ -41552,6 +41751,7 @@
     field public static final int KEYCODE_YEN = 216; // 0xd8
     field public static final int KEYCODE_Z = 54; // 0x36
     field public static final int KEYCODE_ZENKAKU_HANKAKU = 211; // 0xd3
+    field public static final int KEYCODE_ZOOM = 10004; // 0x2714
     field public static final int KEYCODE_ZOOM_IN = 168; // 0xa8
     field public static final int KEYCODE_ZOOM_OUT = 169; // 0xa9
     field public static final deprecated int MAX_KEYCODE = 84; // 0x54
diff -ur ../aosp/frameworks/base/cmds/bootanimation/Android.mk ../Desktop/android/frameworks/base/cmds/bootanimation/Android.mk
--- ../aosp/frameworks/base/cmds/bootanimation/Android.mk	2018-08-06 15:40:21.267142957 +0200
+++ ../Desktop/android/frameworks/base/cmds/bootanimation/Android.mk	2017-11-23 05:21:11.000000000 +0100
@@ -23,7 +23,8 @@
     libEGL \
     libGLESv1_CM \
     libgui \
-    libtinyalsa
+    libtinyalsa \
+    libmedia
 
 LOCAL_MODULE:= bootanimation
 
diff -ur ../aosp/frameworks/base/cmds/bootanimation/AudioPlayer.cpp ../Desktop/android/frameworks/base/cmds/bootanimation/AudioPlayer.cpp
--- ../aosp/frameworks/base/cmds/bootanimation/AudioPlayer.cpp	2018-08-06 15:40:21.267142957 +0200
+++ ../Desktop/android/frameworks/base/cmds/bootanimation/AudioPlayer.cpp	2017-11-23 05:21:11.000000000 +0100
@@ -20,7 +20,7 @@
 #include "AudioPlayer.h"
 
 #include <androidfw/ZipFileRO.h>
-#include <tinyalsa/asoundlib.h>
+
 #include <utils/Log.h>
 #include <utils/String8.h>
 
@@ -32,6 +32,29 @@
 // Maximum line length for audio_conf.txt
 // We only accept lines less than this length to avoid overflows using sscanf()
 #define MAX_LINE_LENGTH 1024
+#define AUDIO_MAP_CNT 16
+#define NAME_LEN 20
+#define PATH_LEN 30
+#define WRITE_BUF 4096
+
+//for ahub
+#define HUB "sndahub"
+int output_card = -1;
+
+typedef struct name_map_t
+{
+    char name[NAME_LEN];
+    int card_num;
+    int active;
+    int output_device;
+}name_map;
+
+static name_map audio_name_map[AUDIO_MAP_CNT] =
+{
+    {"sndacx00codec",        -1,        1,  1},
+    {"sndhdmi",              -1,        1,  0},
+    {"sndspdif",             -1,        0, -1},
+};
 
 struct riff_wave_header {
     uint32_t riff_id;
@@ -61,12 +84,45 @@
         mDevice(-1),
         mPeriodSize(0),
         mPeriodCount(0),
+        ahub_mixer(NULL),
         mCurrentFile(NULL)
 {
 }
 
 AudioPlayer::~AudioPlayer() {
+    for(int index = 0; index < CARD_NUM; index++)
+    {
+        if(cards[index].pcm)
+        {
+            pcm_close(cards[index].pcm);
+            cards[index].pcm = NULL;
+        }
+        if(cards[index].hub_pcm)
+        {
+            pcm_close(cards[index].hub_pcm);
+            cards[index].hub_pcm = NULL;
+        }
+    }
 }
+static bool setHubRoute(struct mixer* mixer)
+{
+    struct mixer_ctl *ctl;
+    //i2s1->APBIF_TXDIF0
+    ctl = mixer_get_ctl_by_name(mixer, "I2S1 Src Select");
+    mixer_ctl_set_value(ctl, 0, 1);
+    //enble i2s1
+    ctl = mixer_get_ctl_by_name(mixer, "I2S1OUT Switch");
+    mixer_ctl_set_value(ctl, 0, 1);
+
+    //i2s3->APBIF_TXDIF0
+    ctl = mixer_get_ctl_by_name(mixer, "I2S3 Src Select");
+    mixer_ctl_set_value(ctl, 0, 2);
+    //enable i2s3
+    ctl = mixer_get_ctl_by_name(mixer, "I2S3OUT Switch");
+    mixer_ctl_set_value(ctl, 0, 1);
+    return 0;
+}
+
 
 static bool setMixerValue(struct mixer* mixer, const char* name, const char* values)
 {
@@ -114,7 +170,6 @@
                 ALOGE("unsupported mixer type %d for %s", type, name);
                 break;
         }
-
         values = strchr(values, ' ');
     }
 
@@ -140,8 +195,11 @@
 bool AudioPlayer::init(const char* config)
 {
     int tempInt;
+    memset(cards, 0, sizeof(cards));
     struct mixer* mixer = NULL;
     char    name[MAX_LINE_LENGTH];
+    AudioMap  *audiomap = new AudioMap();
+    audiomap->init_audio_map();
 
     for (;;) {
         const char* endl = strstr(config, "\n");
@@ -153,7 +211,7 @@
         }
         const char* l = line.string();
 
-        if (sscanf(l, "card=%d", &tempInt) == 1) {
+            if (sscanf(l, "card=%d", &tempInt) == 1) {
             ALOGD("card=%d", tempInt);
             mCard = tempInt;
 
@@ -185,12 +243,10 @@
     }
 
     mixer_close(mixer);
-
-    if (mCard >= 0 && mDevice >= 0) {
-        return true;
-    }
-
-    return false;
+    audiomap->reinit_card(cards, mPeriodSize, mPeriodCount);
+    delete(audiomap);
+   
+    return true;
 }
 
 void AudioPlayer::playFile(FileMap* fileMap) {
@@ -204,7 +260,6 @@
 bool AudioPlayer::threadLoop()
 {
     struct pcm_config config;
-    struct pcm *pcm = NULL;
     bool moreChunks = true;
     const struct chunk_fmt* chunkFmt = NULL;
     int bufferSize;
@@ -215,7 +270,7 @@
     if (mCurrentFile == NULL) {
         ALOGE("mCurrentFile is NULL");
         return false;
-     }
+    }
 
     wavData = (const uint8_t *)mCurrentFile->getDataPtr();
     if (!wavData) {
@@ -265,7 +320,6 @@
         goto exit;
     }
 
-
     memset(&config, 0, sizeof(config));
     config.channels = chunkFmt->num_channels;
     config.rate = chunkFmt->sample_rate;
@@ -279,35 +333,154 @@
         goto exit;
     }
     config.format = PCM_FORMAT_S16_LE;
-
-    pcm = pcm_open(mCard, mDevice, PCM_OUT, &config);
-    if (!pcm || !pcm_is_ready(pcm)) {
-        ALOGE("Unable to open PCM device (%s)\n", pcm_get_error(pcm));
-        goto exit;
+    //open ahub(output_card) mixer
+    ahub_mixer = mixer_open(output_card);
+    //set route
+    setHubRoute(ahub_mixer);
+    //open ahub
+    for(int index = 0; index < CARD_NUM; index++)
+    {
+        if(1 == cards[index].active)
+        {
+            //if 0(hdmi) 4(cvbs) is active then card[0], card[4] is active
+            cards[index].hub_pcm = pcm_open(output_card, cards[index].output_device, PCM_OUT, &config);
+            if (!cards[index].hub_pcm || !pcm_is_ready(cards[index].hub_pcm))
+            {
+                ALOGE("Unable to open PCM device (%s)\n", pcm_get_error(cards[index].hub_pcm));
+                goto exit;
+            }
+            bufferSize = pcm_frames_to_bytes(cards[index].hub_pcm, pcm_get_buffer_size(cards[index].hub_pcm));
+        }
     }
 
-    bufferSize = pcm_frames_to_bytes(pcm, pcm_get_buffer_size(pcm));
+    //open ordinay cards
+    for(int index = 0; index < CARD_NUM; index++)
+    {
+        if(1 == cards[index].active)
+        {
+            //if 0(hdmi) 4(cvbs) is active then card[0], card[4] is active
+            cards[index].pcm = pcm_open(index, mDevice, PCM_OUT, &config);
+            if (!cards[index].pcm || !pcm_is_ready(cards[index].pcm))
+            {
+                ALOGE("Unable to open PCM device (%s)\n", pcm_get_error(cards[index].pcm));
+                goto exit;
+            }
+            pcm_prepare(cards[index].pcm);
+            bufferSize = pcm_frames_to_bytes(cards[index].pcm, pcm_get_buffer_size(cards[index].pcm));
+        }
+    }
+    #if 0
+    cards[0].hub_pcm = pcm_open(0, 0, PCM_OUT, &config);
+    if(cards[0].hub_pcm == NULL)
+    else
+    cards[0].pcm = pcm_open(1, 0, PCM_OUT, &config);
+    //pcm_prepare(cards[0].pcm);
+    #endif
 
     while (wavLength > 0) {
         if (exitPending()) goto exit;
-        size_t count = bufferSize;
+        size_t count = WRITE_BUF;
         if (count > wavLength)
             count = wavLength;
 
-        if (pcm_write(pcm, wavData, count)) {
-            ALOGE("pcm_write failed (%s)", pcm_get_error(pcm));
-            goto exit;
+        /* write card */
+        for(int index = 0; index < CARD_NUM; index++)
+        {
+            if(1 == cards[index].active)
+            {
+                if(pcm_write(cards[index].hub_pcm, wavData, count))
+                {
+                    ALOGE("pcm_write failed (%s)", pcm_get_error(cards[index].hub_pcm));
+                    goto exit;
+                }
+            }
         }
         wavData += count;
         wavLength -= count;
     }
 
 exit:
-    if (pcm)
-        pcm_close(pcm);
+    /* close card */
+    for(int index = 0; index < CARD_NUM; index++)
+    {
+        if(cards[index].pcm)
+        {
+            pcm_close(cards[index].pcm);
+            cards[index].pcm = NULL;
+        }
+        if(cards[index].hub_pcm)
+        {
+            pcm_close(cards[index].hub_pcm);
+            cards[index].hub_pcm = NULL;
+        }
+    }
     delete mCurrentFile;
     mCurrentFile = NULL;
     return false;
 }
 
+
+AudioMap::AudioMap()
+{}
+AudioMap::~AudioMap()
+{}
+
+int AudioMap::init_audio_map()
+{
+    char path[PATH_LEN] = {0};
+    char name[NAME_LEN] = {0};
+    int index = 0;
+    int ret = -1;
+    int fd = -1;
+    for(; index < AUDIO_MAP_CNT; index++)
+    {
+        memset(path, 0, PATH_LEN);
+        memset(name, 0, NAME_LEN);
+        sprintf(path, "/proc/asound/card%d/id", index);
+
+        fd = open(path, O_RDONLY, 0);
+        if(fd < 0)
+        {return -1;}
+
+        ret = read(fd, name, NAME_LEN);
+        if(ret < 0)
+        {return -2;};
+
+        int innerindex = 0;
+        for(; innerindex < AUDIO_MAP_CNT; innerindex++)
+        {
+            //search for hub card num
+            if(strncmp(HUB, name, strlen(HUB)) == 0)
+            {
+                output_card = index;
+            }
+            //search for ordinary card num
+            if((strlen(audio_name_map[innerindex].name) != 0)
+                    && (strncmp(audio_name_map[innerindex].name, name, strlen(audio_name_map[innerindex].name)) == 0))
+            {
+                audio_name_map[innerindex].card_num = index;
+            }
+            else
+            {}
+        }
+        close(fd);
+    }
+    return 1;
+}
+int AudioMap::reinit_card(struct active_pcm (&cards)[32], int periodsize, int periodcount)
+{
+    int index = 0;
+    for(; index < AUDIO_MAP_CNT; index++    )
+    {
+        if(audio_name_map[index].active == 1)
+        {
+            int card_num = audio_name_map[index].card_num;
+            cards[card_num].active = 1;
+            cards[card_num].periodsize = periodsize;
+            cards[card_num].periodcount = periodcount;
+            cards[card_num].output_device= audio_name_map[index].output_device;
+        }
+    }
+    return 1;
+}
 } // namespace android
diff -ur ../aosp/frameworks/base/cmds/bootanimation/AudioPlayer.h ../Desktop/android/frameworks/base/cmds/bootanimation/AudioPlayer.h
--- ../aosp/frameworks/base/cmds/bootanimation/AudioPlayer.h	2018-08-06 15:40:21.267142957 +0200
+++ ../Desktop/android/frameworks/base/cmds/bootanimation/AudioPlayer.h	2017-11-23 05:21:11.000000000 +0100
@@ -18,8 +18,25 @@
 #define _BOOTANIMATION_AUDIOPLAYER_H
 
 #include <utils/Thread.h>
+#include <utils/SortedVector.h>
 #include <utils/FileMap.h>
-
+#include <utils/StrongPointer.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <tinyalsa/asoundlib.h>
+
+#define CARD_NUM 32
+
+
+struct active_pcm {
+    int active;
+    int periodsize;
+    int periodcount;
+    struct pcm *pcm;
+    struct pcm *hub_pcm;
+    int output_device;
+};
 namespace android {
 
 class AudioPlayer : public Thread
@@ -33,16 +50,25 @@
 
 private:
     virtual bool        threadLoop();
+	struct active_pcm   cards[CARD_NUM];
+    bool closeHubRoute(struct mixer* mixer);
 
 private:
     int                 mCard;      // ALSA card to use
     int                 mDevice;    // ALSA device to use
     int                 mPeriodSize;
     int                 mPeriodCount;
-
+    struct mixer *      ahub_mixer;
     FileMap*            mCurrentFile;
 };
-
+class AudioMap
+{
+public:
+    AudioMap();
+    ~AudioMap();
+    int init_audio_map();
+    int reinit_card(struct active_pcm (&cards)[CARD_NUM], int periodsize, int periodcount);
+};
 } // namespace android
 
 #endif // _BOOTANIMATION_AUDIOPLAYER_H
diff -ur ../aosp/frameworks/base/cmds/bootanimation/BootAnimation.cpp ../Desktop/android/frameworks/base/cmds/bootanimation/BootAnimation.cpp
--- ../aosp/frameworks/base/cmds/bootanimation/BootAnimation.cpp	2018-08-06 15:40:21.267142957 +0200
+++ ../Desktop/android/frameworks/base/cmds/bootanimation/BootAnimation.cpp	2017-11-23 05:21:11.000000000 +0100
@@ -54,14 +54,22 @@
 #include <GLES/glext.h>
 #include <EGL/eglext.h>
 
+// for setDataSource
+#include <media/IMediaHTTPService.h>
+#include <binder/IServiceManager.h>
+
 #include "BootAnimation.h"
 #include "AudioPlayer.h"
 
 #define OEM_BOOTANIMATION_FILE "/oem/media/bootanimation.zip"
+#define USER_BOOTANIMATION_FILE "/data/local/bootanimation.zip"
 #define SYSTEM_BOOTANIMATION_FILE "/system/media/bootanimation.zip"
 #define SYSTEM_ENCRYPTED_BOOTANIMATION_FILE "/system/media/bootanimation-encrypted.zip"
 #define EXIT_PROP_NAME "service.bootanim.exit"
 
+#define SYSTEM_BOOTVIDEO_FILE   "/system/media/boot.mp4"
+#define USER_BOOTVIDEO_FILE     "/data/local/boot.mp4"
+
 namespace android {
 
 static const int ANIM_ENTRY_NAME_MAX = 256;
@@ -70,6 +78,13 @@
 
 BootAnimation::BootAnimation() : Thread(false), mClockEnabled(true) {
     mSession = new SurfaceComposerClient();
+
+    mVideoPath = NULL;
+    if (access(USER_BOOTVIDEO_FILE, R_OK) == 0) {
+        mVideoPath = USER_BOOTVIDEO_FILE;
+    } else if (access(SYSTEM_BOOTVIDEO_FILE, R_OK) == 0) {
+        mVideoPath = SYSTEM_BOOTVIDEO_FILE;
+    }
 }
 
 BootAnimation::~BootAnimation() {
@@ -224,6 +239,19 @@
     return NO_ERROR;
 }
 
+static void waitServiceReady()
+{
+    char value[PROPERTY_VALUE_MAX];
+    do {
+        property_get("init.svc.media", value, "0");
+        if (!strcmp(value, "running"))
+            break;
+
+        ALOGD("media not published, waiting...");
+        usleep(100000);
+    } while (true);
+}
+
 status_t BootAnimation::readyToRun() {
     mAssets.addDefaultAssets();
 
@@ -244,6 +272,28 @@
 
     sp<Surface> s = control->getSurface();
 
+    if (mVideoPath != NULL) {
+        mFlingerSurface = s;
+        mFlingerSurfaceControl = control;
+
+        waitServiceReady();
+
+        if (startBootMedia(mVideoPath, true) == 0) {
+            do {
+                usleep(100000);
+                checkExit();
+            } while (!exitPending());
+
+            stopBootMedia();
+
+            mFlingerSurface.clear();
+            mFlingerSurfaceControl.clear();
+            IPCThreadState::self()->stopProcess();
+            return NO_ERROR;
+        }
+    }
+
+
     // initialize opengl and egl
     const EGLint attribs[] = {
             EGL_RED_SIZE,   8,
@@ -291,6 +341,9 @@
     else if (access(OEM_BOOTANIMATION_FILE, R_OK) == 0) {
         mZipFileName = OEM_BOOTANIMATION_FILE;
     }
+    else if (access(USER_BOOTANIMATION_FILE, R_OK) == 0) {
+        mZipFileName = USER_BOOTANIMATION_FILE;
+    }
     else if (access(SYSTEM_BOOTANIMATION_FILE, R_OK) == 0) {
         mZipFileName = SYSTEM_BOOTANIMATION_FILE;
     }
@@ -824,6 +877,43 @@
     mLoadedFiles.remove(fn);
     return animation;
 }
+
+int BootAnimation::startBootMedia(const char *path, bool looping)
+{
+    if (!path || *path == '\0' || access(path, R_OK))
+        return -1;
+
+    mPlayer = new MediaPlayer();
+    if (mPlayer == NULL) {
+        ALOGE("new MediaPlayer() return NULL");
+        return -1;
+    }
+
+    char url[1024];
+    snprintf(url, sizeof(url), "file://%s", path);
+    if (mPlayer->setDataSource(0, url, 0) ||
+            mPlayer->setVideoSurfaceTexture(mFlingerSurface->getIGraphicBufferProducer()) ||
+            mPlayer->setLooping(looping) ||
+            mPlayer->setVolume(1.0, 1.0) ||
+            mPlayer->prepare() ||
+            mPlayer->start()) {
+        mPlayer->reset();
+        mPlayer.clear();
+        return -1;
+    }
+
+    return 0;
+}
+
+void BootAnimation::stopBootMedia()
+{
+    if (mPlayer != NULL) {
+        mPlayer->stop();
+        mPlayer->reset();
+        mPlayer.clear();
+     }
+}
+
 // ---------------------------------------------------------------------------
 
 }
diff -ur ../aosp/frameworks/base/cmds/bootanimation/BootAnimation.h ../Desktop/android/frameworks/base/cmds/bootanimation/BootAnimation.h
--- ../aosp/frameworks/base/cmds/bootanimation/BootAnimation.h	2018-08-06 15:40:21.267142957 +0200
+++ ../Desktop/android/frameworks/base/cmds/bootanimation/BootAnimation.h	2017-11-23 05:21:11.000000000 +0100
@@ -26,6 +26,8 @@
 #include <EGL/egl.h>
 #include <GLES/gl.h>
 
+#include <media/mediaplayer.h>
+
 class SkBitmap;
 
 namespace android {
@@ -100,6 +102,10 @@
 
     void checkExit();
 
+    // add for boot video
+    int startBootMedia(const char *path, bool looping);
+    void stopBootMedia();
+
     sp<SurfaceComposerClient>       mSession;
     sp<AudioPlayer>                 mAudioPlayer;
     AssetManager mAssets;
@@ -115,6 +121,10 @@
     bool        mClockEnabled;
     String8     mZipFileName;
     SortedVector<String8> mLoadedFiles;
+
+    // add for boot video
+    sp<MediaPlayer> mPlayer;
+    const char *mVideoPath;
 };
 
 // ---------------------------------------------------------------------------
diff -ur ../aosp/frameworks/base/core/java/android/app/SystemServiceRegistry.java ../Desktop/android/frameworks/base/core/java/android/app/SystemServiceRegistry.java
--- ../aosp/frameworks/base/core/java/android/app/SystemServiceRegistry.java	2018-08-06 15:40:21.515146143 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/app/SystemServiceRegistry.java	2017-11-23 05:21:12.000000000 +0100
@@ -73,6 +73,11 @@
 import android.net.EthernetManager;
 import android.net.IConnectivityManager;
 import android.net.IEthernetManager;
+
+/* add by zhaokai for pppoe,2016.10.27 */
+import android.net.PppoeManager;
+import android.net.IPppoeManager;
+
 import android.net.INetworkPolicyManager;
 import android.net.NetworkPolicyManager;
 import android.net.NetworkScoreManager;
@@ -90,9 +95,11 @@
 import android.net.wifi.p2p.WifiP2pManager;
 import android.nfc.NfcManager;
 import android.os.BatteryManager;
+import android.os.DisplayOutputManager;
 import android.os.DropBoxManager;
 import android.os.HardwarePropertiesManager;
 import android.os.IBinder;
+import android.os.IDisplayOutputManager;
 import android.os.IHardwarePropertiesManager;
 import android.os.IPowerManager;
 import android.os.IRecoverySystem;
@@ -305,6 +312,19 @@
                 return new DisplayManager(ctx.getOuterContext());
             }});
 
+        registerService(Context.DISPLAYOUTPUT_SERVICE, DisplayOutputManager.class,
+                new CachedServiceFetcher<DisplayOutputManager>() {
+            @Override
+            public DisplayOutputManager createService(ContextImpl ctx) {
+                IBinder b = ServiceManager.getService(Context.DISPLAYOUTPUT_SERVICE);
+                IDisplayOutputManager service = IDisplayOutputManager.Stub.asInterface(b);
+                if (service == null) {
+                    Log.wtf(TAG, "Failed to get device output manager service.");
+                }
+                return new DisplayOutputManager(ctx.getOuterContext(),
+                        service);
+            }});
+
         registerService(Context.INPUT_METHOD_SERVICE, InputMethodManager.class,
                 new StaticServiceFetcher<InputMethodManager>() {
             @Override
@@ -554,6 +574,16 @@
                 IEthernetManager service = IEthernetManager.Stub.asInterface(b);
                 return new EthernetManager(ctx.getOuterContext(), service);
             }});
+       /*add by zhaokai for pppoe,2016.10.27*/
+       registerService(Context.PPPOE_SERVICE, PppoeManager.class,
+                new CachedServiceFetcher<PppoeManager>() {
+            @Override
+            public PppoeManager createService(ContextImpl ctx) {
+                IBinder b = ServiceManager.getService(Context.PPPOE_SERVICE);
+                IPppoeManager service = IPppoeManager.Stub.asInterface(b);
+                return new PppoeManager(ctx.getOuterContext(),service);
+            }});
+
 
         registerService(Context.WINDOW_SERVICE, WindowManager.class,
                 new CachedServiceFetcher<WindowManager>() {
Only in ../Desktop/android/frameworks/base/core/java/android/bluetooth: BluetoothRtkbt.java
Only in ../Desktop/android/frameworks/base/core/java/android/bluetooth: IBluetoothRtkbt.aidl
diff -ur ../aosp/frameworks/base/core/java/android/content/Context.java ../Desktop/android/frameworks/base/core/java/android/content/Context.java
--- ../aosp/frameworks/base/core/java/android/content/Context.java	2018-08-06 15:40:21.691148403 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/content/Context.java	2017-11-23 05:21:12.000000000 +0100
@@ -2698,6 +2698,7 @@
             //@hide: HDMI_CONTROL_SERVICE,
             INPUT_SERVICE,
             DISPLAY_SERVICE,
+            DISPLAYOUTPUT_SERVICE,
             USER_SERVICE,
             RESTRICTIONS_SERVICE,
             APP_OPS_SERVICE,
@@ -3177,6 +3178,20 @@
      */
     public static final String ETHERNET_SERVICE = "ethernet";
 
+     /*add by zhaokai for pppoe,2016.10.27*/
+     /**
+     * Use with {@link #getSystemService} to retrieve a {@link
+     * android.net.pppoe.PppoeManager} for handling management of
+     * Ethernet access.
+     *
+     * @see #getSystemService
+     * @see android.net.pppoe.PppoeManager
+     *
+     *@hide
+     */
+    public static final String PPPOE_SERVICE = "pppoe";
+
+
     /**
      * Use with {@link #getSystemService} to retrieve a {@link
      * android.net.nsd.NsdManager} for handling management of network service
@@ -3457,6 +3472,15 @@
 
     /**
      * Use with {@link #getSystemService} to retrieve a
+     * {@link android.os.DisplayOutputManager} for switch display devices settings.
+     *
+     * @see #getSystemService
+     * @see android.os.DisplayOutputManager
+     */
+    public static final String DISPLAYOUTPUT_SERVICE = "display_output";
+
+    /**
+     * Use with {@link #getSystemService} to retrieve a
      * {@link android.os.UserManager} for managing users on devices that support multiple users.
      *
      * @see #getSystemService
diff -ur ../aosp/frameworks/base/core/java/android/content/Intent.java ../Desktop/android/frameworks/base/core/java/android/content/Intent.java
--- ../aosp/frameworks/base/core/java/android/content/Intent.java	2018-08-06 15:40:21.695148454 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/content/Intent.java	2017-11-23 05:21:12.000000000 +0100
@@ -3250,6 +3250,9 @@
      */
     public static final int EXTRA_THERMAL_STATE_EXCEEDED = 2;
 
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String ACTION_HDMISTATUS_CHANGED = "android.intent.action.HDMISTATUS_CHANGED";
+    public final static String ACTION_HDMI_PLUGGED = "android.intent.action.HDMI_PLUGGED";
 
     // ---------------------------------------------------------------------
     // ---------------------------------------------------------------------
@@ -4632,6 +4635,14 @@
      */
     public static final int FLAG_RECEIVER_EXCLUDE_BACKGROUND = 0x00800000;
 
+     /*add by chenjd,2013-03-19,start {{---------------------------
+     * add intent for audio plug in/out
+     */
+     @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+     public static final String ACTION_AUDIO_PLUG_IN_OUT =
+          "android.intent.action.AUDIO_PLUG_IN_OUT";
+     /*add by chenjd, end ---------------------------------------}}*/
+
     /**
      * @hide Flags that can't be changed with PendingIntent.
      */
diff -ur ../aosp/frameworks/base/core/java/android/content/pm/PackageManager.java ../Desktop/android/frameworks/base/core/java/android/content/pm/PackageManager.java
--- ../aosp/frameworks/base/core/java/android/content/pm/PackageManager.java	2018-08-06 15:40:21.707148609 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/content/pm/PackageManager.java	2017-11-23 05:21:12.000000000 +0100
@@ -2155,6 +2155,15 @@
     @SdkConstant(SdkConstantType.FEATURE)
     public static final String FEATURE_ETHERNET = "android.hardware.ethernet";
 
+/**
+     * Feature for {@link #getSystemAvailableFeatures} and
+     * {@link #hasSystemFeature}: This device supports pppoe.
+     */
+    /* add by zhaokai for pppoe,2016.10.27 */
+    @SdkConstant(SdkConstantType.FEATURE)
+    public static final String FEATURE_PPPOE = "android.software.pppoe";
+
+
     /**
      * Feature for {@link #getSystemAvailableFeatures} and
      * {@link #hasSystemFeature}: This device supports HDMI-CEC.
diff -ur ../aosp/frameworks/base/core/java/android/hardware/camera2/CameraManager.java ../Desktop/android/frameworks/base/core/java/android/hardware/camera2/CameraManager.java
--- ../aosp/frameworks/base/core/java/android/hardware/camera2/CameraManager.java	2018-08-06 15:40:21.751149174 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/hardware/camera2/CameraManager.java	2017-11-23 05:21:12.000000000 +0100
@@ -650,6 +650,14 @@
      * <p>In case of errors connecting to the camera service, will return an empty list.</p>
      */
     private ArrayList<String> getOrCreateDeviceIdListLocked() throws CameraAccessException {
+
+       //add by zhengjiangwei to support Android N Camera hot plug...
+       if(mDeviceIdList  !=null)
+       {
+           mDeviceIdList  = null;
+       }
+
+
         if (mDeviceIdList == null) {
             int numCameras = 0;
             ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
Only in ../Desktop/android/frameworks/base/core/java/android/hardware/usb: UsbCameraManager.java
diff -ur ../aosp/frameworks/base/core/java/android/net/ConnectivityManager.java ../Desktop/android/frameworks/base/core/java/android/net/ConnectivityManager.java
--- ../aosp/frameworks/base/core/java/android/net/ConnectivityManager.java	2018-08-06 15:40:21.823150098 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/net/ConnectivityManager.java	2017-11-23 05:21:12.000000000 +0100
@@ -539,12 +539,14 @@
      * It may or may not be providing security services.
      */
     public static final int TYPE_VPN = 17;
-
+   /* add by zhaokai for pppoe,2016.10.27*/
+   /** {@hide} */
+    public static final int TYPE_PPPOE=18;
     /** {@hide} */
-    public static final int MAX_RADIO_TYPE   = TYPE_VPN;
+    public static final int MAX_RADIO_TYPE   = TYPE_PPPOE;
 
     /** {@hide} */
-    public static final int MAX_NETWORK_TYPE = TYPE_VPN;
+    public static final int MAX_NETWORK_TYPE = TYPE_PPPOE;
 
     /**
      * If you want to set the default network preference,you can directly
@@ -643,6 +645,8 @@
                 return "PROXY";
             case TYPE_VPN:
                 return "VPN";
+            case TYPE_PPPOE:
+                return "PPPOE";
             default:
                 return Integer.toString(type);
         }
diff -ur ../aosp/frameworks/base/core/java/android/net/IpConfiguration.java ../Desktop/android/frameworks/base/core/java/android/net/IpConfiguration.java
--- ../aosp/frameworks/base/core/java/android/net/IpConfiguration.java	2018-08-06 15:40:21.831150201 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/net/IpConfiguration.java	2017-11-23 05:21:12.000000000 +0100
@@ -35,6 +35,8 @@
         STATIC,
         /* Use dynamically configured IP settigns */
         DHCP,
+        /* use for pppoe */
+        PPPOE,
         /* no IP details are assigned, this is used to indicate
          * that any existing IP settings should be retained */
         UNASSIGNED
Only in ../Desktop/android/frameworks/base/core/java/android/net: IPppoeManager.aidl
diff -ur ../aosp/frameworks/base/core/java/android/net/NetworkCapabilities.java ../Desktop/android/frameworks/base/core/java/android/net/NetworkCapabilities.java
--- ../aosp/frameworks/base/core/java/android/net/NetworkCapabilities.java	2018-08-06 15:40:21.835150251 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/net/NetworkCapabilities.java	2017-11-23 05:21:12.000000000 +0100
@@ -404,9 +404,10 @@
      * Indicates this network uses a VPN transport.
      */
     public static final int TRANSPORT_VPN = 4;
+    public static final int TRANSPORT_PPPOE = 5;
 
     private static final int MIN_TRANSPORT = TRANSPORT_CELLULAR;
-    private static final int MAX_TRANSPORT = TRANSPORT_VPN;
+    private static final int MAX_TRANSPORT = TRANSPORT_PPPOE;
 
     /**
      * Adds the given transport type to this {@code NetworkCapability} instance.
@@ -862,6 +863,7 @@
                 case TRANSPORT_BLUETOOTH:   transports += "BLUETOOTH"; break;
                 case TRANSPORT_ETHERNET:    transports += "ETHERNET"; break;
                 case TRANSPORT_VPN:         transports += "VPN"; break;
+                case TRANSPORT_PPPOE:       transports += "PPPOE"; break;
             }
             if (++i < types.length) transports += "|";
         }
Only in ../Desktop/android/frameworks/base/core/java/android/net: PppoeManager.java
Only in ../Desktop/android/frameworks/base/core/java/android/os: DisplayOutputManager.java
Only in ../Desktop/android/frameworks/base/core/java/android/os: IDisplayOutputManager.aidl
diff -ur ../aosp/frameworks/base/core/java/android/os/Process.java ../Desktop/android/frameworks/base/core/java/android/os/Process.java
--- ../aosp/frameworks/base/core/java/android/os/Process.java	2018-08-06 15:40:21.887150920 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/os/Process.java	2017-11-23 05:21:12.000000000 +0100
@@ -1130,7 +1130,11 @@
      * other's processes.
      */
     public static final void killProcess(int pid) {
-        sendSignal(pid, SIGNAL_KILL);
+	if(getUidForPid(pid)!=SYSTEM_UID){
+        	sendSignal(pid, SIGNAL_KILL);
+	}else{
+		Log.e(LOG_TAG,"We are sending kill signal to system pid = " + pid);
+	}
     }
 
     /** @hide */
@@ -1154,7 +1158,11 @@
      * beat you up.
      */
     public static final void killProcessQuiet(int pid) {
-        sendSignalQuiet(pid, SIGNAL_KILL);
+	 if(getUidForPid(pid)!=SYSTEM_UID){
+        	sendSignalQuiet(pid, SIGNAL_KILL);
+	 }else{
+		Log.e(LOG_TAG,"We are sending kill signal to system pid = " + pid);
+	 }
     }
 
     /**
diff -ur ../aosp/frameworks/base/core/java/android/os/RecoverySystem.java ../Desktop/android/frameworks/base/core/java/android/os/RecoverySystem.java
--- ../aosp/frameworks/base/core/java/android/os/RecoverySystem.java	2018-08-06 15:40:21.895151022 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/os/RecoverySystem.java	2017-11-23 05:21:12.000000000 +0100
@@ -72,6 +72,7 @@
 
     /** Used to communicate with recovery.  See bootable/recovery/recovery.cpp. */
     private static final File RECOVERY_DIR = new File("/cache/recovery");
+    private static File COMMAND_FILE = new File(RECOVERY_DIR, "command");
     private static final File LOG_FILE = new File(RECOVERY_DIR, "log");
     private static final File LAST_INSTALL_FILE = new File(RECOVERY_DIR, "last_install");
     private static final String LAST_PREFIX = "last_";
@@ -473,6 +474,10 @@
                 // file as the package name instead.
                 filename = "@/cache/recovery/block.map";
             }
+            String storage="/storage/emulated/";
+            if (filename.startsWith("/storage/emulated/"))
+		filename="/data/media/"+filename.substring(storage.length());
+	    Log.w(TAG, "!!! REBOOTING TO INSTALL " + filename + " !!!");
 
             final String filenameArg = "--update_package=" + filename + "\n";
             final String localeArg = "--locale=" + Locale.getDefault().toString() + "\n";
@@ -483,12 +488,12 @@
                 command += securityArg;
             }
 
-            RecoverySystem rs = (RecoverySystem) context.getSystemService(
+            /*RecoverySystem rs = (RecoverySystem) context.getSystemService(
                     Context.RECOVERY_SERVICE);
             if (!rs.setupBcb(command)) {
                 throw new IOException("Setup BCB failed");
-            }
-
+            }*/
+						bootCommand_leagcy(context,command);
             // Having set up the BCB (bootloader control block), go ahead and reboot
             PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
             pm.reboot(PowerManager.REBOOT_RECOVERY_UPDATE);
@@ -687,6 +692,36 @@
         }
     }
 
+    private static void bootCommand_leagcy(Context context, String... args) throws IOException {
+        RECOVERY_DIR.mkdirs();  // In case we need it
+        COMMAND_FILE.delete();  // In case it's not writable
+        LOG_FILE.delete();
+
+        FileWriter command = new FileWriter(COMMAND_FILE);
+        try {
+            for (String arg : args) {
+                if (!TextUtils.isEmpty(arg)) {
+                    command.write(arg);
+                    command.write("\n");
+                }
+            }
+        } finally {
+            command.flush();
+            command.close();
+        }
+        try {
+            Runtime runTime = Runtime.getRuntime();
+            java.lang.Process proc = runTime.exec("sync");
+            proc.waitFor();
+        } catch  (Exception e) {
+            e.printStackTrace();
+        }
+        // Having written the command file, go ahead and reboot
+        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+        pm.reboot(PowerManager.REBOOT_RECOVERY);
+
+        throw new IOException("Reboot failed (no permissions?)");
+    }
     // Read last_install; then report time (in seconds) and I/O (in MiB) for
     // this update to tron.
     // Only report on the reboots immediately after an OTA update.
diff -ur ../aosp/frameworks/base/core/java/android/provider/Settings.java ../Desktop/android/frameworks/base/core/java/android/provider/Settings.java
--- ../aosp/frameworks/base/core/java/android/provider/Settings.java	2018-08-06 15:40:21.959151844 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/provider/Settings.java	2017-11-23 05:21:12.000000000 +0100
@@ -80,6 +80,16 @@
  */
 public final class Settings {
 
+      /**
+        * Ethernet related stored configurations
+        * @hide
+        */
+      public static final String ETHERNET_MODE             = "eth_mode";
+      /**
+        * parameter related to pppoe enable.
+        * @hide
+        */
+      public static final String PPPOE_ENABLED             = "pppoe_enabled";
     // Intent actions for Settings
 
     /**
@@ -1775,6 +1785,23 @@
             MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_PING_COUNT);
             MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_PING_DELAY_MS);
             MOVED_TO_SECURE.add(Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS);
+			MOVED_TO_SECURE.add(Secure.HOME_PAGE);   //cmcc by fuqiang, start
+            MOVED_TO_SECURE.add(Secure.UPGRADE_URL);
+            MOVED_TO_SECURE.add(Secure.UPGRADE_PATH);
+            MOVED_TO_SECURE.add(Secure.NTVUSERACCOUNT);
+            MOVED_TO_SECURE.add(Secure.NTVUSERSUFFIX);
+            MOVED_TO_SECURE.add(Secure.NTVUSERPASSWORD);
+            MOVED_TO_SECURE.add(Secure.NTP_SERVER);
+			MOVED_TO_SECURE.add(Secure.NTP_SERVER2);
+			MOVED_TO_SECURE.add(Secure.DHCP_USER);
+			MOVED_TO_SECURE.add(Secure.DHCP_PSWD);
+			MOVED_TO_SECURE.add(Secure.DHCP_OPTION);
+			MOVED_TO_SECURE.add(Secure.DHCP_IPVER);
+			MOVED_TO_SECURE.add(Secure.PPPOE_USERNAME);
+			MOVED_TO_SECURE.add(Secure.PPPOE_PSWD);
+            MOVED_TO_SECURE.add(Secure.DEFAULT_SCREEN_RATIO);
+            MOVED_TO_SECURE.add(Secure.DEFAULT_PLAYER_QUALITY);
+			MOVED_TO_SECURE.add(Secure.SQM_START_MODE);//cmcc by fuqiang, end
 
             // At one time in System, then Global, but now back in Secure
             MOVED_TO_SECURE.add(Secure.INSTALL_NON_MARKET_APPS);
@@ -1794,7 +1821,8 @@
             MOVED_TO_SECURE_THEN_GLOBAL.add(Global.DEVICE_PROVISIONED);
             MOVED_TO_SECURE_THEN_GLOBAL.add(Global.USB_MASS_STORAGE_ENABLED);
             MOVED_TO_SECURE_THEN_GLOBAL.add(Global.HTTP_PROXY);
-
+            MOVED_TO_GLOBAL.add(Settings.Global.ETHERNET_MODE); //add by zhaokai ,2016.11.11
+            MOVED_TO_GLOBAL.add(Settings.Global.PPPOE_ENABLED); //add by zhaokai,2016.12.06
             // these are moving directly from system to global
             MOVED_TO_GLOBAL.add(Settings.Global.AIRPLANE_MODE_ON);
             MOVED_TO_GLOBAL.add(Settings.Global.AIRPLANE_MODE_RADIOS);
@@ -2382,6 +2410,19 @@
             }
         }
 
+			/**
+			 * Description:record the audio output channel<br/>
+			 * @hide
+			 */
+			public static final String AUDIO_OUTPUT_CHANNEL = "audio_output_channel";
+			/**
+			 * Description:record the audio output policy<br/>
+			 * @hide
+			 */
+			public static final String AUDIO_MANAGE_POLICY = "audio_manage_policy";
+			/**@hide*/
+			public static final String ENABLE_PASS_THROUGH = "enable_pass_through";
+
         /**
          * @deprecated Use {@link android.provider.Settings.Global#STAY_ON_WHILE_PLUGGED_IN} instead
          */
@@ -3541,7 +3582,7 @@
                 }
             }
         };
-
+        public static final String MOUSE_ADVANCE = "mouse_advance";
         /**
          * IMPORTANT: If you add a new public settings you also have to add it to
          * PUBLIC_SETTINGS below. If the new setting is hidden you have to add
@@ -3601,9 +3642,15 @@
             POINTER_SPEED,
             VIBRATE_WHEN_RINGING,
             RINGTONE,
+            MOUSE_ADVANCE,
             LOCK_TO_APP_ENABLED,
             NOTIFICATION_SOUND,
-            ACCELEROMETER_ROTATION
+            ACCELEROMETER_ROTATION,
+            /* AW Code Begin */
+            AUDIO_OUTPUT_CHANNEL,
+            AUDIO_MANAGE_POLICY,
+            ENABLE_PASS_THROUGH,
+            /* AW Code End */
         };
 
         /**
@@ -6115,6 +6162,27 @@
          */
         public static final String SLEEP_TIMEOUT = "sleep_timeout";
 
+		//cmcc by fuqiang, start
+        public static final String HOME_PAGE = "home_page";
+        public static final String UPGRADE_URL = "upgrade_url";
+        public static final String UPGRADE_PATH = "upgrade_path";
+        public static final String NTVUSERACCOUNT = "ntvuseraccount";
+        public static final String NTVUSERSUFFIX = "ntvusersuffix";
+        public static final String NTVUSERPASSWORD = "ntvuserpassword";
+        public static final String NTP_SERVER = "ntp_server";
+		public static final String NTP_SERVER2 = "ntp_server2";
+        public static final String DEFAULT_SCREEN_RATIO = "default_screen_ratio";
+        public static final String DEFAULT_PLAYER_QUALITY = "default_player_quality";
+        public static final String DISPLAY_AREA = "display_area";
+		public static final String DHCP_USER = "dhcp_user";
+		public static final String DHCP_PSWD = "dhcp_pswd";
+		public static final String DHCP_OPTION = "dhcp_option";
+		public static final String DHCP_IPVER = "dhcp_ipver";
+		public static final String PPPOE_USERNAME = "pppoe_username";
+		public static final String PPPOE_PSWD = "pppoe_pswd";
+		public static final String SQM_START_MODE = "sqm_start_mode";
+		//cmcc by fuqiang, end
+
         /**
          * Controls whether double tap to wake is enabled.
          * @hide
@@ -6526,6 +6594,12 @@
          * The content:// style URL for global secure settings items.  Not public.
          */
         public static final Uri CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/global");
+        /**
+        * Ethernet related stored configurations
+        * @hide
+        */
+        public static final String ETHERNET_MODE             = "eth_mode";
+        public static final String PPPOE_ENABLED             = "pppoe_enabled";
 
         /**
          * Whether users are allowed to add more users or guest from lockscreen.
diff -ur ../aosp/frameworks/base/core/java/android/view/IWindowManager.aidl ../Desktop/android/frameworks/base/core/java/android/view/IWindowManager.aidl
--- ../aosp/frameworks/base/core/java/android/view/IWindowManager.aidl	2018-08-06 15:40:22.123153952 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/view/IWindowManager.aidl	2017-11-23 05:21:12.000000000 +0100
@@ -421,4 +421,19 @@
      * Remove the input consumer for wallpaper events.
      */
     void removeWallpaperInputConsumer();
+
+    /**
+     * Sets the current touch exploration state.
+     *
+     * @param enabled Whether touch exploration is enabled.
+     */
+    void keyEnterMouseMode();
+
+    void keyExitMouseMode();
+
+    void keySetMouseMoveCode(int left,int right,int top,int bottom);
+
+    void keySetMouseBtnCode(int leftbtn,int midbtn,int rightbtn);
+
+    void keySetMouseDistance(int distance);
 }
diff -ur ../aosp/frameworks/base/core/java/android/view/KeyEvent.java ../Desktop/android/frameworks/base/core/java/android/view/KeyEvent.java
--- ../aosp/frameworks/base/core/java/android/view/KeyEvent.java	2018-08-06 15:40:22.123153952 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/view/KeyEvent.java	2017-11-23 05:21:12.000000000 +0100
@@ -749,6 +749,19 @@
     public static final int KEYCODE_HELP = 259;
     /** Key code constant: Navigate to previous key.
      * Goes backward by one item in an ordered collection of items. */
+
+    // NOTE: If you add a new keycode here you must also add it to:
+    //  isSystem()
+    //  isWakeKey()
+    //  frameworks/native/include/android/keycodes.h
+    //  frameworks/native/include/input/InputEventLabels.h
+    //  frameworks/base/core/res/res/values/attrs.xml
+    //  emulator?
+    //  LAST_KEYCODE
+
+    /* add by Gary. start {{----------------------------------- */
+    //add for karaok by linjunqian
+
     public static final int KEYCODE_NAVIGATE_PREVIOUS = 260;
     /** Key code constant: Navigate to next key.
      * Advances to the next item in an ordered collection of items. */
@@ -796,6 +809,31 @@
     public static final int KEYCODE_COPY = 278;
     /** Key code constant: Paste key. */
     public static final int KEYCODE_PASTE = 279;
+    /** Key code constant: a shortcut key for mouse */
+    public static final int KEYCODE_MOUSE           = 10009;
+    public static final int KEYCODE_TV_SYSTEM       = 10000;
+    /** Key code constant: a shortcut key for a time dialog */
+    public static final int KEYCODE_GOTO            = 10001;
+    /** Key code constant: a shortcut key for switching subtitles */
+    public static final int KEYCODE_SUBTITLE        = 10002;
+    /** Key code constant: a shortcut key for switching tracks */
+    public static final int KEYCODE_AUDIO           = 10003;
+    /** Key code constant: a shortcut key for zooming video */
+    public static final int KEYCODE_ZOOM            = 10004;
+    /** Key code constant: a shortcut key for favourite */
+    public static final int KEYCODE_FAVOURITE       = 10006;
+    /** Key code constant: a shortcut key for loop */
+    public static final int KEYCODE_LOOP            = 10007;
+    /** Key code constant: a shortcut key for showing or hiding statusbar's expanded view */
+    public static final int KEYCODE_EXPAND          = 10008;
+    /** Key code constant: a shortcut key for movie */
+    public static final int KEYCODE_MOVIE           = 10010;
+    /** Key code constant: a shortcut key for app list */
+    public static final int KEYCODE_APPS            = 10011;
+    /** Key code constant: a shortcut key for the browser app */
+    public static final int KEYCODE_BROWSER         = 10012;
+    /** Key code constant: a shortcut key for the screenshot */
+    public static final int KEYCODE_SCREENSHOT      = 10013;
 
     private static final int LAST_KEYCODE = KEYCODE_PASTE;
 
diff -ur ../aosp/frameworks/base/core/java/android/view/TextureView.java ../Desktop/android/frameworks/base/core/java/android/view/TextureView.java
--- ../aosp/frameworks/base/core/java/android/view/TextureView.java	2018-08-06 15:40:22.135154106 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/view/TextureView.java	2017-11-23 05:21:12.000000000 +0100
@@ -516,7 +516,7 @@
      * of the associated surface texture. If the surface texture is not available,
      * this method returns null.</p>
      *
-     * <p>The bitmap returned by this method uses the {@link Bitmap.Config#ARGB_8888}
+     * <p>The bitmap returned by this method uses the {@link android.graphics.Bitmap.Config#ARGB_8888}
      * pixel format and its dimensions are the same as this view's.</p>
      *
      * <p><strong>Do not</strong> invoke this method from a drawing method
@@ -524,7 +524,7 @@
      *
      * <p>If an error occurs during the copy, an empty bitmap will be returned.</p>
      *
-     * @return A valid {@link Bitmap.Config#ARGB_8888} bitmap, or null if the surface
+     * @return A valid {@link android.graphics.Bitmap.Config#ARGB_8888} bitmap, or null if the surface
      *         texture is not available or the width &lt;= 0 or the height &lt;= 0
      *
      * @see #isAvailable()
@@ -540,7 +540,7 @@
      * of the associated surface texture. If the surface texture is not available,
      * this method returns null.</p>
      *
-     * <p>The bitmap returned by this method uses the {@link Bitmap.Config#ARGB_8888}
+     * <p>The bitmap returned by this method uses the {@link android.graphics.Bitmap.Config#ARGB_8888}
      * pixel format.</p>
      *
      * <p><strong>Do not</strong> invoke this method from a drawing method
@@ -551,7 +551,7 @@
      * @param width The width of the bitmap to create
      * @param height The height of the bitmap to create
      *
-     * @return A valid {@link Bitmap.Config#ARGB_8888} bitmap, or null if the surface
+     * @return A valid {@link android.graphics.Bitmap.Config#ARGB_8888} bitmap, or null if the surface
      *         texture is not available or width is &lt;= 0 or height is &lt;= 0
      *
      * @see #isAvailable()
diff -ur ../aosp/frameworks/base/core/java/android/view/ViewGroup.java ../Desktop/android/frameworks/base/core/java/android/view/ViewGroup.java
--- ../aosp/frameworks/base/core/java/android/view/ViewGroup.java	2018-08-06 15:40:22.155154362 +0200
+++ ../Desktop/android/frameworks/base/core/java/android/view/ViewGroup.java	2017-11-23 05:21:12.000000000 +0100
@@ -1120,6 +1120,7 @@
      * @param touchscreenBlocksFocus true to enable blocking focus in the presence of a touchscreen
      */
     public void setTouchscreenBlocksFocus(boolean touchscreenBlocksFocus) {
+        touchscreenBlocksFocus = false;
         if (touchscreenBlocksFocus) {
             mGroupFlags |= FLAG_TOUCHSCREEN_BLOCKS_FOCUS;
             if (hasFocus()) {
diff -ur ../aosp/frameworks/base/core/java/com/android/internal/app/LocaleStore.java ../Desktop/android/frameworks/base/core/java/com/android/internal/app/LocaleStore.java
--- ../aosp/frameworks/base/core/java/com/android/internal/app/LocaleStore.java	2018-08-06 15:40:22.275155902 +0200
+++ ../Desktop/android/frameworks/base/core/java/com/android/internal/app/LocaleStore.java	2017-11-23 05:21:12.000000000 +0100
@@ -247,7 +247,7 @@
     }
 
     public static void fillCache(Context context) {
-        if (sFullyInitialized) {
+        if (false) {
             return;
         }
 
diff -ur ../aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java ../Desktop/android/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java
--- ../aosp/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java	2018-08-06 15:40:22.307156314 +0200
+++ ../Desktop/android/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java	2017-11-23 05:21:13.000000000 +0100
@@ -212,6 +212,37 @@
         Log.d(TAG, "end preload");
     }
 
+    static void preloadOptBeforeSystemServer() {
+        Log.d(TAG, "begin preload");
+        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "BeginIcuCachePinning");
+        beginIcuCachePinning();
+        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
+        Log.d(TAG, "preload opengl");
+        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadOpenGL");
+        preloadOpenGL();
+        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
+        Log.d(TAG, "preload sharedlibraries");
+        preloadSharedLibraries();
+        Log.d(TAG, "preload preloadTextResources");
+        preloadTextResources();
+        // Ask the WebViewFactory to do any initialization that must run in the zygote process,
+        // for memory sharing purposes.
+        Log.d(TAG, "prepareWebViewInZygote");
+        WebViewFactory.prepareWebViewInZygote();
+        endIcuCachePinning();
+        warmUpJcaProviders();
+        Log.d(TAG, "end preload");
+    }
+
+    static void preloadOptAfterSystemServer() {
+        Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadClasses");
+        preloadClasses();
+        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
+         Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadResources");
+        preloadResources();
+        Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
+    }
+
     private static void beginIcuCachePinning() {
         // Pin ICU data in memory from this point that would normally be held by soft references.
         // Without this, any references created immediately below or during class preloading
@@ -684,6 +715,7 @@
         }
         return result;
     }
+    static int preloadOpt = 0;
 
     public static void main(String argv[]) {
         // Mark zygote start. This ensures that thread creation will throw
@@ -716,10 +748,21 @@
             }
 
             registerZygoteSocket(socketName);
+            preloadOpt = SystemProperties.getInt("persist.sys.bootopt.preload", 0);
+            int firstRun =  SystemProperties.getInt("persist.sys.bootopt.notfirstrun",0);
             Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "ZygotePreload");
             EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,
                 SystemClock.uptimeMillis());
-            preload();
+
+            if (firstRun != 1) {
+                preloadOpt = 0;
+            }
+            if (preloadOpt>0) {
+                preloadOptBeforeSystemServer();
+            } else {
+                preload();
+            }
+
             EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,
                 SystemClock.uptimeMillis());
             Trace.traceEnd(Trace.TRACE_TAG_DALVIK);
@@ -747,6 +790,13 @@
                 startSystemServer(abiList, socketName);
             }
 
+            if (preloadOpt>0) {
+                preloadOptAfterSystemServer();
+            }
+            if (firstRun==0) {
+                SystemProperties.set("persist.sys.bootopt.notfirstrun","1");
+            }
+
             Log.i(TAG, "Accepting command socket connections");
             runSelectLoop(abiList);
 
diff -ur ../aosp/frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java ../Desktop/android/frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java
--- ../aosp/frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java	2018-08-06 15:40:22.307156314 +0200
+++ ../Desktop/android/frameworks/base/core/java/com/android/internal/policy/PhoneWindow.java	2017-11-23 05:21:13.000000000 +0100
@@ -846,6 +846,10 @@
             }
         }
 
+        if(!st.hasPanelItems()){
+            Log.e(TAG,"PanelFeatureState does not have Panel Items, so donot add AtchDlg");
+            return;
+        }
         st.isHandled = false;
 
         WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
diff -ur ../aosp/frameworks/base/core/jni/Android.mk ../Desktop/android/frameworks/base/core/jni/Android.mk
--- ../aosp/frameworks/base/core/jni/Android.mk	2018-08-06 15:40:22.371157136 +0200
+++ ../Desktop/android/frameworks/base/core/jni/Android.mk	2017-11-23 05:21:13.000000000 +0100
@@ -89,7 +89,7 @@
     android_os_Trace.cpp \
     android_os_UEventObserver.cpp \
     android_net_LocalSocketImpl.cpp \
-    android_net_NetUtils.cpp \
+    android_net_NetUtils.cpp  \
     android_net_TrafficStats.cpp \
     android_nio_utils.cpp \
     android_util_AssetManager.cpp \
Only in ../Desktop/android/frameworks/base/core/res/res/drawable: key_mouse.png
Only in ../Desktop/android/frameworks/base/core/res/res/values: config_custom.xml
diff -ur ../aosp/frameworks/base/core/res/res/values/config.xml ../Desktop/android/frameworks/base/core/res/res/values/config.xml
--- ../aosp/frameworks/base/core/res/res/values/config.xml	2018-08-06 15:40:23.559172390 +0200
+++ ../Desktop/android/frameworks/base/core/res/res/values/config.xml	2017-11-23 05:21:15.000000000 +0100
@@ -255,6 +255,17 @@
         <item>15</item>
     </integer-array>
 
+    <!-- Array of integer pairs controlling the rate at which the master volume changes
+         in response to volume up and down key events.
+         The first integer of each pair is compared against the current master volume
+         (in range 0 to 100).
+         The last pair with first integer <= the current volume is chosen,
+         and the second integer of the pair indicates the amount to increase the master volume
+         when volume up is pressed. -->
+    <integer-array name="config_masterVolumeRamp">
+        <item>0</item>  <item>5</item>  <!-- default: always increase volume by 5% -->
+    </integer-array>
+
     <!-- This string array should be overridden by the device to present a list of radio
          attributes.  This is used by the connectivity manager to decide which networks can coexist
          based on the hardware -->
@@ -381,6 +392,7 @@
         <item>5</item>
         <item>7</item>
         <item>9</item>
+        <item>18</item>
     </integer-array>
 
     <!-- If the DUN connection for this CDMA device supports more than just DUN -->
Only in ../Desktop/android/frameworks/base/core/res/res/values: display_configs.xml
Only in ../Desktop/android/frameworks/base/core/res/res/values: public_custom.xml
Only in ../Desktop/android/frameworks/base/core/res/res/values: strings_custom.xml
Only in ../Desktop/android/frameworks/base/core/res/res/values: symbols_custom.xml
diff -ur ../aosp/frameworks/base/core/res/res/values/symbols.xml ../Desktop/android/frameworks/base/core/res/res/values/symbols.xml
--- ../aosp/frameworks/base/core/res/res/values/symbols.xml	2018-08-06 15:40:23.567172494 +0200
+++ ../Desktop/android/frameworks/base/core/res/res/values/symbols.xml	2017-11-23 05:21:15.000000000 +0100
@@ -400,6 +400,7 @@
   <java-symbol type="integer" name="config_safe_media_volume_index" />
   <java-symbol type="integer" name="config_mobile_mtu" />
   <java-symbol type="array"   name="config_mobile_tcp_buffers" />
+  <java-symbol type="array" name="config_masterVolumeRamp" />
   <java-symbol type="integer" name="config_volte_replacement_rat"/>
   <java-symbol type="integer" name="config_valid_wappush_index" />
   <java-symbol type="integer" name="config_overrideHasPermanentMenuKey" />
Only in ../Desktop/android/frameworks/base/core/res/res/values-zh-rCN: strings_custom.xml
diff -ur ../aosp/frameworks/base/graphics/java/android/graphics/pdf/PdfRenderer.java ../Desktop/android/frameworks/base/graphics/java/android/graphics/pdf/PdfRenderer.java
--- ../aosp/frameworks/base/graphics/java/android/graphics/pdf/PdfRenderer.java	2018-08-06 15:40:47.351477877 +0200
+++ ../Desktop/android/frameworks/base/graphics/java/android/graphics/pdf/PdfRenderer.java	2017-11-23 05:21:34.000000000 +0100
@@ -333,7 +333,7 @@
          * </p>
          * <p>
          * <strong>Note: </strong> The destination bitmap format must be
-         * {@link Config#ARGB_8888 ARGB}.
+         * {@link android.graphics.Bitmap.Config#ARGB_8888 ARGB}.
          * </p>
          * <p>
          * <strong>Note: </strong> The optional transformation matrix must be affine as per
diff -ur ../aosp/frameworks/base/libs/input/PointerController.cpp ../Desktop/android/frameworks/base/libs/input/PointerController.cpp
--- ../aosp/frameworks/base/libs/input/PointerController.cpp	2018-08-06 15:40:47.511479932 +0200
+++ ../Desktop/android/frameworks/base/libs/input/PointerController.cpp	2017-11-23 05:21:34.000000000 +0100
@@ -23,6 +23,7 @@
 
 #include "PointerController.h"
 
+#include <utils/CallStack.h>
 #include <cutils/log.h>
 
 #pragma GCC diagnostic push
@@ -64,7 +65,7 @@
     } else {
         ALOGE("Failed to initialize DisplayEventReceiver.");
     }
-
+    unfadeset = 0;
     AutoMutex _l(mLock);
 
     mLocked.animationPending = false;
@@ -233,6 +234,7 @@
 
     // Always reset the inactivity timer.
     resetInactivityTimeoutLocked();
+    unfadeset = 1;
 
     // Start unfading.
     if (transition == TRANSITION_IMMEDIATE) {
@@ -243,6 +245,7 @@
         mLocked.pointerFadeDirection = 1;
         startAnimationLocked();
     }
+    unfadeset = 0;
 }
 
 void PointerController::setPresentation(Presentation presentation) {
@@ -600,7 +603,9 @@
 
     if (mLocked.pointerAlpha > 0) {
         mLocked.pointerSprite->setAlpha(mLocked.pointerAlpha);
-        mLocked.pointerSprite->setVisible(true);
+        if(unfadeset>0) {
+            mLocked.pointerSprite->setVisible(true);
+        }
     } else {
         mLocked.pointerSprite->setVisible(false);
     }
diff -ur ../aosp/frameworks/base/libs/input/PointerController.h ../Desktop/android/frameworks/base/libs/input/PointerController.h
--- ../aosp/frameworks/base/libs/input/PointerController.h	2018-08-06 15:40:47.511479932 +0200
+++ ../Desktop/android/frameworks/base/libs/input/PointerController.h	2017-11-23 05:21:34.000000000 +0100
@@ -148,6 +148,7 @@
     DisplayEventReceiver mDisplayEventReceiver;
 
     PointerResources mResources;
+    int unfadeset;
 
     struct Locked {
         bool animationPending;
diff -ur ../aosp/frameworks/base/media/java/android/media/AudioManagerInternal.java ../Desktop/android/frameworks/base/media/java/android/media/AudioManagerInternal.java
--- ../aosp/frameworks/base/media/java/android/media/AudioManagerInternal.java	2018-08-06 15:40:47.539480291 +0200
+++ ../Desktop/android/frameworks/base/media/java/android/media/AudioManagerInternal.java	2017-11-23 05:21:35.000000000 +0100
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 package android.media;
-
+import android.os.IBinder;
 import com.android.server.LocalServices;
 
 /**
@@ -35,6 +35,12 @@
     public abstract void setStreamVolumeForUid(int streamType, int direction, int flags,
             String callingPackage, int uid);
 
+    public abstract void adjustMasterVolumeForUid(int steps, int flags, String callingPackage,
+            int uid);
+
+    public abstract void setMasterMuteForUid(boolean state, int flags, String callingPackage,
+            int userId, int uid);
+
     public abstract void setRingerModeDelegate(RingerModeDelegate delegate);
 
     public abstract int getRingerModeInternal();
diff -ur ../aosp/frameworks/base/media/java/android/media/AudioManager.java ../Desktop/android/frameworks/base/media/java/android/media/AudioManager.java
--- ../aosp/frameworks/base/media/java/android/media/AudioManager.java	2018-08-06 15:40:47.539480291 +0200
+++ ../Desktop/android/frameworks/base/media/java/android/media/AudioManager.java	2017-11-23 05:21:35.000000000 +0100
@@ -42,6 +42,8 @@
 import android.os.SystemClock;
 import android.os.ServiceManager;
 import android.os.UserHandle;
+import android.os.SystemProperties;
+
 import android.provider.Settings;
 import android.util.ArrayMap;
 import android.util.Log;
@@ -168,6 +170,18 @@
         "android.media.STREAM_MUTE_CHANGED_ACTION";
 
     /**
+     * @hide Broadcast intent when the master volume changes.
+     * Includes the new volume
+     *
+     * @see #EXTRA_MASTER_VOLUME_VALUE
+     * @see #EXTRA_PREV_MASTER_VOLUME_VALUE
+     */
+    @SdkConstant(SdkConstantType.BROADCAST_INTENT_ACTION)
+    public static final String MASTER_VOLUME_CHANGED_ACTION =
+        "android.media.MASTER_VOLUME_CHANGED_ACTION";
+
+
+    /**
      * @hide Broadcast intent when the master mute state changes.
      * Includes the the new volume
      *
@@ -218,6 +232,23 @@
             "android.media.EXTRA_VOLUME_STREAM_TYPE_ALIAS";
 
     /**
+     * @hide The previous master volume value for the master volume changed intent.
+     * Value is integer between 0 and 100 inclusive.
+     */
+    public static final String EXTRA_PREV_MASTER_VOLUME_VALUE =
+        "android.media.EXTRA_PREV_MASTER_VOLUME_VALUE";
+
+
+    /**
+     * @hide The new master volume value for the master volume changed intent.
+     * Value is integer between 0 and 100 inclusive.
+     */
+    public static final String EXTRA_MASTER_VOLUME_VALUE =
+        "android.media.EXTRA_MASTER_VOLUME_VALUE";
+
+
+
+    /**
      * @hide The volume associated with the stream for the volume changed intent.
      */
     public static final String EXTRA_VOLUME_STREAM_VALUE =
@@ -635,6 +666,13 @@
                 com.android.internal.R.bool.config_useFixedVolume);
     }
 
+	private boolean isUseMasterVolume(){
+		if(SystemProperties.getBoolean("media.stagefright.mode", false) == true)
+			return false;
+		else
+			return true;
+	}
+
     private Context getContext() {
         if (mApplicationContext == null) {
             setContext(mOriginalContext);
@@ -708,8 +746,12 @@
              * The user has hit another key during the delay (e.g., 300ms)
              * since the last volume key up, so cancel any sounds.
              */
-            adjustSuggestedStreamVolume(ADJUST_SAME,
-                    stream, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
+
+            if (isUseMasterVolume()) {
+                adjustMasterVolume(ADJUST_SAME, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
+            } else {
+                adjustSuggestedStreamVolume(ADJUST_SAME,stream, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
+		    }
         }
     }
 
@@ -725,12 +767,20 @@
                  * Adjust the volume in on key down since it is more
                  * responsive to the user.
                  */
+            if (isUseMasterVolume()) {
+                adjustMasterVolume(
+						keyCode == KeyEvent.KEYCODE_VOLUME_UP
+                                ? ADJUST_RAISE
+                                : ADJUST_LOWER,
+                        FLAG_SHOW_UI | FLAG_VIBRATE);
+            }else{
                 adjustSuggestedStreamVolume(
                         keyCode == KeyEvent.KEYCODE_VOLUME_UP
                                 ? ADJUST_RAISE
                                 : ADJUST_LOWER,
                         stream,
                         FLAG_SHOW_UI | FLAG_VIBRATE);
+            }
                 break;
             case KeyEvent.KEYCODE_VOLUME_MUTE:
                 if (event.getRepeatCount() == 0) {
@@ -754,10 +804,14 @@
                  * sound to play when a user holds down volume down to mute.
                  */
                 if (mUseVolumeKeySounds) {
-                    adjustSuggestedStreamVolume(
+					if (isUseMasterVolume()) {
+                        adjustMasterVolume(ADJUST_SAME, FLAG_PLAY_SOUND);
+                    } else {
+                        adjustSuggestedStreamVolume(
                             ADJUST_SAME,
                             stream,
                             FLAG_PLAY_SOUND);
+					}
                 }
                 mVolumeKeyUpTime = SystemClock.uptimeMillis();
                 break;
@@ -807,8 +861,15 @@
     public void adjustStreamVolume(int streamType, int direction, int flags) {
         IAudioService service = getService();
         try {
-            service.adjustStreamVolume(streamType, direction, flags,
+            if(direction == ADJUST_MUTE || direction == ADJUST_UNMUTE){
+                service.adjustStreamVolume(streamType, direction, flags,
                     getContext().getOpPackageName());
+            }
+            else if(isUseMasterVolume()){
+                service.adjustMasterVolume(direction, flags, getContext().getOpPackageName());
+            }else{
+                service.adjustStreamVolume(streamType, direction, flags,
+                    getContext().getOpPackageName());}
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
@@ -838,8 +899,17 @@
      * @see #isVolumeFixed()
      */
     public void adjustVolume(int direction, int flags) {
-        MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(getContext());
-        helper.sendAdjustVolumeBy(USE_DEFAULT_STREAM_TYPE, direction, flags);
+        IAudioService service = getService();
+        try {
+		    if (isUseMasterVolume()) {
+                service.adjustMasterVolume(direction, flags, getContext().getOpPackageName());
+            }else{
+		        MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(getContext());
+                helper.sendAdjustVolumeBy(USE_DEFAULT_STREAM_TYPE, direction, flags);
+		    }
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in adjustVolume", e);
+        }
     }
 
     /**
@@ -867,8 +937,17 @@
      * @see #isVolumeFixed()
      */
     public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags) {
-        MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(getContext());
-        helper.sendAdjustVolumeBy(suggestedStreamType, direction, flags);
+        IAudioService service = getService();
+        try {
+            if(isUseMasterVolume()){
+                service.adjustMasterVolume(direction, flags, getContext().getOpPackageName());
+            }else{
+                MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(getContext());
+                helper.sendAdjustVolumeBy(suggestedStreamType, direction, flags);
+            }
+		} catch (RemoteException e) {
+            Log.e(TAG, "Dead object in adjustSuggestedStreamVolume", e);
+        }
     }
 
     /** @hide */
@@ -899,6 +978,25 @@
     }
 
     /**
+     * Adjusts the master volume for the device's audio amplifier.
+     * <p>
+     *
+     * @param steps The number of volume steps to adjust. A positive
+     *            value will raise the volume.
+     * @param flags One or more flags.
+     * @hide
+     */
+    public void adjustMasterVolume(int steps, int flags) {
+        IAudioService service = getService();
+        try {
+            service.adjustMasterVolume(steps, flags, getContext().getOpPackageName());
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in adjustMasterVolume", e);
+        }
+    }
+
+
+    /**
      * Checks valid ringer mode values.
      *
      * @return true if the ringer mode indicated is valid, false otherwise.
@@ -928,7 +1026,10 @@
     public int getStreamMaxVolume(int streamType) {
         IAudioService service = getService();
         try {
-            return service.getStreamMaxVolume(streamType);
+			if(isUseMasterVolume())
+				return service.getMasterMaxVolume();
+			else
+                return service.getStreamMaxVolume(streamType);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
@@ -962,12 +1063,47 @@
     public int getStreamVolume(int streamType) {
         IAudioService service = getService();
         try {
-            return service.getStreamVolume(streamType);
+            if(isUseMasterVolume()){
+                return service.getMasterVolume();
+            }else
+                return service.getStreamVolume(streamType);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
     }
 
+   /**
+     * Returns the current volume index for master volume.
+     *
+     * @return The current volume index for master volume.
+     * @hide
+     */
+    public int getMasterVolume() {
+        IAudioService service = getService();
+        try {
+            return service.getMasterVolume();
+        } catch (RemoteException e) {
+            Log.e(TAG, "Dead object in getMasterVolume", e);
+            return 0;
+        }
+    }
+
+   /**
+	* Get last audible volume before master volume was muted.
+	*
+	* @hide
+	*/
+   public int getLastAudibleMasterVolume() {
+	   IAudioService service = getService();
+	   try {
+		   return service.getLastAudibleMasterVolume();
+	   } catch (RemoteException e) {
+		   Log.e(TAG, "Dead object in getLastAudibleMasterVolume", e);
+		   return 0;
+	   }
+   }
+
+
     /**
      * Get last audible volume before stream was muted.
      *
@@ -976,7 +1112,10 @@
     public int getLastAudibleStreamVolume(int streamType) {
         IAudioService service = getService();
         try {
-            return service.getLastAudibleStreamVolume(streamType);
+            if(isUseMasterVolume())
+                return service.getLastAudibleMasterVolume();
+            else
+                return service.getLastAudibleStreamVolume(streamType);
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
@@ -1043,7 +1182,10 @@
     public void setStreamVolume(int streamType, int index, int flags) {
         IAudioService service = getService();
         try {
-            service.setStreamVolume(streamType, index, flags, getContext().getOpPackageName());
+            if(isUseMasterVolume()){
+                service.setMasterVolume(index, flags, getContext().getOpPackageName());
+            }else{
+                service.setStreamVolume(streamType, index, flags, getContext().getOpPackageName());}
         } catch (RemoteException e) {
             throw e.rethrowFromSystemServer();
         }
@@ -1148,6 +1290,9 @@
      * @hide
      */
     public void forceVolumeControlStream(int streamType) {
+        if (isUseMasterVolume()) {
+            return;
+        }
         IAudioService service = getService();
         try {
             service.forceVolumeControlStream(streamType, mICallBack);
diff -ur ../aosp/frameworks/base/media/java/android/media/AudioTrack.java ../Desktop/android/frameworks/base/media/java/android/media/AudioTrack.java
--- ../aosp/frameworks/base/media/java/android/media/AudioTrack.java	2018-08-06 15:40:47.543480343 +0200
+++ ../Desktop/android/frameworks/base/media/java/android/media/AudioTrack.java	2017-11-23 05:21:35.000000000 +0100
@@ -815,15 +815,6 @@
         }
         mSampleRate = sampleRateInHz;
 
-        // IEC61937 is based on stereo. We could coerce it to stereo.
-        // But the application needs to know the stream is stereo so that
-        // it is encoded and played correctly. So better to just reject it.
-        if (audioFormat == AudioFormat.ENCODING_IEC61937
-                && channelConfig != AudioFormat.CHANNEL_OUT_STEREO) {
-            throw new IllegalArgumentException(
-                    "ENCODING_IEC61937 must be configured as CHANNEL_OUT_STEREO");
-        }
-
         //--------------
         // channel config
         mChannelConfiguration = channelConfig;
diff -ur ../aosp/frameworks/base/media/java/android/media/IAudioService.aidl ../Desktop/android/frameworks/base/media/java/android/media/IAudioService.aidl
--- ../aosp/frameworks/base/media/java/android/media/IAudioService.aidl	2018-08-06 15:40:47.543480343 +0200
+++ ../Desktop/android/frameworks/base/media/java/android/media/IAudioService.aidl	2017-11-23 05:21:35.000000000 +0100
@@ -44,8 +44,12 @@
 
     void adjustStreamVolume(int streamType, int direction, int flags, String callingPackage);
 
+    void adjustMasterVolume(int direction, int flags, String callingPackage);
+
     void setStreamVolume(int streamType, int index, int flags, String callingPackage);
 
+    void setMasterVolume(int index, int flags, String callingPackage);
+
     boolean isStreamMute(int streamType);
 
     void forceRemoteSubmixFullVolume(boolean startForcing, IBinder cb);
@@ -56,12 +60,18 @@
 
     int getStreamVolume(int streamType);
 
+    int getMasterVolume();
+
     int getStreamMinVolume(int streamType);
 
     int getStreamMaxVolume(int streamType);
 
+    int getMasterMaxVolume();
+
     int getLastAudibleStreamVolume(int streamType);
 
+	int getLastAudibleMasterVolume();
+
     void setMicrophoneMute(boolean on, String callingPackage, int userId);
 
     void setRingerModeExternal(int ringerMode, String caller);
diff -ur ../aosp/frameworks/base/media/java/android/media/MediaFile.java ../Desktop/android/frameworks/base/media/java/android/media/MediaFile.java
--- ../aosp/frameworks/base/media/java/android/media/MediaFile.java	2018-08-06 15:40:47.547480394 +0200
+++ ../Desktop/android/frameworks/base/media/java/android/media/MediaFile.java	2017-11-23 05:21:35.000000000 +0100
@@ -69,6 +69,7 @@
 
     // More video file types
     public static final int FILE_TYPE_MP2PS   = 200;
+    public static final int FILE_TYPE_CEDARV  = 201;
     private static final int FIRST_VIDEO_FILE_TYPE2 = FILE_TYPE_MP2PS;
     private static final int LAST_VIDEO_FILE_TYPE2 = FILE_TYPE_MP2PS;
 
@@ -96,6 +97,9 @@
     private static final int FIRST_RAW_IMAGE_FILE_TYPE = FILE_TYPE_DNG;
     private static final int LAST_RAW_IMAGE_FILE_TYPE = FILE_TYPE_SRW;
 
+    // More audio file types
+    private static final int FILE_TYPE_CEDARA = 310;
+
     // Playlist file types
     public static final int FILE_TYPE_M3U      = 41;
     public static final int FILE_TYPE_PLS      = 42;
@@ -187,9 +191,9 @@
         addFileType("WAV", FILE_TYPE_WAV, "audio/x-wav", MtpConstants.FORMAT_WAV);
         addFileType("AMR", FILE_TYPE_AMR, "audio/amr");
         addFileType("AWB", FILE_TYPE_AWB, "audio/amr-wb");
-        if (isWMAEnabled()) {
+        // if (isWMAEnabled()) {
             addFileType("WMA", FILE_TYPE_WMA, "audio/x-ms-wma", MtpConstants.FORMAT_WMA);
-        }
+        // }
         addFileType("OGG", FILE_TYPE_OGG, "audio/ogg", MtpConstants.FORMAT_OGG);
         addFileType("OGG", FILE_TYPE_OGG, "application/ogg", MtpConstants.FORMAT_OGG);
         addFileType("OGA", FILE_TYPE_OGG, "application/ogg", MtpConstants.FORMAT_OGG);
@@ -197,6 +201,16 @@
         addFileType("AAC", FILE_TYPE_AAC, "audio/aac-adts", MtpConstants.FORMAT_AAC);
         addFileType("MKA", FILE_TYPE_MKA, "audio/x-matroska");
 
+        addFileType("APE", FILE_TYPE_CEDARA, "audio/ape");
+        addFileType("OMG", FILE_TYPE_CEDARA, "audio/omg");
+        addFileType("M4R", FILE_TYPE_CEDARA, "audio/m4r");
+        addFileType("MP1", FILE_TYPE_CEDARA, "audio/mp1");
+        addFileType("MP2", FILE_TYPE_CEDARA, "audio/mp2");
+        addFileType("RA", FILE_TYPE_CEDARA, "audio/ra");
+        addFileType("MKA", FILE_TYPE_CEDARA, "audio/mka");
+        addFileType("AC3", FILE_TYPE_CEDARA, "audio/ac3");
+        addFileType("DTS", FILE_TYPE_CEDARA, "audio/dts");
+
         addFileType("MID", FILE_TYPE_MID, "audio/midi");
         addFileType("MIDI", FILE_TYPE_MID, "audio/midi");
         addFileType("XMF", FILE_TYPE_MID, "audio/midi");
@@ -218,12 +232,24 @@
         addFileType("MKV", FILE_TYPE_MKV, "video/x-matroska");
         addFileType("WEBM", FILE_TYPE_WEBM, "video/webm");
         addFileType("TS", FILE_TYPE_MP2TS, "video/mp2ts");
+        addFileType("TP", FILE_TYPE_MP2TS, "video/mp2ts");
+        addFileType("M2TS",FILE_TYPE_MP2TS, "video/mp2ts");
         addFileType("AVI", FILE_TYPE_AVI, "video/avi");
 
-        if (isWMVEnabled()) {
+        addFileType("FLV", FILE_TYPE_CEDARV, "video/flv");
+        addFileType("F4V", FILE_TYPE_CEDARV, "video/f4v");
+        addFileType("MOV", FILE_TYPE_CEDARV, "video/mov");
+        addFileType("PMP", FILE_TYPE_CEDARV, "video/pmp");
+        addFileType("RM",  FILE_TYPE_CEDARV, "video/rm");
+        addFileType("RMVB",FILE_TYPE_CEDARV, "video/rmvb");
+        addFileType("VOB", FILE_TYPE_CEDARV, "video/vob");
+        addFileType("3DM", FILE_TYPE_CEDARV, "video/3dm");
+        addFileType("3DV", FILE_TYPE_CEDARV, "video/3dv");
+
+        // if (isWMVEnabled()) {
             addFileType("WMV", FILE_TYPE_WMV, "video/x-ms-wmv", MtpConstants.FORMAT_WMV);
             addFileType("ASF", FILE_TYPE_ASF, "video/x-ms-asf");
-        }
+        // }
 
         addFileType("JPG", FILE_TYPE_JPEG, "image/jpeg", MtpConstants.FORMAT_EXIF_JPEG);
         addFileType("JPEG", FILE_TYPE_JPEG, "image/jpeg", MtpConstants.FORMAT_EXIF_JPEG);
@@ -271,7 +297,8 @@
         return ((fileType >= FIRST_AUDIO_FILE_TYPE &&
                 fileType <= LAST_AUDIO_FILE_TYPE) ||
                 (fileType >= FIRST_MIDI_FILE_TYPE &&
-                fileType <= LAST_MIDI_FILE_TYPE));
+                fileType <= LAST_MIDI_FILE_TYPE) ||
+                fileType == FILE_TYPE_CEDARA);
     }
 
     public static boolean isVideoFileType(int fileType) {
diff -ur ../aosp/frameworks/base/media/java/android/media/MediaPlayer.java ../Desktop/android/frameworks/base/media/java/android/media/MediaPlayer.java
--- ../aosp/frameworks/base/media/java/android/media/MediaPlayer.java	2018-08-06 15:40:47.551480446 +0200
+++ ../Desktop/android/frameworks/base/media/java/android/media/MediaPlayer.java	2017-11-23 05:21:35.000000000 +0100
@@ -659,6 +659,12 @@
     private static final int INVOKE_ID_SET_VIDEO_SCALE_MODE = 6;
     private static final int INVOKE_ID_GET_SELECTED_TRACK = 7;
 
+    private static final int INVOKE_ID_SET_3D_MODE = 128;
+    private static final int INVOKE_ID_GET_3D_MODE = 129;
+    private static final int INVOKE_ID_GET_CONTENT_ID = 1000;
+    private static final int INVOKE_ID_GET_BITRATE = 1002;
+    private static final int INVOKE_ID_GET_CACHEBYTES = 1003;
+
     /**
      * Create a request parcel which can be routed to the native media
      * player using {@link #invoke(Parcel, Parcel)}. The Parcel
@@ -2002,6 +2008,20 @@
                 mFormat.setInteger(MediaFormat.KEY_IS_DEFAULT, in.readInt());
                 mFormat.setInteger(MediaFormat.KEY_IS_FORCED_SUBTITLE, in.readInt());
             }
+            /*
+            else if (mTrackType == MEDIA_TRACK_TYPE_TIMEDTEXT) {
+                int codecFormat = in.readInt();
+                int isExternal = in.readInt();
+            } else if (mTrackType == MEDIA_TRACK_TYPE_AUDIO) {
+                int channel = in.readInt();
+                int sampleRate = in.readInt();
+                int bitRate = in.readInt();
+                int codec = in.readInt();
+            } else if (mTrackType == MEDIA_TRACK_TYPE_VIDEO) {
+                int is3D = in.readInt();
+                int codec = in.readInt();
+            }
+            */
         }
 
         /** @hide */
@@ -2157,6 +2177,19 @@
      */
     public static final String MEDIA_MIMETYPE_TEXT_CEA_708 = "text/cea-708";
 
+    /*Allwinner BEGIN add by zhaozhili*/
+    public static final String[] MEDIA_MIMETYPE = new String[] {
+        "application/idx-sub",
+        "application/sub",
+        "application/x-subrip", "text/sami", "text/rt", "text/txt",
+        "text/ssa", "text/aqt", "text/jss", "text/js", "text/ass",
+        "text/vsf", "text/tts", "text/stl", "text/zeg", "text/ovr",
+        "text/dks", "text/lrc", "text/pan", "text/sbt", "text/vkt",
+        "text/pjs", "text/mpl", "text/scr", "text/psb", "text/asc",
+        "text/rtf", "text/s2k", "text/sst", "text/son", "text/ssts",
+        "text/smi", "text/rip", "text/matroska-tt-ssa", "text/matroska-tt-vobsub"};
+    /*Allwinner END add by zhaozhili*/
+
     /*
      * A helper function to check if the mime type is supported by media framework.
      */
@@ -2164,6 +2197,13 @@
         if (MEDIA_MIMETYPE_TEXT_SUBRIP.equals(mimeType)) {
             return true;
         }
+        /*Allwinner BEGIN add by zhaozhili*/
+        for(String type : MEDIA_MIMETYPE) {
+            if (type.equals(mimeType)) {
+                return true;
+            }
+        }
+        /*Allwinner END add by zhaozhili*/
         return false;
     }
 
@@ -2491,6 +2531,25 @@
             throw new IllegalArgumentException("Illegal mimeType for timed text source: " + mime);
         }
 
+        /*Allwinner BEGIN add by zhaozhili*/
+        boolean using_native_subtile_decoder = true;
+        if (using_native_subtile_decoder) {
+            Parcel request = Parcel.obtain();
+            Parcel reply = Parcel.obtain();
+            try {
+                request.writeInterfaceToken(IMEDIA_PLAYER);
+                request.writeInt(INVOKE_ID_ADD_EXTERNAL_SOURCE_FD);
+                request.writeFileDescriptor(fd);
+                request.writeLong(offset);
+                request.writeLong(length);
+                request.writeString(mime);
+                invoke(request, reply);
+            } finally {
+                request.recycle();
+                reply.recycle();
+            }
+        } else {
+        /*Allwinner END add by zhaozhili*/
         FileDescriptor fd2;
         try {
             fd2 = Libcore.os.dup(fd);
@@ -2575,6 +2634,10 @@
                 thread.getLooper().quitSafely();
             }
         });
+
+        /*Allwinner BEGIN add by zhaozhili*/
+        } // using_native_subtile_decoder = false
+        /*Allwinner END add by zhaozhili*/
     }
 
     /**
diff -ur ../aosp/frameworks/base/media/java/android/media/session/MediaSessionLegacyHelper.java ../Desktop/android/frameworks/base/media/java/android/media/session/MediaSessionLegacyHelper.java
--- ../aosp/frameworks/base/media/java/android/media/session/MediaSessionLegacyHelper.java	2018-08-06 15:40:47.563480599 +0200
+++ ../Desktop/android/frameworks/base/media/java/android/media/session/MediaSessionLegacyHelper.java	2017-11-23 05:21:35.000000000 +0100
@@ -218,10 +218,15 @@
                 mSessionManager.dispatchAdjustVolume(AudioManager.USE_DEFAULT_STREAM_TYPE,
                         direction, flags);
             } else if (isMute) {
-                if (down && keyEvent.getRepeatCount() == 0) {
+                if (down) {
+                    // We need to send two volume events on down, one to mute
+                    // and one to show the UI
                     mSessionManager.dispatchAdjustVolume(AudioManager.USE_DEFAULT_STREAM_TYPE,
                             AudioManager.ADJUST_TOGGLE_MUTE, flags);
                 }
+                mSessionManager.dispatchAdjustVolume(AudioManager.USE_DEFAULT_STREAM_TYPE,
+                        0 /* direction, causes UI to show on down */, flags);
+
             }
         }
     }
diff -ur ../aosp/frameworks/base/media/java/android/media/TimedText.java ../Desktop/android/frameworks/base/media/java/android/media/TimedText.java
--- ../aosp/frameworks/base/media/java/android/media/TimedText.java	2018-08-06 15:40:47.555480497 +0200
+++ ../Desktop/android/frameworks/base/media/java/android/media/TimedText.java	2017-11-23 05:21:35.000000000 +0100
@@ -18,6 +18,7 @@
 
 import android.graphics.Rect;
 import android.os.Parcel;
+import android.graphics.Bitmap;
 import android.util.Log;
 import java.util.HashMap;
 import java.util.Set;
@@ -48,6 +49,30 @@
  */
 public final class TimedText
 {
+    //aw extend for ssa subtitle position. eric_wang,20130710.
+    //copy cedarx's definitions.
+    public static final int SUB_RENDER_ALIGN_NONE       = 0;
+    public static final int SUB_RENDER_HALIGN_LEFT      = 1;
+    public static final int SUB_RENDER_HALIGN_CENTER    = 2;
+    public static final int SUB_RENDER_HALIGN_RIGHT     = 3;
+    public static final int SUN_RENDER_HALIGN_MASK      = 0x0000000f;
+    public static final int SUB_RENDER_VALIGN_TOP       = (1 << 4);
+    public static final int SUB_RENDER_VALIGN_CENTER    = (2 << 4);
+    public static final int SUB_RENDER_VALIGN_BOTTOM    = (3 << 4);
+    public static final int SUN_RENDER_VALIGN_MASK      = 0x000000f0;
+
+    public static final int SUB_DISPPOS_DEFAULT   = 0;
+    public static final int SUB_DISPPOS_BOT_LEFT  = SUB_RENDER_VALIGN_BOTTOM+SUB_RENDER_HALIGN_LEFT;
+    public static final int SUB_DISPPOS_BOT_MID   = SUB_RENDER_VALIGN_BOTTOM+SUB_RENDER_HALIGN_CENTER;
+    public static final int SUB_DISPPOS_BOT_RIGHT = SUB_RENDER_VALIGN_BOTTOM+SUB_RENDER_HALIGN_RIGHT;
+    public static final int SUB_DISPPOS_MID_LEFT  = SUB_RENDER_VALIGN_CENTER+SUB_RENDER_HALIGN_LEFT;
+    public static final int SUB_DISPPOS_MID_MID   = SUB_RENDER_VALIGN_CENTER+SUB_RENDER_HALIGN_CENTER;
+    public static final int SUB_DISPPOS_MID_RIGHT = SUB_RENDER_VALIGN_CENTER+SUB_RENDER_HALIGN_RIGHT;
+    public static final int SUB_DISPPOS_TOP_LEFT  = SUB_RENDER_VALIGN_TOP   +SUB_RENDER_HALIGN_LEFT;
+    public static final int SUB_DISPPOS_TOP_MID   = SUB_RENDER_VALIGN_TOP   +SUB_RENDER_HALIGN_CENTER;
+    public static final int SUB_DISPPOS_TOP_RIGHT = SUB_RENDER_VALIGN_TOP   +SUB_RENDER_HALIGN_RIGHT;
+    //aw extend for ssa subtitle position. end.
+
     private static final int FIRST_PUBLIC_KEY                 = 1;
 
     // These keys must be in sync with the keys in TextDescription.h
@@ -70,7 +95,20 @@
 
     private static final int LAST_PUBLIC_KEY                  = 16;
 
-    private static final int FIRST_PRIVATE_KEY                = 101;
+    private static final int FIRST_PRIVATE_KEY                = 17;
+    //aw extend for idxsub ,pgs and ssa subtitle. eric_wang,20130625.
+    private static final int KEY_SUBTITLE_ID                   = 17; //subtitle id
+    private static final int KEY_STRUCT_AWEXTEND_BMP           = 50;    // bmp subtitle such as idxsub and pgs.
+    private static final int KEY_STRUCT_AWEXTEND_PIXEL_FORMAT  = 51;    // PIXEL_FORMAT_RGBA_8888
+    private static final int KEY_STRUCT_AWEXTEND_PICWIDTH      = 52;    // bmp subtitle item's width
+    private static final int KEY_STRUCT_AWEXTEND_PICHEIGHT     = 53;    // bmp subtitle item's height
+    private static final int KEY_STRUCT_AWEXTEND_SUBDISPPOS    = 54;    // text subtitle's position, SUB_DISPPOS_BOT_LEFT
+    private static final int KEY_STRUCT_AWEXTEND_SCREENRECT    = 55;    // text subtitle's position need a whole area as a ref.
+    private static final int KEY_STRUCT_AWEXTEND_HIDESUB       = 56;    // when multi subtitle show the same time, such as ssa, we need to tell app which subtitle need to hide.
+    private static final int KEY_STRUCT_AWEXTEND_REFERENCE_VIDEO_WIDTH      = 57;    // bmp subtitle item's reference video width
+    private static final int KEY_STRUCT_AWEXTEND_REFERENCE_VIDEO_HEIGHT     = 58;    // bmp subtitle item's reference video height
+    //aw extend for idxsub ,pgs and ssa subtitle. end.
+
 
     // The following keys are used between TimedText.java and
     // TextDescription.cpp in order to parce the Parcel.
@@ -105,6 +143,18 @@
     private Rect mTextBounds = null;
     private String mTextChars = null;
 
+    //aw extend. for support idxsub ,pgs and ssa subtitle. eric_wang,20130625.
+    private Bitmap  mAWExtendBitmap = null;
+    private int     mAWExtendBitmapSubtitleFlag = 0;    //0:text; 1:bitmap
+    private int     mAWExtendHideSubFlag = 0;           //0:show; 1:hide
+    private int     mAWExtendSubDispPos = SUB_DISPPOS_DEFAULT;    //SUB_DISPPOS_DEFAULT
+    private Rect    mAWExtendTextScreenBounds = null;
+    private int     mAWExtendReferenceVideoWidth = 0;
+    private int     mAWExtendReferenceVideoHeight = 0;
+    //aw extend. for support idxsub ,pgs and ssa subtitle. end.
+
+    private int     mAWExtendSubtitleID = 0;
+
     private Justification mJustification;
 
     /**
@@ -385,6 +435,109 @@
         return mTextBounds;
     }
 
+    //aw extend. for get extend member. eric_wang, 20130710
+    public Bitmap AWExtend_getBitmap()
+    {
+        return mAWExtendBitmap;
+    }
+    public int AWExtend_getBitmapSubtitleFlag()
+    {
+        return mAWExtendBitmapSubtitleFlag;
+    }
+    public int AWExtend_getHideSubFlag()
+    {
+        return mAWExtendHideSubFlag;
+    }
+    public int AWExtend_getSubDispPos()
+    {
+        return mAWExtendSubDispPos;
+    }
+    public Rect AWExtend_getTextScreenBounds()
+    {
+        return mAWExtendTextScreenBounds;
+    }
+    public List<Style> AWExtend_getStyleList()
+    {
+        return mStyleList;
+    }
+
+    public int AWExtend_getSubtitleID()
+    {
+        return mAWExtendSubtitleID;
+    }
+
+    public int AWExtend_getReferenceVideoWidth()
+    {
+        return mAWExtendReferenceVideoWidth;
+    }
+
+    public int AWExtend_getReferenceVideoHeight()
+    {
+        return mAWExtendReferenceVideoHeight;
+    }
+    //aw extend. for get extend member. end.
+
+    private boolean parseBmp(Parcel parcel) {
+        // aw extend: eric_wang add bmp subtitle process code such as idxsub and pgs. 20130625
+        int type = parcel.readInt();
+        if(type != KEY_STRUCT_AWEXTEND_PIXEL_FORMAT)
+        {
+            Log.w(TAG, "java_parseParcel, aw_extend, fail_1!");
+        }
+
+        int pixelFormat = parcel.readInt();
+
+        type = parcel.readInt();
+        if(type != KEY_STRUCT_AWEXTEND_PICWIDTH)
+        {
+            Log.w(TAG, "java_parseParcel, aw_extend, fail_2!");
+        }
+
+        int subWidth = parcel.readInt();
+        //Log.i(TAG, "parseParcel:subWidth=" + subWidth);
+
+        type = parcel.readInt();
+        if(type != KEY_STRUCT_AWEXTEND_PICHEIGHT)
+        {
+            Log.w(TAG, "java_parseParcel, aw_extend, fail_3!");
+        }
+        int subHeight = parcel.readInt();
+        //Log.i(TAG, "parseParcel:subHeight=" + subHeight);
+
+        type = parcel.readInt();
+        if(type != KEY_STRUCT_AWEXTEND_REFERENCE_VIDEO_WIDTH)
+        {
+            Log.w(TAG, "java_parseParcel, aw_extend, fail_4!");
+        }
+        mAWExtendReferenceVideoWidth = parcel.readInt();
+        //Log.i(TAG, "parseParcel:subWidth=" + subWidth);
+
+        type = parcel.readInt();
+        if(type != KEY_STRUCT_AWEXTEND_REFERENCE_VIDEO_HEIGHT)
+        {
+            Log.w(TAG, "java_parseParcel, aw_extend, fail_5!");
+        }
+        mAWExtendReferenceVideoHeight = parcel.readInt();
+        //Log.i(TAG, "parseParcel:subHeight=" + subHeight);
+
+        int picLen = parcel.readInt();
+        //Log.i(TAG, "parseParcel:picLen=" + picLen);
+        int[] ARGBBuf = parcel.createIntArray();
+        if (ARGBBuf == null || ARGBBuf.length == 0)
+        {
+            Log.w(TAG, "java_parseParcel, aw_extend, fail_4!");
+            mAWExtendBitmap = null;
+        }
+        else
+        {
+            //Log.i(TAG, "parseParcel:ARGBBuf.length_int=" + ARGBBuf.length);
+            mAWExtendBitmap = Bitmap.createBitmap(ARGBBuf, subWidth, subHeight, Bitmap.Config.ARGB_8888);
+        }
+        mAWExtendBitmapSubtitleFlag = 1;
+
+        return true;
+    }
+
     /*
      * Go over all the records, collecting metadata keys and fields in the
      * Parcel. These are stored in mKeyObjectMap for application to retrieve.
@@ -407,15 +560,24 @@
 
             type = parcel.readInt();
             if (type != KEY_STRUCT_TEXT) {
-                return false;
-            }
+                if(type != KEY_STRUCT_AWEXTEND_BMP)
+                {
+                    Log.w(TAG, "java_parseParcel, find timedtext type=" + type + ", so return false");
+                    return false;
+                }
 
-            int textLen = parcel.readInt();
-            byte[] text = parcel.createByteArray();
-            if (text == null || text.length == 0) {
-                mTextChars = null;
+                if (parseBmp(parcel) == false) {
+                    return false;
+                }
             } else {
-                mTextChars = new String(text);
+                int textLen = parcel.readInt();
+                byte[] text = parcel.createByteArray();
+                if (text == null || text.length == 0) {
+                    mTextChars = null;
+                } else {
+                    mTextChars = new String(text);
+                }
+                mAWExtendBitmapSubtitleFlag = 0;
             }
 
         } else if (type != KEY_GLOBAL_SETTING) {
@@ -508,6 +670,35 @@
                     object = mScrollDelay;
                     break;
                 }
+                //aw extend. for ssa subtitle. eric_wang, 20130710.
+                case KEY_STRUCT_AWEXTEND_SUBDISPPOS:
+                {
+                    mAWExtendSubDispPos = parcel.readInt();
+                    //Log.i(TAG, "java_parseParcel_SUBDISPPOS=0x" + Integer.toHexString(mAWExtendSubDispPos));
+                    break;
+                }
+                case KEY_STRUCT_AWEXTEND_SCREENRECT:
+                {
+                    int top     = parcel.readInt();
+                    int left    = parcel.readInt();
+                    int bottom  = parcel.readInt();
+                    int right   = parcel.readInt();
+                    //Log.i(TAG, "java_parseParcel_SCREENRECT, top:" + top + ", " + "left:" + left + ", " + "bottom:" + bottom + ", " + "right:" + right);
+                    mAWExtendTextScreenBounds = new Rect(left, top, right, bottom);
+                    break;
+                }
+                case KEY_STRUCT_AWEXTEND_HIDESUB:
+                {
+                    mAWExtendHideSubFlag = parcel.readInt();
+                    //Log.i(TAG, "java_parseParcel_HIDESUB=" + mAWExtendHideSubFlag);
+                    break;
+                }
+                case KEY_SUBTITLE_ID:
+                {
+                    mAWExtendSubtitleID = parcel.readInt();
+                    Log.d(TAG,"nSubtitleID = " + mAWExtendSubtitleID);
+                }
+                //aw extend. for ssa subtitle. end.
                 default: {
                     break;
                 }
diff -ur ../aosp/frameworks/base/native/android/Android.mk ../Desktop/android/frameworks/base/native/android/Android.mk
--- ../aosp/frameworks/base/native/android/Android.mk	2018-08-06 15:41:04.683700372 +0200
+++ ../Desktop/android/frameworks/base/native/android/Android.mk	2017-11-23 05:21:45.000000000 +0100
@@ -18,6 +18,7 @@
     sensor.cpp \
     storage_manager.cpp \
     trace.cpp \
+    input_addon.cpp
 
 LOCAL_SHARED_LIBRARIES := \
     liblog \
Only in ../Desktop/android/frameworks/base/native/android: input_addon.cpp
diff -ur ../aosp/frameworks/base/native/android/input.cpp ../Desktop/android/frameworks/base/native/android/input.cpp
--- ../aosp/frameworks/base/native/android/input.cpp	2018-08-06 15:41:04.683700372 +0200
+++ ../Desktop/android/frameworks/base/native/android/input.cpp	2017-11-23 05:21:45.000000000 +0100
@@ -29,6 +29,7 @@
 
 #include <poll.h>
 #include <errno.h>
+#include <android/input_addon.h>
 
 using android::InputEvent;
 using android::InputQueue;
@@ -47,7 +48,13 @@
 }
 
 int32_t AInputEvent_getSource(const AInputEvent* event) {
-    return static_cast<const InputEvent*>(event)->getSource();
+    int32_t source = static_cast<const InputEvent*>(event)->getSource();
+    //check if the process is kodi
+    int ret = ensureCallingProcesss("org.xbmc.kodi");
+    if(ret == 0){
+        source &= ~(1 << 10);
+    }
+    return source;
 }
 
 int32_t AKeyEvent_getAction(const AInputEvent* key_event) {
diff -ur ../aosp/frameworks/base/packages/SettingsLib/src/com/android/settingslib/drawer/SettingsDrawerActivity.java ../Desktop/android/frameworks/base/packages/SettingsLib/src/com/android/settingslib/drawer/SettingsDrawerActivity.java
--- ../aosp/frameworks/base/packages/SettingsLib/src/com/android/settingslib/drawer/SettingsDrawerActivity.java	2018-08-06 15:41:05.307708382 +0200
+++ ../Desktop/android/frameworks/base/packages/SettingsLib/src/com/android/settingslib/drawer/SettingsDrawerActivity.java	2017-11-23 05:21:45.000000000 +0100
@@ -214,8 +214,10 @@
 
     public void showMenuIcon() {
         mShowingMenu = true;
+        if(getActionBar()!=null){
         getActionBar().setHomeAsUpIndicator(R.drawable.ic_menu);
         getActionBar().setDisplayHomeAsUpEnabled(true);
+        }
     }
 
     public List<DashboardCategory> getDashboardCategories() {
diff -ur ../aosp/frameworks/base/packages/SettingsLib/src/com/android/settingslib/RestrictedLockUtils.java ../Desktop/android/frameworks/base/packages/SettingsLib/src/com/android/settingslib/RestrictedLockUtils.java
--- ../aosp/frameworks/base/packages/SettingsLib/src/com/android/settingslib/RestrictedLockUtils.java	2018-08-06 15:41:05.287708125 +0200
+++ ../Desktop/android/frameworks/base/packages/SettingsLib/src/com/android/settingslib/RestrictedLockUtils.java	2017-11-23 05:21:45.000000000 +0100
@@ -344,6 +344,9 @@
         }
         boolean isAccountTypeDisabled = false;
         String[] disabledTypes = dpm.getAccountTypesWithManagementDisabledAsUser(userId);
+        if(disabledTypes == null){
+            return null;
+        }
         for (String type : disabledTypes) {
             if (accountType.equals(type)) {
                 isAccountTypeDisabled = true;
diff -ur ../aosp/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java ../Desktop/android/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java
--- ../aosp/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java	2018-08-06 15:41:05.315708485 +0200
+++ ../Desktop/android/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java	2017-11-23 05:21:45.000000000 +0100
@@ -787,7 +787,11 @@
             }
             NetworkCapabilities nc = cm.getNetworkCapabilities(nw);
             if (nc != null && !nc.hasCapability(nc.NET_CAPABILITY_VALIDATED)) {
-                return context.getString(R.string.wifi_connected_no_internet);
+                /**
+                 * FIX ME
+                 * maybe should disable CAPTIVE_PORTAL_DETECTION_ENABLED
+                 */
+                //return context.getString(R.string.wifi_connected_no_internet);
             }
         }
 
Only in ../Desktop/android/frameworks/base/packages/SettingsProvider/res/values: defaults_custom.xml
diff -ur ../aosp/frameworks/base/packages/SettingsProvider/res/values/defaults.xml ../Desktop/android/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
--- ../aosp/frameworks/base/packages/SettingsProvider/res/values/defaults.xml	2018-08-06 15:41:05.347708895 +0200
+++ ../Desktop/android/frameworks/base/packages/SettingsProvider/res/values/defaults.xml	2017-11-23 05:21:45.000000000 +0100
@@ -214,6 +214,30 @@
     <!-- Default for Settings.Secure.NFC_PAYMENT_COMPONENT -->
     <string name="def_nfc_payment_component"></string>
 
+    <!-- Default for Settings captive portal false -->
+    <bool name="def_captive_portal_detection_enabled">false</bool>
+
     <!-- Default setting for ability to add users from the lock screen -->
     <bool name="def_add_users_from_lockscreen">false</bool>
+    <!-- cmcc by fuqiang, start -->
+	<string name="def_home_page">http://bngt.itv.cmvideo.cn:8095</string>
+	<string name="def_upgrade_url">http://tview.itv.cmvideo.cn:80/ACSServlet</string>
+	<string name="def_upgrade_path"></string>
+	<string name="def_ntvuseraccount"></string>
+	<string name="def_ntvusersuffix"></string>
+	<string name="def_ntvuserpassword"></string>
+	<string name="def_ntp_server">cn.pool.ntp.org</string>
+	<string name="def_ntp_server2">221.181.100.40</string>
+	<string name="def_default_screen_ratio">1</string>
+	<string name="def_default_player_quality">0</string>
+	<string name="def_display_area"></string>
+
+	<string name="def_dhcp_user"></string>
+	<string name="def_dhcp_pswd"></string>
+	<string name="def_dhcp_option"></string>
+	<string name="def_dhcp_ipver"></string>
+	<string name="def_pppoe_username"></string>
+	<string name="def_pppoe_pswd"></string>
+	<string name="def_sqm_start_mode">0</string>
+	<!-- cmcc by fuqiang, end -->
 </resources>
diff -ur ../aosp/frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java ../Desktop/android/frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
--- ../aosp/frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java	2018-08-06 15:41:05.347708895 +0200
+++ ../Desktop/android/frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java	2017-11-23 05:21:45.000000000 +0100
@@ -375,6 +375,23 @@
                     Settings.Secure.WIFI_WATCHDOG_PING_COUNT,
                     Settings.Secure.WIFI_WATCHDOG_PING_DELAY_MS,
                     Settings.Secure.WIFI_WATCHDOG_PING_TIMEOUT_MS,
+                    Settings.Secure.HOME_PAGE,    //cmcc by fuqiang, start
+                    Settings.Secure.UPGRADE_URL,
+                    Settings.Secure.UPGRADE_PATH,
+                    Settings.Secure.NTVUSERACCOUNT,
+                    Settings.Secure.NTVUSERSUFFIX,
+                    Settings.Secure.NTVUSERPASSWORD,
+                    Settings.Secure.NTP_SERVER,
+                    Settings.Secure.NTP_SERVER2,
+                    Settings.Secure.DEFAULT_SCREEN_RATIO,
+                    Settings.Secure.DEFAULT_PLAYER_QUALITY,
+                    Settings.Secure.DHCP_USER,
+                    Settings.Secure.DHCP_PSWD,
+                    Settings.Secure.DHCP_OPTION,
+                    Settings.Secure.DHCP_IPVER,
+                    Settings.Secure.PPPOE_USERNAME,
+                    Settings.Secure.PPPOE_PSWD,
+                    Settings.Secure.SQM_START_MODE, //cmcc by fuqiang, end
                 };
             moveSettingsToNewTable(db, TABLE_SYSTEM, TABLE_SECURE, settingsToMove, false);
             upgradeVersion = 28;
@@ -2395,6 +2412,13 @@
             loadIntegerSetting(stmt, Settings.System.POINTER_SPEED,
                     R.integer.def_pointer_speed);
 
+            loadStringSetting(stmt, Settings.System.AUDIO_OUTPUT_CHANNEL,
+                    R.string.def_audio_output_channel);
+            loadIntegerSetting(stmt, Settings.System.AUDIO_MANAGE_POLICY,
+                    R.integer.def_audio_manage_policy);
+            loadBooleanSetting(stmt, Settings.System.ENABLE_PASS_THROUGH,
+                    R.bool.def_enable_pass_through);
+
             /*
              * IMPORTANT: Do not add any more upgrade steps here as the global,
              * secure, and system settings are no longer stored in a database
@@ -2484,6 +2508,62 @@
 
             loadStringSetting(stmt, Settings.Secure.ACCESSIBILITY_SCREEN_READER_URL,
                     R.string.def_accessibility_screen_reader_url);
+			//cmcc by fuqiang, start
+            loadStringSetting(stmt, Settings.Secure.HOME_PAGE,
+                    R.string.def_home_page);
+
+            loadStringSetting(stmt, Settings.Secure.UPGRADE_URL,
+                    R.string.def_upgrade_url);
+
+            loadStringSetting(stmt, Settings.Secure.UPGRADE_PATH,
+                    R.string.def_upgrade_path);
+
+            loadStringSetting(stmt, Settings.Secure.NTVUSERACCOUNT,
+                    R.string.def_ntvuseraccount);
+
+            loadStringSetting(stmt, Settings.Secure.NTVUSERSUFFIX,
+                    R.string.def_ntvusersuffix);
+
+            loadStringSetting(stmt, Settings.Secure.NTVUSERPASSWORD,
+                    R.string.def_ntvuserpassword);
+
+            loadStringSetting(stmt, Settings.Secure.NTP_SERVER,
+                    R.string.def_ntp_server);
+
+			loadStringSetting(stmt, Settings.Secure.NTP_SERVER2,
+                    R.string.def_ntp_server2);
+
+            loadStringSetting(stmt, Settings.Secure.DEFAULT_SCREEN_RATIO,
+                    R.string.def_default_screen_ratio);
+
+            loadStringSetting(stmt, Settings.Secure.DEFAULT_PLAYER_QUALITY,
+                    R.string.def_default_player_quality);
+
+
+            loadStringSetting(stmt, Settings.Secure.DISPLAY_AREA,
+                    R.string.def_display_area);
+
+			loadStringSetting(stmt, Settings.Secure.DHCP_USER,
+                    R.string.def_dhcp_user);
+
+			loadStringSetting(stmt, Settings.Secure.DHCP_PSWD,
+                    R.string.def_dhcp_pswd);
+
+			loadStringSetting(stmt, Settings.Secure.DHCP_OPTION,
+                    R.string.def_dhcp_option);
+
+			loadStringSetting(stmt, Settings.Secure.DHCP_IPVER,
+                    R.string.def_dhcp_ipver);
+
+			loadStringSetting(stmt, Settings.Secure.PPPOE_USERNAME,
+                    R.string.def_pppoe_username);
+
+			loadStringSetting(stmt, Settings.Secure.PPPOE_PSWD,
+                    R.string.def_pppoe_pswd);
+
+			loadStringSetting(stmt, Settings.Secure.SQM_START_MODE,
+                    R.string.def_sqm_start_mode);
+			//cmcc by fuqiang, end
 
             if (SystemProperties.getBoolean("ro.lockscreen.disable.default", false) == true) {
                 loadSetting(stmt, Settings.System.LOCKSCREEN_DISABLED, "1");
@@ -2502,7 +2582,6 @@
                     com.android.internal.R.string.config_dreamsDefaultComponent);
             loadStringSetting(stmt, Settings.Secure.SCREENSAVER_DEFAULT_COMPONENT,
                     com.android.internal.R.string.config_dreamsDefaultComponent);
-
             loadBooleanSetting(stmt, Settings.Secure.ACCESSIBILITY_DISPLAY_MAGNIFICATION_ENABLED,
                     R.bool.def_accessibility_display_magnification_enabled);
 
@@ -2677,6 +2756,7 @@
             loadIntegerSetting(stmt, Settings.Global.DOCK_AUDIO_MEDIA_ENABLED,
                     R.integer.def_dock_audio_media_enabled);
 
+
             loadSetting(stmt, Settings.Global.SET_INSTALL_LOCATION, 0);
             loadSetting(stmt, Settings.Global.DEFAULT_INSTALL_LOCATION,
                     PackageHelper.APP_INSTALL_AUTO);
@@ -2713,6 +2793,9 @@
             loadSetting(stmt, Settings.Global.ENHANCED_4G_MODE_ENABLED,
                     ImsConfig.FeatureValueConstants.ON);
 
+            loadBooleanSetting(stmt, Settings.Global.CAPTIVE_PORTAL_DETECTION_ENABLED,
+                    R.bool.def_captive_portal_detection_enabled);
+
             /*
              * IMPORTANT: Do not add any more upgrade steps here as the global,
              * secure, and system settings are no longer stored in a database
diff -ur ../aosp/frameworks/base/packages/SystemUI/src/com/android/systemui/recents/tv/RecentsTvActivity.java ../Desktop/android/frameworks/base/packages/SystemUI/src/com/android/systemui/recents/tv/RecentsTvActivity.java
--- ../aosp/frameworks/base/packages/SystemUI/src/com/android/systemui/recents/tv/RecentsTvActivity.java	2018-08-06 15:41:05.671713054 +0200
+++ ../Desktop/android/frameworks/base/packages/SystemUI/src/com/android/systemui/recents/tv/RecentsTvActivity.java	2017-11-23 05:21:46.000000000 +0100
@@ -297,6 +297,7 @@
             finish();
             return;
         }
+		mPipManager.initialize(this);
         mPipRecentsOverlayManager = PipManager.getInstance().getPipRecentsOverlayManager();
 
         // Register this activity with the event bus
diff -ur ../aosp/frameworks/base/packages/WallpaperCropper/res/values/strings.xml ../Desktop/android/frameworks/base/packages/WallpaperCropper/res/values/strings.xml
--- ../aosp/frameworks/base/packages/WallpaperCropper/res/values/strings.xml	2018-08-06 15:41:05.775714389 +0200
+++ ../Desktop/android/frameworks/base/packages/WallpaperCropper/res/values/strings.xml	2017-11-23 05:21:46.000000000 +0100
@@ -16,7 +16,7 @@
 <resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
     <string name="crop_wallpaper">Crop wallpaper</string>
     <!-- Button label on Wallpaper picker screen; user selects this button to set a specific wallpaper -->
-    <string name="wallpaper_instructions">Set wallpaper</string>
+    <string name="wallpaper_instructions">Press Center Key Set wallpaper</string>
     <!-- Error message when an image is selected as a wallpaper,
          but the wallpaper cropper cannot load it. The user will
          usually see this when using another app and trying to set
diff -ur ../aosp/frameworks/base/packages/WallpaperCropper/res/values-sw600dp/config.xml ../Desktop/android/frameworks/base/packages/WallpaperCropper/res/values-sw600dp/config.xml
--- ../aosp/frameworks/base/packages/WallpaperCropper/res/values-sw600dp/config.xml	2018-08-06 15:41:05.775714389 +0200
+++ ../Desktop/android/frameworks/base/packages/WallpaperCropper/res/values-sw600dp/config.xml	2017-11-23 05:21:46.000000000 +0100
@@ -14,5 +14,5 @@
      limitations under the License.
 -->
 <resources>
-    <bool name="allow_rotation">true</bool>
+    <bool name="allow_rotation">false</bool>
 </resources>
diff -ur ../aosp/frameworks/base/packages/WallpaperCropper/res/values-zh-rCN/strings.xml ../Desktop/android/frameworks/base/packages/WallpaperCropper/res/values-zh-rCN/strings.xml
--- ../aosp/frameworks/base/packages/WallpaperCropper/res/values-zh-rCN/strings.xml	2018-08-06 15:41:05.775714389 +0200
+++ ../Desktop/android/frameworks/base/packages/WallpaperCropper/res/values-zh-rCN/strings.xml	2017-11-23 05:21:46.000000000 +0100
@@ -19,7 +19,7 @@
 
 <resources xmlns:android="http://schemas.android.com/apk/res/android"
     xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
-    <string name="wallpaper_instructions" msgid="3524143401182707094">"设置壁纸"</string>
+    <string name="wallpaper_instructions" msgid="3524143401182707094">"按中键设置壁纸"</string>
     <string name="wallpaper_load_fail" msgid="4800700444605404650">"无法加载要设为壁纸的图片"</string>
     <string name="crop_wallpaper" msgid="4882870800623585836">"剪裁壁纸"</string>
 </resources>
diff -ur ../aosp/frameworks/base/packages/WallpaperCropper/src/com/android/wallpapercropper/WallpaperCropActivity.java ../Desktop/android/frameworks/base/packages/WallpaperCropper/src/com/android/wallpapercropper/WallpaperCropActivity.java
--- ../aosp/frameworks/base/packages/WallpaperCropper/src/com/android/wallpapercropper/WallpaperCropActivity.java	2018-08-06 15:41:05.779714440 +0200
+++ ../Desktop/android/frameworks/base/packages/WallpaperCropper/src/com/android/wallpapercropper/WallpaperCropActivity.java	2017-11-23 05:21:46.000000000 +0100
@@ -39,6 +39,7 @@
 import android.util.Log;
 import android.view.Display;
 import android.view.View;
+import android.view.KeyEvent;
 import android.view.WindowManager;
 import android.widget.Toast;
 
@@ -81,7 +82,7 @@
         super.onCreate(savedInstanceState);
         init();
         if (!enableRotation()) {
-            setRequestedOrientation(Configuration.ORIENTATION_PORTRAIT);
+            setRequestedOrientation(Configuration.ORIENTATION_LANDSCAPE);
         }
     }
 
@@ -98,7 +99,7 @@
             finish();
             return;
         }
-
+	mUri = imageUri;
         // Action bar
         // Show the custom action bar view
         final ActionBar actionBar = getActionBar();
@@ -140,6 +141,15 @@
         super.onDestroy();
     }
 
+    @Override
+    public boolean onKeyDown(int keyCode,KeyEvent event){
+	if(keyCode == KeyEvent.KEYCODE_DPAD_CENTER){
+		 boolean finishActivityWhenDone = true;
+		cropImageAndSetWallpaper(mUri, null, finishActivityWhenDone);
+	}
+	return super.onKeyDown(keyCode,event);
+    }
+
     public void setCropViewTileSource(
             final BitmapRegionTileSource.BitmapSource bitmapSource, final boolean touchEnabled,
             final boolean moveToLeft, final Runnable postExecute) {
diff -ur ../aosp/frameworks/base/preloaded-classes ../Desktop/android/frameworks/base/preloaded-classes
--- ../aosp/frameworks/base/preloaded-classes	2018-08-06 15:41:05.783714492 +0200
+++ ../Desktop/android/frameworks/base/preloaded-classes	2017-11-23 05:21:46.000000000 +0100
@@ -1488,6 +1488,7 @@
 android.net.ConnectivityThread
 android.net.Credentials
 android.net.EthernetManager
+android.net.pppoe.PppoeManager
 android.net.IConnectivityManager
 android.net.IConnectivityManager$Stub
 android.net.IConnectivityManager$Stub$Proxy
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java	2018-08-06 15:41:05.851715365 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java	2017-11-23 05:21:46.000000000 +0100
@@ -123,6 +123,7 @@
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.content.IntentSender;
+import android.content.SharedPreferences;
 import android.content.pm.ActivityInfo;
 import android.content.pm.ApplicationInfo;
 import android.content.pm.ConfigurationInfo;
@@ -403,6 +404,16 @@
     // need not be the case.
     public static final String ACTION_TRIGGER_IDLE = "com.android.server.ACTION_TRIGGER_IDLE";
 
+    //add by zhangmm 17/02/27:Set PIP position and size by "Settings" APP saving data
+    private static final int DEFAULT_PIP_BOUNDS_LEFT = 1328;
+    private static final int DEFAULT_PIP_BOUNDS_RIGHT = 1808;
+    private static final int DEFAULT_PIP_BOUNDS_TOP = 54;
+    private static final int DEFAULT_PIP_BOUNDS_BOTTOM = 324;
+    private static final String ALLWINNER_PIP_SETTINGS_BOUNDS_LEFT = "persist.sys.pip.bounds.left";
+    private static final String ALLWINNER_PIP_SETTINGS_BOUNDS_RIGHT = "persist.sys.pip.bounds.right";
+    private static final String ALLWINNER_PIP_SETTINGS_BOUNDS_TOP = "persist.sys.pip.bounds.top";
+    private static final String ALLWINNER_PIP_SETTINGS_BOUNDS_BOTTOM = "persist.sys.pip.bounds.bottom";
+
     /** Control over CPU and battery monitoring */
     // write battery stats every 30 minutes.
     static final long BATTERY_STATS_TIME = 30 * 60 * 1000;
@@ -7552,9 +7563,13 @@
                 // Use the default launch bounds for pinned stack if it doesn't exist yet or use the
                 // current bounds.
                 final ActivityStack pinnedStack = mStackSupervisor.getStack(PINNED_STACK_ID);
+                int left = SystemProperties.getInt(ALLWINNER_PIP_SETTINGS_BOUNDS_LEFT, DEFAULT_PIP_BOUNDS_LEFT);
+                int right = SystemProperties.getInt(ALLWINNER_PIP_SETTINGS_BOUNDS_RIGHT, DEFAULT_PIP_BOUNDS_RIGHT);
+                int top = SystemProperties.getInt(ALLWINNER_PIP_SETTINGS_BOUNDS_TOP, DEFAULT_PIP_BOUNDS_TOP);
+                int bottom = SystemProperties.getInt(ALLWINNER_PIP_SETTINGS_BOUNDS_BOTTOM, DEFAULT_PIP_BOUNDS_BOTTOM);
+                mDefaultPinnedStackBounds = new Rect(left,top,right,bottom);
                 final Rect bounds = (pinnedStack != null)
                         ? pinnedStack.mBounds : mDefaultPinnedStackBounds;
-
                 mStackSupervisor.moveActivityToPinnedStackLocked(
                         r, "enterPictureInPictureMode", bounds);
             }
@@ -20166,7 +20181,8 @@
                     } catch (Exception e) {
                         Slog.w(TAG, "Failed setting process group of " + app.pid
                                 + " to " + app.curSchedGroup);
-                        e.printStackTrace();
+                        //There is too much following print.
+                        //e.printStackTrace();
                     } finally {
                         Binder.restoreCallingIdentity(oldId);
                     }
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/am/AppErrors.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/am/AppErrors.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/am/AppErrors.java	2018-08-06 15:41:05.871715622 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/am/AppErrors.java	2017-11-23 05:21:46.000000000 +0100
@@ -457,9 +457,12 @@
                             r.kill("crash", true);
                         }
                     } else {
-                        // Huh.
+                        // Huh. we can't kill systme_server
+			Log.d("Killer","we want kill uid = " + uid + " pid = " + pid);
+			if(uid!=1000){
                         Process.killProcess(pid);
                         ActivityManagerService.killProcessGroup(uid, pid);
+			}
                     }
                 }
                 return true;
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/am/ProcessList.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/am/ProcessList.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/am/ProcessList.java	2018-08-06 15:41:05.875715673 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/am/ProcessList.java	2017-11-23 05:21:46.000000000 +0100
@@ -144,7 +144,7 @@
     // we have no limit on the number of service, visible, foreground, or other such
     // processes and the number of those processes does not count against the cached
     // process limit.
-    static final int MAX_CACHED_APPS = 32;
+    static final int MAX_CACHED_APPS = 5;
 
     // We allow empty processes to stick around for at most 30 minutes.
     static final long MAX_EMPTY_TIME = 30*60*1000;
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/AssetAtlasService.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/AssetAtlasService.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/AssetAtlasService.java	2018-08-06 15:41:05.807714800 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/AssetAtlasService.java	2017-11-23 05:21:46.000000000 +0100
@@ -408,8 +408,12 @@
                     results.size(), delay));
         }
 
-        WorkerResult result = results.get(0);
-        return new Configuration(result.type, result.width, result.height, result.count);
+        if (results.size()>0) {
+            WorkerResult result = results.get(0);
+            return new Configuration(result.type, result.width, result.height, result.count);
+        } else {
+            return null;
+        }
     }
 
     /**
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/audio/AudioService.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/audio/AudioService.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/audio/AudioService.java	2018-08-06 15:41:05.879715724 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/audio/AudioService.java	2017-11-23 05:21:46.000000000 +0100
@@ -196,6 +196,7 @@
 
     // AudioHandler messages
     private static final int MSG_SET_DEVICE_VOLUME = 0;
+	private static final int MSG_PERSIST_MASTER_VOLUME = 2;
     private static final int MSG_PERSIST_VOLUME = 1;
     private static final int MSG_PERSIST_RINGER_MODE = 3;
     private static final int MSG_AUDIO_SERVER_DIED = 4;
@@ -250,6 +251,14 @@
     private final Object mSoundEffectsLock = new Object();
     private static final int NUM_SOUNDPOOL_CHANNELS = 4;
 
+    // Internally master volume is a float in the 0.0 - 1.0 range,
+    // but to support integer based AudioManager API we translate it to 0 - 100
+    private static final int MAX_MASTER_VOLUME = 75;
+
+    // Maximum volume adjust steps allowed in a single batch call.
+    private static final int MAX_BATCH_VOLUME_ADJUST_STEPS = 4;
+
+
     /* Sound effect file names  */
     private static final String SOUND_EFFECTS_PATH = "/media/audio/ui/";
     private static final List<String> SOUND_EFFECT_FILES = new ArrayList<String>();
@@ -434,6 +443,8 @@
     // Forced device usage for communications
     private int mForcedUseForComm;
 
+    private final int[] mMasterVolumeRamp;
+
     // List of binder death handlers for setMode() client processes.
     // The last process to have called setMode() is at the top of the list.
     private final ArrayList <SetModeDeathHandler> mSetModeDeathHandlers = new ArrayList <SetModeDeathHandler>();
@@ -658,6 +669,8 @@
 
         mUseFixedVolume = mContext.getResources().getBoolean(
                 com.android.internal.R.bool.config_useFixedVolume);
+        mMasterVolumeRamp = mContext.getResources().getIntArray(
+                com.android.internal.R.array.config_masterVolumeRamp);
 
         // must be called before readPersistedSettings() which needs a valid mStreamVolumeAlias[]
         // array initialized by updateStreamVolumeAlias()
@@ -709,12 +722,19 @@
         mUserManagerInternal.addUserRestrictionsListener(mUserRestrictionsListener);
 
         mRecordMonitor.initMonitor();
+        restoreMasterVolume();
     }
 
     public void systemReady() {
         sendMsg(mAudioHandler, MSG_SYSTEM_READY, SENDMSG_QUEUE,
                 0, 0, null, 0);
     }
+	private boolean isUseMasterVolume(){
+		if(SystemProperties.getBoolean("media.stagefright.mode", false) == true)
+			return false;
+		else
+			return true;
+	}
 
     public void onSystemReady() {
         mSystemReady = true;
@@ -832,6 +852,9 @@
         // Restore ringer mode
         setRingerModeInt(getRingerModeInternal(), false);
 
+		// Restore master volume
+		restoreMasterVolume();
+
         // Reset device orientation (if monitored for this device)
         if (mMonitorOrientation) {
             setOrientationForAudioSystem();
@@ -1161,12 +1184,14 @@
     /** @see AudioManager#adjustVolume(int, int) */
     public void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags,
             String callingPackage, String caller) {
+            Log.d(TAG,"myprint adjustSuggestedStreamVolume1 direction = " + direction + "suggestedStreamType = " + suggestedStreamType + "flags = " + flags);
         adjustSuggestedStreamVolume(direction, suggestedStreamType, flags, callingPackage,
                 caller, Binder.getCallingUid());
     }
 
     private void adjustSuggestedStreamVolume(int direction, int suggestedStreamType, int flags,
             String callingPackage, String caller, int uid) {
+        Log.d(TAG,"myprint adjustSuggestedStreamVolume2");
         if (DEBUG_VOL) Log.d(TAG, "adjustSuggestedStreamVolume() stream=" + suggestedStreamType
                 + ", flags=" + flags + ", caller=" + caller);
         int streamType;
@@ -1200,12 +1225,14 @@
     /** @see AudioManager#adjustStreamVolume(int, int, int) */
     public void adjustStreamVolume(int streamType, int direction, int flags,
             String callingPackage) {
+        Log.d(TAG,"myprint adjustStreamVolume1 direction = " + direction + "streamType = " + streamType + "flags = " + flags);
         adjustStreamVolume(streamType, direction, flags, callingPackage, callingPackage,
                 Binder.getCallingUid());
     }
 
     private void adjustStreamVolume(int streamType, int direction, int flags,
             String callingPackage, String caller, int uid) {
+        Log.d(TAG,"myprint adjustStreamVolume2 direction = " + direction + "streamType = " + streamType + "flags = " + flags);
         if (mUseFixedVolume) {
             return;
         }
@@ -1429,6 +1456,28 @@
             }
         }
     }
+    /** @see AudioManager#adjustMasterVolume(int, int) */
+    public void adjustMasterVolume(int steps, int flags, String callingPackage) {
+        adjustMasterVolume(steps, flags, callingPackage, Binder.getCallingUid());
+    }
+
+    public void adjustMasterVolume(int steps, int flags, String callingPackage, int uid) {
+        if (mUseFixedVolume) {
+            return;
+        }
+        ensureValidSteps(steps);
+        int volume = Math.round(AudioSystem.getMasterVolume() * MAX_MASTER_VOLUME);
+        int delta = 0;
+        int numSteps = Math.abs(steps);
+        int direction = steps > 0 ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER;
+        for (int i = 0; i < numSteps; ++i) {
+            delta = findVolumeDelta(direction, volume);
+            volume += delta;
+        }
+
+        //Log.d(TAG, "adjustMasterVolume volume: " + volume + " steps: " + steps);
+        setMasterVolume(volume, flags, callingPackage, uid);
+    }
 
     // StreamVolumeCommand contains the information needed to defer the process of
     // setStreamVolume() in case the user has to acknowledge the safe volume warning message.
@@ -1601,7 +1650,7 @@
                 index = mStreamStates[streamType].getIndex(device);
             }
         }
-        sendVolumeUpdate(streamType, oldIndex, index, flags);
+        //sendVolumeUpdate(streamType, oldIndex, index, flags);
     }
 
     // No ringer affected streams can be changed in total silence mode except those that
@@ -1667,6 +1716,40 @@
             }
         }
     }
+    private int findVolumeDelta(int direction, int volume) {
+        int delta = 0;
+        if (direction == AudioManager.ADJUST_RAISE) {
+            if (volume == MAX_MASTER_VOLUME) {
+                return 0;
+            }
+            // This is the default value if we make it to the end
+            delta = mMasterVolumeRamp[1];
+            // If we're raising the volume move down the ramp array until we
+            // find the volume we're above and use that groups delta.
+            for (int i = mMasterVolumeRamp.length - 1; i > 1; i -= 2) {
+                if (volume >= mMasterVolumeRamp[i - 1]) {
+                    delta = mMasterVolumeRamp[i];
+                    break;
+                }
+            }
+        } else if (direction == AudioManager.ADJUST_LOWER){
+            if (volume == 0) {
+                return 0;
+            }
+            int length = mMasterVolumeRamp.length;
+            // This is the default value if we make it to the end
+            delta = -mMasterVolumeRamp[length - 1];
+            // If we're lowering the volume move up the ramp array until we
+            // find the volume we're below and use the group below it's delta
+            for (int i = 2; i < length; i += 2) {
+                if (volume <= mMasterVolumeRamp[i]) {
+                    delta = -mMasterVolumeRamp[i - 1];
+                    break;
+                }
+            }
+        }
+        return delta;
+    }
 
     private void sendBroadcastToAll(Intent intent) {
         intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
@@ -1704,6 +1787,7 @@
 
     // UI update and Broadcast Intent
     private void sendVolumeUpdate(int streamType, int oldIndex, int index, int flags) {
+    Log.d(TAG,"myprint sendVolumeUpdate oldIndex = " + oldIndex + "streamType = " +  streamType + "index = " + index + "flags = " + flags);
         streamType = mStreamVolumeAlias[streamType];
 
         if (streamType == AudioSystem.STREAM_MUSIC) {
@@ -1726,10 +1810,24 @@
         return flags;
     }
 
+	// UI update and Broadcast Intent
+    private void sendMasterVolumeUpdate(int flags, int oldVolume, int newVolume) {
+        mVolumeController.postMasterVolumeChanged(updateFlagsForSystemAudio(flags));
+
+        Intent intent = new Intent(AudioManager.MASTER_VOLUME_CHANGED_ACTION);
+        intent.putExtra(AudioManager.EXTRA_PREV_MASTER_VOLUME_VALUE, oldVolume);
+        intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_VALUE, newVolume);
+        sendBroadcastToAll(intent);
+    }
+
     // UI update and Broadcast Intent
     private void sendMasterMuteUpdate(boolean muted, int flags) {
         mVolumeController.postMasterMuteChanged(updateFlagsForSystemAudio(flags));
         broadcastMasterMuteStatus(muted);
+        Intent intent = new Intent(AudioManager.STREAM_MUTE_CHANGED_ACTION);
+        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, AudioManager.STREAM_MUSIC);
+        intent.putExtra(AudioManager.EXTRA_STREAM_VOLUME_MUTED, muted);
+        sendBroadcastToAll(intent);
     }
 
     private void broadcastMasterMuteStatus(boolean muted) {
@@ -1940,12 +2038,63 @@
     public boolean isMasterMute() {
         return AudioSystem.getMasterMute();
     }
-
     public void setMasterMute(boolean mute, int flags, String callingPackage, int userId) {
         setMasterMuteInternal(mute, flags, callingPackage, Binder.getCallingUid(),
                 userId);
     }
 
+    @Override
+    public void setMasterVolume(int volume, int flags, String callingPackage) {
+        setMasterVolume(volume, flags, callingPackage, Binder.getCallingUid());
+    }
+
+	public void setMasterVolume(int volume, int flags, String callingPackage, int uid) {
+        if (mUseFixedVolume) {
+            return;
+        }
+
+        if (mAppOps.noteOp(AppOpsManager.OP_AUDIO_MASTER_VOLUME, uid, callingPackage)
+                != AppOpsManager.MODE_ALLOWED) {
+            return;
+        }
+
+        if (volume < 0) {
+            volume = 0;
+        } else if (volume > MAX_MASTER_VOLUME) {
+            volume = MAX_MASTER_VOLUME;
+        }
+        doSetMasterVolume((float)volume / MAX_MASTER_VOLUME, flags);
+    }
+
+	private void doSetMasterVolume(float volume, int flags) {
+        // don't allow changing master volume when muted
+        if (!AudioSystem.getMasterMute()) {
+            int oldVolume = getMasterVolume();
+            AudioSystem.setMasterVolume(volume);
+
+            int newVolume = getMasterVolume();
+            if (newVolume != oldVolume) {
+                // Post a persist master volume msg
+                sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME, SENDMSG_REPLACE,
+                        Math.round(volume * (float)1000.0), 0, null, PERSIST_DELAY);
+                setSystemAudioVolume(oldVolume, newVolume, MAX_MASTER_VOLUME, flags);
+            }
+            // Send the volume update regardless whether there was a change.
+            //sendVolumeUpdate(3,(oldVolume/100 + 5)/10,(newVolume/100 + 5)/10,flags);
+            sendMasterVolumeUpdate(flags, oldVolume, newVolume);
+        }
+    }
+	@Override
+    public int getMasterMaxVolume() {
+        return MAX_MASTER_VOLUME;
+    }
+
+	@Override
+    public int getMasterVolume() {
+        if (isMasterMute()) return 0;
+        return getLastAudibleMasterVolume();
+    }
+
     /** @see AudioManager#getStreamVolume(int) */
     public int getStreamVolume(int streamType) {
         ensureValidStreamType(streamType);
@@ -1984,6 +2133,11 @@
         return (mStreamStates[streamType].getIndex(device) + 5) / 10;
     }
 
+	/** Get last audible master volume before it was muted. */
+    public int getLastAudibleMasterVolume() {
+        return Math.round(AudioSystem.getMasterVolume() * MAX_MASTER_VOLUME);
+    }
+
     /** @see AudioManager#getUiSoundsStreamType()  */
     public int getUiSoundsStreamType() {
         return mStreamVolumeAlias[AudioSystem.STREAM_SYSTEM];
@@ -2182,6 +2336,21 @@
         }
     }
 
+    private void restoreMasterVolume() {
+        if (mUseFixedVolume) {
+            AudioSystem.setMasterVolume(1.0f);
+            return;
+        }
+        if (isUseMasterVolume()) {
+            float volume = Settings.System.getFloatForUser(mContentResolver,
+                    Settings.System.VOLUME_MASTER, -1.0f, UserHandle.USER_CURRENT);
+            if (volume >= 0.0f) {
+                AudioSystem.setMasterVolume(volume);
+            }
+        }
+    }
+
+
     /** @see AudioManager#shouldVibrate(int) */
     public boolean shouldVibrate(int vibrateType) {
         if (!mHasVibrator) return false;
@@ -3550,6 +3719,12 @@
         }
     }
 
+	private void ensureValidSteps(int steps) {
+        if (Math.abs(steps) > MAX_BATCH_VOLUME_ADJUST_STEPS) {
+            throw new IllegalArgumentException("Bad volume adjust steps " + steps);
+        }
+    }
+
     private void ensureValidStreamType(int streamType) {
         if (streamType < 0 || streamType >= mStreamStates.length) {
             throw new IllegalArgumentException("Bad stream type " + streamType);
@@ -3877,9 +4052,9 @@
             if (mStreamVolumeAlias[mStreamType] == mStreamType) {
                 EventLogTags.writeStreamDevicesChanged(mStreamType, prevDevices, devices);
             }
-            sendBroadcastToAll(mStreamDevicesChanged
-                    .putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_DEVICES, prevDevices)
-                    .putExtra(AudioManager.EXTRA_VOLUME_STREAM_DEVICES, devices));
+            //sendBroadcastToAll(mStreamDevicesChanged
+                    //.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_DEVICES, prevDevices)
+                   // .putExtra(AudioManager.EXTRA_VOLUME_STREAM_DEVICES, devices));
             return devices;
         }
 
@@ -3895,7 +4070,7 @@
         public void readSettings() {
             synchronized (VolumeStreamState.class) {
                 // force maximum volume on all streams if fixed volume property is set
-                if (mUseFixedVolume) {
+                if (mUseFixedVolume || isUseMasterVolume()) {
                     mIndexMap.put(AudioSystem.DEVICE_OUT_DEFAULT, mIndexMax);
                     return;
                 }
@@ -4067,7 +4242,7 @@
                 mVolumeChanged.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, oldIndex);
                 mVolumeChanged.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE_ALIAS,
                         mStreamVolumeAlias[mStreamType]);
-                sendBroadcastToAll(mVolumeChanged);
+                //sendBroadcastToAll(mVolumeChanged);
             }
             return changed;
         }
@@ -4172,7 +4347,7 @@
         private int getValidIndex(int index) {
             if (index < mIndexMin) {
                 return mIndexMin;
-            } else if (mUseFixedVolume || index > mIndexMax) {
+            } else if (mUseFixedVolume || isUseMasterVolume() || index > mIndexMax) {
                 return mIndexMax;
             }
 
@@ -4560,6 +4735,15 @@
                 case MSG_PERSIST_VOLUME:
                     persistVolume((VolumeStreamState) msg.obj, msg.arg1);
                     break;
+				case MSG_PERSIST_MASTER_VOLUME:
+						if (mUseFixedVolume) {
+							return;
+						}
+						Settings.System.putFloatForUser(mContentResolver,
+														Settings.System.VOLUME_MASTER,
+														msg.arg1 / (float)1000.0,
+														UserHandle.USER_CURRENT);
+						break;
 
                 case MSG_PERSIST_RINGER_MODE:
                     // note that the value persisted is the current ringer mode, not the
@@ -6095,6 +6279,7 @@
         }
 
         public void postVolumeChanged(int streamType, int flags) {
+			Log.d(TAG,"myprint postVolumeChanged streamType = " +  streamType + "flags = " + flags);
             if (mController == null)
                 return;
             try {
@@ -6108,11 +6293,21 @@
             if (mController == null)
                 return;
             try {
-                mController.masterMuteChanged(flags);
+                mController.volumeChanged(AudioManager.STREAM_MUSIC, flags);
             } catch (RemoteException e) {
                 Log.w(TAG, "Error calling masterMuteChanged", e);
             }
         }
+        public void postMasterVolumeChanged(int flags) {
+            if (mController == null)
+                return;
+            try {
+                mController.volumeChanged(AudioManager.STREAM_MUSIC, flags);
+            } catch (RemoteException e) {
+                Log.w(TAG, "Error calling masterVolumeChanged", e);
+            }
+        }
+
 
         public void setLayoutDirection(int layoutDirection) {
             if (mController == null)
@@ -6172,6 +6367,12 @@
         }
 
         @Override
+        public void adjustMasterVolumeForUid(int steps, int flags, String callingPackage,
+                int uid) {
+            adjustMasterVolume(steps, flags, callingPackage, uid);
+        }
+
+        @Override
         public int getRingerModeInternal() {
             return AudioService.this.getRingerModeInternal();
         }
@@ -6182,6 +6383,12 @@
         }
 
         @Override
+        public void setMasterMuteForUid(boolean state, int flags, String callingPackage, int userId,
+                int uid) {
+            setMasterMuteInternal(state, flags, callingPackage, uid, userId);
+        }
+
+        @Override
         public int getVolumeControllerUid() {
             return mControllerService.mUid;
         }
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/connectivity/NetworkAgentInfo.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/connectivity/NetworkAgentInfo.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/connectivity/NetworkAgentInfo.java	2018-08-06 15:41:05.911716135 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/connectivity/NetworkAgentInfo.java	2017-11-23 05:21:46.000000000 +0100
@@ -236,7 +236,7 @@
         // ConnectivityService.updateCapabilities() to compute the old score prior to updating
         // networkCapabilities (with a potentially different validated state).
         if (!networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED) && !pretendValidated) {
-            score -= UNVALIDATED_SCORE_PENALTY;
+            //score -= UNVALIDATED_SCORE_PENALTY;
         }
         if (score < 0) score = 0;
         return score;
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/ConnectivityService.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/ConnectivityService.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/ConnectivityService.java	2018-08-06 15:41:05.823715005 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/ConnectivityService.java	2017-11-23 05:21:46.000000000 +0100
@@ -165,6 +165,8 @@
 import java.util.SortedSet;
 import java.util.TreeSet;
 
+import com.softwinner.Gpio;
+
 /**
  * @hide
  */
@@ -645,6 +647,24 @@
         mNetworkRequests.put(mDefaultRequest, defaultNRI);
         mNetworkRequestInfoLogs.log("REGISTER " + defaultNRI);
 
+        mWifiRequest = createInternetRequestForTransport(
+                NetworkCapabilities.TRANSPORT_WIFI);
+        NetworkRequestInfo wifiNRI = new NetworkRequestInfo(null, mWifiRequest,
+                new Binder(), NetworkRequestType.REQUEST);
+        mNetworkRequests.put(mWifiRequest, wifiNRI);
+
+        mEthernetRequest = createInternetRequestForTransport(
+                NetworkCapabilities.TRANSPORT_ETHERNET);
+        NetworkRequestInfo ethernetNRI = new NetworkRequestInfo(null, mEthernetRequest,
+                new Binder(), NetworkRequestType.REQUEST);
+        mNetworkRequests.put(mEthernetRequest, ethernetNRI);
+
+        mPppoeRequest = createInternetRequestForTransport(
+                NetworkCapabilities.TRANSPORT_PPPOE);
+        NetworkRequestInfo pppoeNRI = new NetworkRequestInfo(null, mPppoeRequest,
+                new Binder(), NetworkRequestType.REQUEST);
+        mNetworkRequests.put(mPppoeRequest, pppoeNRI);
+
         mDefaultMobileDataRequest = createInternetRequestForTransport(
                 NetworkCapabilities.TRANSPORT_CELLULAR);
 
@@ -4207,7 +4227,9 @@
 
     // Note: if mDefaultRequest is changed, NetworkMonitor needs to be updated.
     private final NetworkRequest mDefaultRequest;
-
+    private final NetworkRequest mWifiRequest;
+    private final NetworkRequest mEthernetRequest;
+    private final NetworkRequest mPppoeRequest;
     // Request used to optionally keep mobile data active even when higher
     // priority networks like Wi-Fi are active.
     private final NetworkRequest mDefaultMobileDataRequest;
@@ -5037,7 +5059,9 @@
         if (state != DetailedState.DISCONNECTED) {
             info.setDetailedState(state, null, info.getExtraInfo());
             sendConnectedBroadcast(info);
+            Gpio.setNetworkLedOn(true);
         } else {
+            Gpio.setNetworkLedOn(false);
             info.setDetailedState(state, info.getReason(), info.getExtraInfo());
             Intent intent = new Intent(ConnectivityManager.CONNECTIVITY_ACTION);
             intent.putExtra(ConnectivityManager.EXTRA_NETWORK_INFO, info);
Only in ../Desktop/android/frameworks/base/services/core/java/com/android/server: DisplayOutputManagerService.java
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/input/InputManagerService.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/input/InputManagerService.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/input/InputManagerService.java	2018-08-06 15:41:05.927716340 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/input/InputManagerService.java	2017-11-23 05:21:46.000000000 +0100
@@ -77,6 +77,7 @@
 import android.provider.Settings.SettingNotFoundException;
 import android.text.TextUtils;
 import android.util.Slog;
+import android.util.Log;
 import android.util.SparseArray;
 import android.util.Xml;
 import android.view.IInputFilter;
@@ -222,6 +223,12 @@
     private static native void nativeSetPointerIconType(long ptr, int iconId);
     private static native void nativeReloadPointerIcons(long ptr);
     private static native void nativeSetCustomPointerIcon(long ptr, PointerIcon icon);
+    //support mouse mode
+    private static native void nativeKeyEnterMouseMode(long ptr);
+    private static native void nativeKeyExitMouseMode(long ptr);
+    private static native void nativeKeySetMouseDistance(long ptr,int distance);
+    private static native void nativeKeySetMouseMoveCode(long ptr,int left,int right,int top,int bottom);
+    private static native void nativeKeySetMouseBtnCode(long ptr,int leftbtn,int midbtn,int rightbtn);
 
     // Input event injection constants defined in InputDispatcher.h.
     private static final int INPUT_EVENT_INJECTION_SUCCEEDED = 0;
@@ -1583,6 +1590,32 @@
         int setting = getShowTouchesSetting(0);
         nativeSetShowTouches(mPtr, setting != 0);
     }
+    public void KeyEnterMouseMode()
+    {
+        Log.d(TAG,"KeyEnterMouseMode");
+        nativeKeyEnterMouseMode(mPtr);
+    }
+
+    public void KeyExitMouseMode()
+    {
+        Log.d(TAG,"KeyExitMouseMode");
+        nativeKeyExitMouseMode(mPtr);
+    }
+
+    public void KeySetMouseDistance(int distance)
+    {
+        nativeKeySetMouseDistance(mPtr,distance);
+    }
+
+    public void KeySetMouseMoveCode(int left,int right,int top,int bottom)
+    {
+        nativeKeySetMouseMoveCode(mPtr,left,right,top,bottom);
+    }
+
+    public void KeySetMouseBtnCode(int leftbtn,int midbtn,int rightbtn)
+    {
+        nativeKeySetMouseBtnCode(mPtr,leftbtn,midbtn,rightbtn);
+    }
 
     private void registerShowTouchesSettingObserver() {
         mContext.getContentResolver().registerContentObserver(
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/media/MediaSessionRecord.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/media/MediaSessionRecord.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/media/MediaSessionRecord.java	2018-08-06 15:41:05.939716494 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/media/MediaSessionRecord.java	2017-11-23 05:21:46.000000000 +0100
@@ -38,6 +38,8 @@
 import android.media.session.PlaybackState;
 import android.media.AudioAttributes;
 import android.net.Uri;
+import android.os.UserHandle;
+import android.os.SystemProperties;
 import android.os.Binder;
 import android.os.Bundle;
 import android.os.DeadObjectException;
@@ -90,6 +92,7 @@
     private final SessionStub mSession;
     private final SessionCb mSessionCb;
     private final MediaSessionService mService;
+    private final boolean mUseMasterVolume;
 
     private final Object mLock = new Object();
     private final ArrayList<ISessionControllerCallback> mControllerCallbacks =
@@ -142,6 +145,10 @@
         mAudioManager = (AudioManager) service.getContext().getSystemService(Context.AUDIO_SERVICE);
         mAudioManagerInternal = LocalServices.getService(AudioManagerInternal.class);
         mAudioAttrs = new AudioAttributes.Builder().setUsage(AudioAttributes.USAGE_MEDIA).build();
+        if((SystemProperties.get("media.stagefright.mode","true")).equals("true"))
+            mUseMasterVolume = true;
+        else
+            mUseMasterVolume = false;
     }
 
     /**
@@ -245,8 +252,27 @@
         if (isPlaybackActive(false) || hasFlag(MediaSession.FLAG_EXCLUSIVE_GLOBAL_PRIORITY)) {
             flags &= ~AudioManager.FLAG_PLAY_SOUND;
         }
+        boolean isMute = direction == AudioManager.ADJUST_TOGGLE_MUTE;
+        int userId = UserHandle.getCallingUserId();
         if (mVolumeType == PlaybackInfo.PLAYBACK_TYPE_LOCAL) {
-            // Adjust the volume with a handler not to be blocked by other system service.
+            if (mUseMasterVolume) {
+                // If this device only uses master volume and playback is local
+                // just adjust the master volume and return.
+                boolean isMasterMute = mAudioManager.isMasterMute();
+                if (isMute) {
+                    mAudioManagerInternal.setMasterMuteForUid(!isMasterMute,
+                            flags, packageName, userId, uid);
+                } else {
+                    mAudioManagerInternal.adjustMasterVolumeForUid(direction, flags, packageName,
+                            uid);
+                    if (isMasterMute) {
+                        mAudioManagerInternal.setMasterMuteForUid(false,
+                                flags, packageName, userId, uid);
+                    }
+                }
+                return;
+            }
+			// Adjust the volume with a handler not to be blocked by other system service.
             int stream = AudioAttributes.toLegacyStreamType(mAudioAttrs);
             postAdjustLocalVolume(stream, direction, flags, packageName, uid, useSuggested,
                     previousFlagPlaySound);
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/media/MediaSessionService.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/media/MediaSessionService.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/media/MediaSessionService.java	2018-08-06 15:41:05.939716494 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/media/MediaSessionService.java	2017-11-23 05:21:46.000000000 +0100
@@ -52,6 +52,8 @@
 import android.os.ResultReceiver;
 import android.os.ServiceManager;
 import android.os.UserHandle;
+import android.os.SystemProperties;
+
 import android.provider.Settings;
 import android.speech.RecognizerIntent;
 import android.text.TextUtils;
@@ -83,6 +85,7 @@
 
     private final SessionManagerImpl mSessionManagerImpl;
     private final MediaSessionStack mPriorityStack;
+	private final boolean mUseMasterVolume;
 
     private final ArrayList<MediaSessionRecord> mAllSessions = new ArrayList<MediaSessionRecord>();
     private final SparseArray<UserRecord> mUserRecords = new SparseArray<UserRecord>();
@@ -110,6 +113,11 @@
         mPriorityStack = new MediaSessionStack();
         PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
         mMediaEventWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "handleMediaEvent");
+		if((SystemProperties.get("media.stagefright.mode","true")).equals("true"))
+			mUseMasterVolume = true;
+		else
+			mUseMasterVolume = false;
+
     }
 
     @Override
@@ -899,9 +907,26 @@
                     return;
                 }
                 try {
+					if(mUseMasterVolume)
+					{
+					    String packageName = getContext().getOpPackageName();
+						boolean isMasterMute = mAudioService.isMasterMute();
+						int userId = UserHandle.getCallingUserId();
+						if (direction == AudioManager.ADJUST_TOGGLE_MUTE) {
+                            mAudioService.setMasterMute(!isMasterMute, flags, packageName, userId);
+                        } else {
+                            mAudioService.adjustMasterVolume(direction, flags, packageName);
+                            // Do not call setMasterMute when direction = 0 which is used just to
+                            // show the UI.
+                            if (isMasterMute && direction != 0) {
+                                mAudioService.setMasterMute(false, flags, packageName, userId);
+                            }
+                        }
+
+					}else{
                     String packageName = getContext().getOpPackageName();
                     mAudioService.adjustSuggestedStreamVolume(direction, suggestedStream,
-                            flags, packageName, TAG);
+                            flags, packageName, TAG);}
                 } catch (RemoteException e) {
                     Log.e(TAG, "Error adjusting default volume.", e);
                 }
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/MountService.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/MountService.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/MountService.java	2018-08-06 15:41:05.835715159 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/MountService.java	2017-11-23 05:21:46.000000000 +0100
@@ -1263,16 +1263,15 @@
         if (vol.type == VolumeInfo.TYPE_EMULATED) {
             final StorageManager storage = mContext.getSystemService(StorageManager.class);
             final VolumeInfo privateVol = storage.findPrivateForEmulated(vol);
-
             if (Objects.equals(StorageManager.UUID_PRIVATE_INTERNAL, mPrimaryStorageUuid)
                     && VolumeInfo.ID_PRIVATE_INTERNAL.equals(privateVol.id)) {
-                Slog.v(TAG, "Found primary storage at " + vol);
+                Slog.v(TAG, "1Found primary storage at " + vol);
                 vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
                 vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
                 mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
 
             } else if (Objects.equals(privateVol.fsUuid, mPrimaryStorageUuid)) {
-                Slog.v(TAG, "Found primary storage at " + vol);
+                Slog.v(TAG, "2Found primary storage at " + vol);
                 vol.mountFlags |= VolumeInfo.MOUNT_FLAG_PRIMARY;
                 vol.mountFlags |= VolumeInfo.MOUNT_FLAG_VISIBLE;
                 mHandler.obtainMessage(H_VOLUME_MOUNT, vol).sendToTarget();
@@ -1821,7 +1820,7 @@
         final CountDownLatch latch = findOrCreateDiskScanLatch(diskId);
         try {
             mConnector.execute("volume", "partition", diskId, "private");
-            waitForLatch(latch, "partitionPrivate", 3 * DateUtils.MINUTE_IN_MILLIS);
+            waitForLatch(latch, "partitionPrivate", 10 * DateUtils.MINUTE_IN_MILLIS);
         } catch (NativeDaemonConnectorException e) {
             throw e.rethrowAsParcelableException();
         } catch (TimeoutException e) {
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/NativeDaemonConnector.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/NativeDaemonConnector.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/NativeDaemonConnector.java	2018-08-06 15:41:05.835715159 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/NativeDaemonConnector.java	2017-11-23 05:21:46.000000000 +0100
@@ -136,7 +136,7 @@
                 listenToSocket();
             } catch (Exception e) {
                 loge("Error in NativeDaemonConnector: " + e);
-                SystemClock.sleep(5000);
+                SystemClock.sleep(50);
             }
         }
     }
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/pm/PackageInstallerSession.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/pm/PackageInstallerSession.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/pm/PackageInstallerSession.java	2018-08-06 15:41:05.955716700 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/pm/PackageInstallerSession.java	2017-11-23 05:21:46.000000000 +0100
@@ -731,6 +731,10 @@
             // validate split names marked for removal
             final int flags = mSignatures == null ? PackageManager.GET_SIGNATURES : 0;
             final PackageInfo pkg = mPm.getPackageInfo(params.appPackageName, flags, userId);
+			if(pkg == null){
+				throw new PackageManagerException(INSTALL_FAILED_INVALID_APK,
+                        "The PackageInfo pkg is a null object reference!");
+			}
             for (String splitName : removeSplitList) {
                 if (!ArrayUtils.contains(pkg.splitNames, splitName)) {
                     throw new PackageManagerException(INSTALL_FAILED_INVALID_APK,
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java	2018-08-06 15:41:05.999717265 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java	2017-11-23 05:21:46.000000000 +0100
@@ -253,6 +253,8 @@
 import com.android.server.pm.Settings.VersionInfo;
 import com.android.server.storage.DeviceStorageMonitorInternal;
 
+import com.android.server.pm.util.PackageDataManager;
+
 import dalvik.system.CloseGuard;
 import dalvik.system.DexFile;
 import dalvik.system.VMRuntime;
@@ -1324,6 +1326,14 @@
         private static final String USAGE_FILE_MAGIC_VERSION_1 = USAGE_FILE_MAGIC + "1";
     }
 
+    PackageDataManager pManager = null;
+    boolean pManagerPostUpdateTask = false;
+    int laterScanData = 0;
+    Set<String> dataAppScanInBoot = new HashSet<String>();
+    List<String> dataAppScanAfterBoot = null;
+    boolean mDataScaned = false;
+    static final int DATA_SCAN_FINISH= 1000;
+
     class PackageHandler extends Handler {
         private boolean mBound = false;
         final ArrayList<HandlerParams> mPendingInstalls =
@@ -2393,6 +2403,15 @@
                 }
             }
 
+            int pmsMode = SystemProperties.getInt("persist.sys.bootopt.pms", 0);
+            if (pmsMode > 0) {
+                long t = SystemClock.uptimeMillis();
+                pManager = PackageDataManager.getInstance(pmsMode);
+                pManager.waitForReadTasksFinish();
+                Slog.i(TAG, "pmanager waitForReadTasksFinish cost :" +
+                    (SystemClock.uptimeMillis() - t));
+            }
+
             File frameworkDir = new File(Environment.getRootDirectory(), "framework");
 
             final VersionInfo ver = mSettings.getInternalVersion();
@@ -2422,6 +2441,7 @@
             // (Do this before scanning any apps.)
             // For security and version matching reason, only consider
             // overlay packages if they reside in VENDOR_OVERLAY_DIR.
+            Slog.i(TAG, "scan vendor");
             File vendorOverlayDir = new File(VENDOR_OVERLAY_DIR);
             scanDirTracedLI(vendorOverlayDir, mDefParseFlags
                     | PackageParser.PARSE_IS_SYSTEM
@@ -2429,6 +2449,7 @@
                     | PackageParser.PARSE_TRUSTED_OVERLAY, scanFlags | SCAN_TRUSTED_OVERLAY, 0);
 
             // Find base frameworks (resource packages without code).
+            Slog.i(TAG, "scan framework");
             scanDirTracedLI(frameworkDir, mDefParseFlags
                     | PackageParser.PARSE_IS_SYSTEM
                     | PackageParser.PARSE_IS_SYSTEM_DIR
@@ -2436,6 +2457,7 @@
                     scanFlags | SCAN_NO_DEX, 0);
 
             // Collected privileged system packages.
+            Slog.i(TAG, "scan system priv-app");
             final File privilegedAppDir = new File(Environment.getRootDirectory(), "priv-app");
             scanDirTracedLI(privilegedAppDir, mDefParseFlags
                     | PackageParser.PARSE_IS_SYSTEM
@@ -2443,11 +2465,13 @@
                     | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, 0);
 
             // Collect ordinary system packages.
+            Slog.i(TAG, "scan system app");
             final File systemAppDir = new File(Environment.getRootDirectory(), "app");
             scanDirTracedLI(systemAppDir, mDefParseFlags
                     | PackageParser.PARSE_IS_SYSTEM
                     | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, 0);
 
+            Slog.i(TAG, "scan data app");
             // Collect all vendor packages.
             File vendorAppDir = new File("/vendor/app");
             try {
@@ -6072,6 +6096,22 @@
 
     private @NonNull List<ResolveInfo> queryIntentReceiversInternal(Intent intent,
             String resolvedType, int flags, int userId) {
+        if (pManager != null && (!pManagerPostUpdateTask) && Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {
+            pManagerPostUpdateTask = true;
+            mHandler.postDelayed(new Runnable() {
+                public void run() {
+                    Slog.i(TAG, "try update pmanager ");
+                    if (pManager.updateData(mMetrics)) {
+                        Slog.i(TAG, "finish update pmanager database");
+                        return;
+                    }
+                    Slog.i(TAG, "post update pmanager later");
+                    mHandler.postDelayed(this, 3*1000);
+               }
+               }, 3*1000);
+        }
+
+
         if (!sUserManager.exists(userId)) return Collections.emptyList();
         flags = updateFlagsForResolve(flags, userId, intent);
         ComponentName comp = intent.getComponent();
@@ -6812,24 +6852,34 @@
     private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,
             long currentTime, UserHandle user) throws PackageManagerException {
         if (DEBUG_INSTALL) Slog.d(TAG, "Parsing: " + scanFile);
-        PackageParser pp = new PackageParser();
-        pp.setSeparateProcesses(mSeparateProcesses);
-        pp.setOnlyCoreApps(mOnlyCore);
-        pp.setDisplayMetrics(mMetrics);
-
-        if ((scanFlags & SCAN_TRUSTED_OVERLAY) != 0) {
-            parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY;
-        }
+        PackageParser.Package pkg2 = null;
+        if (pManager != null) {
+            pkg2 = pManager.getPkgParserData(scanFile.getPath());
+        }
+        if (pkg2 == null) {
+            Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage");
+            Slog.i(TAG, "scan normal " + scanFile.toString());
+            try {
+                PackageParser pp = new PackageParser();
+                if ((scanFlags & SCAN_TRUSTED_OVERLAY) != 0) {
+                    parseFlags |= PackageParser.PARSE_TRUSTED_OVERLAY;
+                }
+                pp.setSeparateProcesses(mSeparateProcesses);
+                pp.setOnlyCoreApps(mOnlyCore);
+                pp.setDisplayMetrics(mMetrics);
+                pkg2 = pp.parsePackage(scanFile, parseFlags);
+            } catch (PackageParserException e) {
+                throw PackageManagerException.from(e);
+            } finally {
+                Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
+            }
 
-        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "parsePackage");
-        final PackageParser.Package pkg;
-        try {
-            pkg = pp.parsePackage(scanFile, parseFlags);
-        } catch (PackageParserException e) {
-            throw PackageManagerException.from(e);
-        } finally {
-            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
+            if (pManager != null)
+                pManager.addPkgParserData(pkg2);
+        } else {
+            Slog.i(TAG, "scan quick " + scanFile.toString());
         }
+        final PackageParser.Package pkg = pkg2;
 
         return scanPackageLI(pkg, scanFile, parseFlags, scanFlags, currentTime, user);
     }
@@ -7935,8 +7985,10 @@
             int scanFlags, long currentTime, UserHandle user) throws PackageManagerException {
         boolean success = false;
         try {
+            long t = SystemClock.uptimeMillis();
             final PackageParser.Package res = scanPackageDirtyLI(pkg, policyFlags, scanFlags,
                     currentTime, user);
+            Slog.i(TAG,"scan dirty "+pkg.packageName+" cost:"+(SystemClock.uptimeMillis()-t));
             success = true;
             return res;
         } finally {
Only in ../Desktop/android/frameworks/base/services/core/java/com/android/server/pm: util
Only in ../Desktop/android/frameworks/base/services/core/java/com/android/server/policy: TvWindowManager.java
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java	2018-08-06 15:41:06.015717470 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/power/PowerManagerService.java	2017-11-23 05:21:46.000000000 +0100
@@ -3435,7 +3435,7 @@
             mContext.enforceCallingOrSelfPermission(android.Manifest.permission.REBOOT, null);
             if (PowerManager.REBOOT_RECOVERY.equals(reason)
                     || PowerManager.REBOOT_RECOVERY_UPDATE.equals(reason)) {
-                mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null);
+                //mContext.enforceCallingOrSelfPermission(android.Manifest.permission.RECOVERY, null);
             }
 
             final long ident = Binder.clearCallingIdentity();
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/power/ShutdownThread.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/power/ShutdownThread.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/power/ShutdownThread.java	2018-08-06 15:41:06.015717470 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/power/ShutdownThread.java	2017-11-23 05:21:46.000000000 +0100
@@ -60,6 +60,8 @@
 import java.io.FileReader;
 import java.io.IOException;
 
+import com.softwinner.Gpio;
+
 public final class ShutdownThread extends Thread {
     // constants
     private static final String TAG = "ShutdownThread";
@@ -88,6 +90,9 @@
     private static boolean mRebootHasProgressBar;
     private static String mReason;
 
+	// config led status when shutdown,default to light the standby led.
+    private boolean ledShutdownAllOff = false;
+
     // Provides shutdown assurance in case the system_server is killed
     public static final String SHUTDOWN_ACTION_PROPERTY = "sys.shutdown.requested";
 
@@ -98,6 +103,8 @@
     // Indicates whether we should stay in safe mode until ro.build.date.utc is newer than this
     public static final String AUDIT_SAFEMODE_PROPERTY = "persist.sys.audit_safemode";
 
+    public static final String SHUTDOWN_FAST_PROPERTY = "sys.shutdown.hdmi";
+
     // static instance of this thread
     private static final ShutdownThread sInstance = new ShutdownThread();
 
@@ -119,7 +126,17 @@
 
     private ShutdownThread() {
     }
-
+    private void ShutdownLeds() {
+		ledShutdownAllOff = mContext.getResources().getBoolean(
+			com.android.internal.R.bool.config_ledShutdownAllOff);
+		if(ledShutdownAllOff == false) {  // standby led : on ; normal led : off
+			Gpio.setNormalLedOn(false);
+			Gpio.setStandbyLedOn(true);
+		} else {			     // all led off
+			Gpio.setNormalLedOn(false);
+			Gpio.setStandbyLedOn(false);
+		}
+	}
     /**
      * Request a clean shutdown, waiting for subsystems to clean up their
      * state etc.  Must be called from a Looper thread in which its UI
@@ -371,6 +388,7 @@
         {
             String reason = (mReboot ? "1" : "0") + (mReason != null ? mReason : "");
             SystemProperties.set(SHUTDOWN_ACTION_PROPERTY, reason);
+            SystemProperties.set(SHUTDOWN_FAST_PROPERTY, "1");
         }
 
         /*
@@ -493,7 +511,7 @@
             // done yet, trigger it now.
             uncrypt();
         }
-
+        ShutdownLeds();
         rebootOrShutdown(mContext, mReboot, mReason);
     }
 
@@ -518,18 +536,19 @@
         final boolean[] done = new boolean[1];
         Thread t = new Thread() {
             public void run() {
-                boolean nfcOff;
+                //boolean nfcOff;
                 boolean bluetoothOff;
-                boolean radioOff;
+                //boolean radioOff;
 
-                final INfcAdapter nfc =
-                        INfcAdapter.Stub.asInterface(ServiceManager.checkService("nfc"));
-                final ITelephony phone =
-                        ITelephony.Stub.asInterface(ServiceManager.checkService("phone"));
+                //final INfcAdapter nfc =
+                //        INfcAdapter.Stub.asInterface(ServiceManager.checkService("nfc"));
+                //final ITelephony phone =
+                //        ITelephony.Stub.asInterface(ServiceManager.checkService("phone"));
                 final IBluetoothManager bluetooth =
                         IBluetoothManager.Stub.asInterface(ServiceManager.checkService(
                                 BluetoothAdapter.BLUETOOTH_MANAGER_SERVICE));
-
+                final BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();
+                /*
                 try {
                     nfcOff = nfc == null ||
                              nfc.getState() == NfcAdapter.STATE_OFF;
@@ -541,9 +560,10 @@
                 Log.e(TAG, "RemoteException during NFC shutdown", ex);
                     nfcOff = true;
                 }
-
+                */
                 try {
                     bluetoothOff = bluetooth == null || !bluetooth.isEnabled();
+                    bluetoothOff = (mBluetoothAdapter == null) || (mBluetoothAdapter.getState() == BluetoothAdapter.STATE_OFF);
                     if (!bluetoothOff) {
                         Log.w(TAG, "Disabling Bluetooth...");
                         bluetooth.disable(false);  // disable but don't persist new state
@@ -552,7 +572,7 @@
                     Log.e(TAG, "RemoteException during bluetooth shutdown", ex);
                     bluetoothOff = true;
                 }
-
+                /*
                 try {
                     radioOff = phone == null || !phone.needMobileRadioShutdown();
                     if (!radioOff) {
@@ -563,8 +583,9 @@
                     Log.e(TAG, "RemoteException during radio shutdown", ex);
                     radioOff = true;
                 }
-
-                Log.i(TAG, "Waiting for NFC, Bluetooth and Radio...");
+                */
+                //Log.i(TAG, "Waiting for NFC, Bluetooth and Radio...");
+                Log.i(TAG, "Waiting for Bluetooth");
 
                 long delay = endTime - SystemClock.elapsedRealtime();
                 while (delay > 0) {
@@ -578,6 +599,7 @@
                     if (!bluetoothOff) {
                         try {
                             bluetoothOff = !bluetooth.isEnabled();
+                            bluetoothOff = (mBluetoothAdapter.getState() == BluetoothAdapter.STATE_OFF);
                         } catch (RemoteException ex) {
                             Log.e(TAG, "RemoteException during bluetooth shutdown", ex);
                             bluetoothOff = true;
@@ -586,6 +608,7 @@
                             Log.i(TAG, "Bluetooth turned off.");
                         }
                     }
+                    /*
                     if (!radioOff) {
                         try {
                             radioOff = !phone.needMobileRadioShutdown();
@@ -608,9 +631,11 @@
                             Log.i(TAG, "NFC turned off.");
                         }
                     }
-
-                    if (radioOff && bluetoothOff && nfcOff) {
-                        Log.i(TAG, "NFC, Radio and Bluetooth shutdown complete.");
+                    */
+                    //if (radioOff && bluetoothOff && nfcOff) {
+                    if (bluetoothOff) {
+                        //Log.i(TAG, "NFC, Radio and Bluetooth shutdown complete.");
+                        Log.i(TAG, "Bluetooth shutdown complete.");
                         done[0] = true;
                         break;
                     }
@@ -645,7 +670,8 @@
             PowerManagerService.lowLevelReboot(reason);
             Log.e(TAG, "Reboot failed, will attempt shutdown instead");
             reason = null;
-        } else if (SHUTDOWN_VIBRATE_MS > 0 && context != null) {
+        }
+        /*else if (SHUTDOWN_VIBRATE_MS > 0 && context != null) {
             // vibrate before shutting down
             Vibrator vibrator = new SystemVibrator(context);
             try {
@@ -661,6 +687,7 @@
             } catch (InterruptedException unused) {
             }
         }
+        */
 
         // Shutdown power
         Log.i(TAG, "Performing low-level shutdown...");
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/wallpaper/WallpaperManagerService.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/wallpaper/WallpaperManagerService.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/wallpaper/WallpaperManagerService.java	2018-08-06 15:41:06.023717573 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/wallpaper/WallpaperManagerService.java	2017-11-23 05:21:46.000000000 +0100
@@ -67,6 +67,7 @@
 import android.os.SELinux;
 import android.os.ServiceManager;
 import android.os.SystemClock;
+import android.os.SystemProperties;
 import android.os.UserHandle;
 import android.os.UserManager;
 import android.service.wallpaper.IWallpaperConnection;
@@ -1984,9 +1985,16 @@
         if (wallpaper.width < baseSize) {
             wallpaper.width = baseSize;
         }
-        if (wallpaper.height < baseSize) {
-            wallpaper.height = baseSize;
-        }
+	if(!SystemProperties.getBoolean("media.stagefright.mode",false)){
+		if (wallpaper.height < 1080) {
+           	 wallpaper.height = 1080;
+        	}
+	}else{
+
+        	if (wallpaper.height < baseSize) {
+            	 wallpaper.height = baseSize;
+        	}
+	}
         // and crop, if not previously specified
         if (wallpaper.cropHint.width() <= 0
                 || wallpaper.cropHint.height() <= 0) {
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/WiredAccessoryManager.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/WiredAccessoryManager.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/WiredAccessoryManager.java	2018-08-06 15:41:05.839715210 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/WiredAccessoryManager.java	2017-11-23 05:21:46.000000000 +0100
@@ -357,7 +357,7 @@
             List<UEventInfo> retVal = new ArrayList<UEventInfo>();
             UEventInfo uei;
 
-            // Monitor h2w
+/*            // Monitor h2w
             if (!mUseDevInputEventForAudioJack) {
                 uei = new UEventInfo(NAME_H2W, BIT_HEADSET, BIT_HEADSET_NO_MIC, BIT_LINEOUT);
                 if (uei.checkSwitchExists()) {
@@ -394,7 +394,7 @@
                     Slog.w(TAG, "This kernel does not have HDMI audio support");
                 }
             }
-
+*/
             return retVal;
         }
 
diff -ur ../aosp/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java ../Desktop/android/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
--- ../aosp/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java	2018-08-06 15:41:06.043717829 +0200
+++ ../Desktop/android/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java	2017-11-23 05:21:46.000000000 +0100
@@ -140,6 +140,7 @@
 import com.android.server.Watchdog;
 import com.android.server.input.InputManagerService;
 import com.android.server.policy.PhoneWindowManager;
+import com.android.server.policy.TvWindowManager;
 import com.android.server.power.ShutdownThread;
 
 import java.io.BufferedWriter;
@@ -383,7 +384,7 @@
 
     final boolean mLimitedAlphaCompositing;
 
-    final WindowManagerPolicy mPolicy = new PhoneWindowManager();
+    final WindowManagerPolicy mPolicy = new TvWindowManager();
 
     final IActivityManager mActivityManager;
     final ActivityManagerInternal mAmInternal;
@@ -3726,7 +3727,7 @@
     boolean updateOrientationFromAppTokensLocked(boolean inTransaction) {
         long ident = Binder.clearCallingIdentity();
         try {
-            int req = getOrientationLocked();
+            int req = "1".equals(SystemProperties.get("ro.sf.disablerotation","0"))?ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:getOrientationLocked();
             if (req != mForcedAppOrientation) {
                 mForcedAppOrientation = req;
                 //send a message to Policy indicating orientation change to take
@@ -10079,6 +10080,33 @@
     public boolean isSafeModeEnabled() {
         return mSafeMode;
     }
+    //support mouse mode
+    public void keyEnterMouseMode()
+    {
+        Log.d(TAG,"keyEnterMouseMode");
+        mInputManager.KeyEnterMouseMode();
+    }
+
+    public void keyExitMouseMode()
+    {
+        Log.d(TAG,"keyExitMouseMode");
+        mInputManager.KeyExitMouseMode();
+    }
+
+    public void keySetMouseMoveCode(int left,int right,int top,int bottom)
+    {
+        mInputManager.KeySetMouseMoveCode(left,right,top,bottom);
+    }
+
+    public void keySetMouseBtnCode(int leftbtn,int midbtn,int rightbtn)
+    {
+        mInputManager.KeySetMouseBtnCode(leftbtn,midbtn,rightbtn);
+    }
+
+    public void keySetMouseDistance(int distance)
+    {
+        mInputManager.KeySetMouseDistance(distance);
+    }
 
     @Override
     public boolean clearWindowContentFrameStats(IBinder token) {
diff -ur ../aosp/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp ../Desktop/android/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp
--- ../aosp/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp	2018-08-06 15:41:06.055717983 +0200
+++ ../Desktop/android/frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp	2017-11-23 05:21:46.000000000 +0100
@@ -1371,6 +1371,36 @@
 
     im->setShowTouches(enabled);
 }
+//support mouse mode
+static void android_server_InputManager_nativeKeyEnterMouseMode(JNIEnv* env, jclass clazz, jlong ptr)
+{
+    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);
+    im->getInputManager()->getReader()->keyEnterMouseMode();
+}
+
+static void android_server_InputManager_nativeKeyExitMouseMode(JNIEnv* env, jclass clazz, jlong ptr)
+{
+    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);
+    im->getInputManager()->getReader()->keyExitMouseMode();
+}
+
+static void android_server_InputManager_nativeKeySetMouseBtnCode(JNIEnv* env, jclass clazz,jlong ptr,jint leftbtn,jint midbtn,jint rightbtn)
+{
+    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);
+    im->getInputManager()->getReader()->keySetMouseBtnCode((int)leftbtn,(int)midbtn,(int)rightbtn);
+}
+
+static void android_server_InputManager_nativeKeySetMouseDistance(JNIEnv* env, jclass clazz,jlong ptr,jint distance)
+{
+    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);
+    im->getInputManager()->getReader()->keySetMouseDistance((int)distance);
+}
+
+static void android_server_InputManager_nativeKeySetMouseMoveCode(JNIEnv* env, jclass clazz,jlong ptr,jint left,jint right,jint top,jint bottom)
+{
+    NativeInputManager* im = reinterpret_cast<NativeInputManager*>(ptr);
+    im->getInputManager()->getReader()->keySetMouseMoveCode((int)left,(int)right,(int)top,(int)bottom);
+}
 
 static void nativeSetInteractive(JNIEnv* env,
         jclass clazz, jlong ptr, jboolean interactive) {
@@ -1537,6 +1567,17 @@
             (void*) nativeReloadPointerIcons },
     { "nativeSetCustomPointerIcon", "(JLandroid/view/PointerIcon;)V",
             (void*) nativeSetCustomPointerIcon },
+    //support mouse mode
+    { "nativeKeyEnterMouseMode", "(J)V",
+            (void*) android_server_InputManager_nativeKeyEnterMouseMode},
+    { "nativeKeyExitMouseMode", "(J)V",
+            (void*) android_server_InputManager_nativeKeyExitMouseMode},
+    { "nativeKeySetMouseDistance", "(JI)V",
+            (void*) android_server_InputManager_nativeKeySetMouseDistance},
+    { "nativeKeySetMouseMoveCode", "(JIIII)V",
+            (void*) android_server_InputManager_nativeKeySetMouseMoveCode},
+    { "nativeKeySetMouseBtnCode", "(JIII)V",
+            (void*) android_server_InputManager_nativeKeySetMouseBtnCode},
 };
 
 #define FIND_CLASS(var, className) \
diff -ur ../aosp/frameworks/base/services/java/com/android/server/SystemServer.java ../Desktop/android/frameworks/base/services/java/com/android/server/SystemServer.java
--- ../aosp/frameworks/base/services/java/com/android/server/SystemServer.java	2018-08-06 15:41:06.083718343 +0200
+++ ../Desktop/android/frameworks/base/services/java/com/android/server/SystemServer.java	2017-11-23 05:21:46.000000000 +0100
@@ -47,6 +47,9 @@
 import android.util.EventLog;
 import android.util.Slog;
 import android.view.WindowManager;
+import android.app.PackageInstallObserver;
+import android.content.pm.VerificationParams;
+import android.net.Uri;
 
 import com.android.internal.R;
 import com.android.internal.os.BinderInternal;
@@ -61,6 +64,7 @@
 import com.android.server.connectivity.MetricsLoggerService;
 import com.android.server.devicepolicy.DevicePolicyManagerService;
 import com.android.server.display.DisplayManagerService;
+import com.android.server.DisplayOutputManagerService;
 import com.android.server.dreams.DreamManagerService;
 import com.android.server.fingerprint.FingerprintService;
 import com.android.server.hdmi.HdmiControlService;
@@ -94,6 +98,7 @@
 import com.android.server.tv.TvInputManagerService;
 import com.android.server.twilight.TwilightService;
 import com.android.server.usage.UsageStatsService;
+import com.android.server.usb.UsbCameraDeviceManagerObserver;
 import com.android.server.vr.VrManagerService;
 import com.android.server.webkit.WebViewUpdateService;
 import com.android.server.wm.WindowManagerService;
@@ -106,6 +111,7 @@
 import java.util.Timer;
 import java.util.TimerTask;
 
+import com.android.server.pm.util.PackageDataManager;
 public final class SystemServer {
     private static final String TAG = "SystemServer";
 
@@ -161,6 +167,10 @@
     private static final String WALLPAPER_SERVICE_CLASS =
             "com.android.server.wallpaper.WallpaperManagerService$Lifecycle";
 
+    /*add by zhaokai for pppoe,2016.10.27*/
+    private static final String PPPOE_SERVICE_CLASS =
+            "com.android.server.pppoe.PppoeService";
+
     private static final String PERSISTENT_DATA_BLOCK_PROP = "ro.frp.pst";
 
     private static final String UNCRYPT_PACKAGE_FILE = "/cache/recovery/uncrypt_file";
@@ -216,6 +226,9 @@
 
     private void run() {
         try {
+            android.os.Process.setThreadPriority(
+                android.os.Process.THREAD_PRIORITY_URGENT_AUDIO);
+
             Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, "InitBeforeStartServices");
             // If a device's clock is before 1970 (before 0), a lot of
             // APIs crash dealing with negative numbers, notably
@@ -294,8 +307,6 @@
             BinderInternal.setMaxThreads(sMaxBinderThreads);
 
             // Prepare the main looper thread (this thread).
-            android.os.Process.setThreadPriority(
-                android.os.Process.THREAD_PRIORITY_FOREGROUND);
             android.os.Process.setCanSelfBackground(false);
             Looper.prepareMainLooper();
 
@@ -312,6 +323,16 @@
             // Create the system service manager.
             mSystemServiceManager = new SystemServiceManager(mSystemContext);
             LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
+
+            int pmsMode = SystemProperties.getInt("persist.sys.bootopt.pms", 0);
+            Slog.i(TAG, "read pmsmode :"+ pmsMode);
+            if (pmsMode > 0) {
+                long t = SystemClock.uptimeMillis();
+                PackageDataManager pManager = PackageDataManager.getInstance(pmsMode);
+                pManager.readData();
+                Slog.i(TAG, "read pmanager cost :"+ (SystemClock.uptimeMillis()-t));
+            }
+
         } finally {
             Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
         }
@@ -334,7 +355,8 @@
         if (StrictMode.conditionallyEnableDebugLogging()) {
             Slog.i(TAG, "Enabled StrictMode for system server main thread.");
         }
-
+        android.os.Process.setThreadPriority(
+                android.os.Process.THREAD_PRIORITY_FOREGROUND);
         // Loop forever.
         Looper.loop();
         throw new RuntimeException("Main thread loop unexpectedly exited");
@@ -482,6 +504,25 @@
         // The sensor service needs access to package manager service, app ops
         // service, and permissions service, therefore we start it after them.
         startSensorService();
+        if (mFirstBoot)
+            preinstall("/system/preinstall");
+    }
+
+    private void preinstall(String path) {
+        Slog.i(TAG, "preinstall start");
+        if (path == null) {
+            return;
+        }
+        File[] files = new File(path).listFiles();
+        if (files == null) {
+            return;
+        }
+        for (File apkFile : files) {
+            String apkFilePath = Uri.fromFile(apkFile).getPath();
+            Slog.i(TAG, "preinstall apk " + apkFilePath);
+            PackageInstallObserver obs = new PackageInstallObserver();
+            mPackageManagerService.installPackageAsUser(apkFilePath, obs.getBinder(), 0, null, mSystemContext.getUserId());
+        }
     }
 
     /**
@@ -600,6 +641,15 @@
             watchdog.init(context, mActivityManagerService);
             Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
 
+            traceBeginAndSlog("DisplayOutputManagerService");
+            try {
+              ServiceManager.addService(Context.DISPLAYOUTPUT_SERVICE,
+                       new DisplayOutputManagerService(context));
+            } catch (Throwable e) {
+              reportWtf("starting DisplayOutputManagerService Manager", e);
+            }
+            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
+
             traceBeginAndSlog("StartInputManagerService");
             inputManager = new InputManagerService(context);
             Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
@@ -836,7 +886,11 @@
                     mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
                     mSystemServiceManager.startService(ETHERNET_SERVICE_CLASS);
                 }
-
+                /*add by zhaokai for pppoe,2016.10.27*/
+               if (mPackageManager.hasSystemFeature(PackageManager.FEATURE_PPPOE) ||
+                    mPackageManager.hasSystemFeature(PackageManager.FEATURE_USB_HOST)) {
+                    mSystemServiceManager.startService(PPPOE_SERVICE_CLASS);
+                }
                 traceBeginAndSlog("StartConnectivityService");
                 try {
                     connectivity = new ConnectivityService(
@@ -955,6 +1009,13 @@
             } catch (Throwable e) {
                 reportWtf("starting WiredAccessoryManager", e);
             }
+            try {
+                Slog.i(TAG, "Audio device manager Observer");
+                // Listen for wired headset changes
+                AudioDeviceManagerObserver.getInstance(context);
+            } catch (Throwable e) {
+                reportWtf("starting AudioDeviceManagerObserver", e);
+            }
             Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
 
             if (!disableNonCoreServices) {
@@ -971,7 +1032,15 @@
                     mSystemServiceManager.startService(USB_SERVICE_CLASS);
                     Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);
                 }
-
+                //add by fuqiang for usb camera hot plug, start
+                try {
+                    Slog.d(TAG, "Usb Camera device manager Observer");
+                    // Listen for wired headset changes
+                    UsbCameraDeviceManagerObserver.getInstance(context);
+                } catch (Throwable e) {
+                    Slog.e(TAG, "Failture starting UsbCameraDeviceManagerObserver", e);
+                }
+                //add by fuqiang for usb camera hot plug, end
                 if (!disableSerial) {
                     traceBeginAndSlog("StartSerialService");
                     try {
Only in ../Desktop/android/frameworks/base/services/usb/java/com/android/server/usb: UsbCameraDeviceManagerObserver.java
diff -ur ../aosp/frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java ../Desktop/android/frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java
--- ../aosp/frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java	2018-08-06 15:41:06.131718959 +0200
+++ ../Desktop/android/frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java	2017-11-23 05:21:46.000000000 +0100
@@ -37,6 +37,7 @@
 import android.os.Looper;
 import android.os.Message;
 import android.os.ParcelFileDescriptor;
+import android.os.PowerManager;
 import android.os.SystemClock;
 import android.os.SystemProperties;
 import android.os.UEventObserver;
@@ -150,6 +151,8 @@
     private UsbDebuggingManager mDebuggingManager;
     private final UsbAlsaManager mUsbAlsaManager;
     private Intent mBroadcastedIntent;
+    private PowerManager.WakeLock wl;
+    private int wlref = 0;
 
     private class AdbSettingsObserver extends ContentObserver {
         public AdbSettingsObserver() {
@@ -191,6 +194,13 @@
         }
     };
 
+    private void initUsb0State(){
+        if(SystemProperties.getInt("persist.sys.usb0device",0)==1){
+            Slog.d(TAG,"start usb0 as device");
+            SystemProperties.set("persist.sys.usb0device","1");
+        }
+    }
+
     public UsbDeviceManager(Context context, UsbAlsaManager alsaManager) {
         mContext = context;
         mUsbAlsaManager = alsaManager;
@@ -198,6 +208,10 @@
         PackageManager pm = mContext.getPackageManager();
         mHasUsbAccessory = pm.hasSystemFeature(PackageManager.FEATURE_USB_ACCESSORY);
         initRndisAddress();
+	initUsb0State();
+
+        PowerManager power = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+        wl = power.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, TAG);
 
         readOemUsbOverrideConfig();
 
@@ -223,6 +237,21 @@
         }
     }
 
+    private void enableWakeLock(boolean enable){
+        Slog.d(TAG,"enableWakeLock " + enable);
+        if (enable) {
+            if (wlref == 0) {
+                wlref++;
+                wl.acquire();
+            }
+        } else {
+            if (wlref == 1) {
+                wl.release();
+                wlref--;
+            }
+        }
+    }
+
     public void systemReady() {
         if (DEBUG) Slog.d(TAG, "systemReady");
 
@@ -699,6 +728,7 @@
                 case MSG_UPDATE_STATE:
                     mConnected = (msg.arg1 == 1);
                     mConfigured = (msg.arg2 == 1);
+                    enableWakeLock(mConnected);
                     if (!mConnected) {
                         // When a disconnect occurs, relock access to sensitive user data
                         mUsbDataUnlocked = false;
diff -ur ../aosp/frameworks/base/telephony/java/android/telephony/TelephonyManager.java ../Desktop/android/frameworks/base/telephony/java/android/telephony/TelephonyManager.java
--- ../aosp/frameworks/base/telephony/java/android/telephony/TelephonyManager.java	2018-08-06 15:41:06.191719729 +0200
+++ ../Desktop/android/frameworks/base/telephony/java/android/telephony/TelephonyManager.java	2017-11-23 05:21:46.000000000 +0100
@@ -1107,6 +1107,10 @@
         if (!isVoiceCapable()) {
             return PHONE_TYPE_NONE;
         }
+        if(SystemProperties.getBoolean("ro.telephony.disable",false)){
+	    Log.d(TAG,"return PHONE_TYPE_NONE on TV device");
+            return PHONE_TYPE_NONE;
+	}
         return getCurrentPhoneType();
     }
 
diff -ur ../aosp/frameworks/base/tools/layoutlib/bridge/src/android/view/IWindowManagerImpl.java ../Desktop/android/frameworks/base/tools/layoutlib/bridge/src/android/view/IWindowManagerImpl.java
--- ../aosp/frameworks/base/tools/layoutlib/bridge/src/android/view/IWindowManagerImpl.java	2018-08-06 15:41:06.511723837 +0200
+++ ../Desktop/android/frameworks/base/tools/layoutlib/bridge/src/android/view/IWindowManagerImpl.java	2017-11-23 05:21:47.000000000 +0100
@@ -536,6 +536,26 @@
         // TODO Auto-generated method stub
         return null;
     }
+    //support mouse mode
+    public void keyEnterMouseMode(){
+
+    }
+
+    public void keyExitMouseMode(){
+
+    }
+
+    public void keySetMouseMoveCode(int left,int right,int top,int bottom){
+
+    }
+
+    public void keySetMouseBtnCode(int leftbtn,int midbtn,int rightbtn){
+
+    }
+
+    public void keySetMouseDistance(int distance){
+
+    }
 
     @Override
     public int getDockedStackSide() throws RemoteException {
diff -ur ../aosp/frameworks/base/tools/layoutlib/bridge/src/com/android/layoutlib/bridge/android/view/WindowManagerImpl.java ../Desktop/android/frameworks/base/tools/layoutlib/bridge/src/com/android/layoutlib/bridge/android/view/WindowManagerImpl.java
--- ../aosp/frameworks/base/tools/layoutlib/bridge/src/com/android/layoutlib/bridge/android/view/WindowManagerImpl.java	2018-08-06 15:41:06.519723939 +0200
+++ ../Desktop/android/frameworks/base/tools/layoutlib/bridge/src/com/android/layoutlib/bridge/android/view/WindowManagerImpl.java	2017-11-23 05:21:47.000000000 +0100
@@ -68,4 +68,24 @@
     public void requestAppKeyboardShortcuts(
             KeyboardShortcutsReceiver receiver, int deviceId) {
     }
+    //support mouse mode
+    public void keyEnterMouseMode(){
+
+    }
+
+    public void keyExitMouseMode(){
+
+    }
+
+    public void keySetMouseMoveCode(int left,int right,int top,int bottom){
+
+    }
+
+    public void keySetMouseBtnCode(int leftbtn,int midbtn,int rightbtn){
+
+    }
+
+    public void keySetMouseDistance(int distance){
+
+    }
 }
Only in ../Desktop/android/frameworks/native/data/etc: android.hardware.type.television.xml
Only in ../Desktop/android/frameworks/native/data/etc: android.software.leanback.xml
Only in ../Desktop/android/frameworks/native/data/etc: android.software.pppoe.xml
Only in ../Desktop/android/frameworks/native/data/etc: tv_core_hardware.xml
Only in ../Desktop/android/frameworks/native/include/android: input_addon.h
diff -ur ../aosp/frameworks/native/include/android/keycodes.h ../Desktop/android/frameworks/native/include/android/keycodes.h
--- ../aosp/frameworks/native/include/android/keycodes.h	2018-08-06 15:41:16.755855320 +0200
+++ ../Desktop/android/frameworks/native/include/android/keycodes.h	2017-11-23 05:21:51.000000000 +0100
@@ -757,7 +757,44 @@
     /** Copy key. */
     AKEYCODE_COPY = 278,
     /** Paste key. */
-    AKEYCODE_PASTE = 279
+    AKEYCODE_PASTE = 279,
+    // add for karaok by linjunqian
+    AKEYCODE_MIC_VOLUME_UP   = 370,
+    AKEYCODE_MIC_VOLUME_DOWN = 371,
+    AKEYCODE_KOUT_VOLUME_UP  = 372,
+    AKEYCODE_KOUT_VOLUME_DOWN = 373,
+
+    //HISENSE SECTION,RANG 4201-4300
+    AKEYCODE_HISENSE_FAC_NEC_OK = 4213,
+    AKEYCODE_HISENSE_FAC_NEC_MAC = 4214,
+    AKEYCODE_HISENSE_FAC_NEC_IP = 4215,
+    AKEYCODE_HISENSE_FAC_NEC_M = 4315,
+    AKEYCODE_HISENSE_FAC_NEC_AGING = 4313,
+    AKEYCODE_HISENSE_FAC_NEC_DMP = 4312,
+    AKEYCODE_PRE = 4307,
+    AKEYCODE_NEXT = 4308,
+    AKEYCODE_HISENSE_FAVOURITE_APP = 4229,
+    AKEYCODE_HISENSE_MEDIA_CENTRE = 4320,
+    AKEYCODE_HISENSE_EDUCATION = 4321,
+    AKEYCODE_HISENSE_SHOPPING = 4322,
+
+    /* add by Gary. start {{----------------------------------- */
+    /* 2011-10-27 */
+    /* add some new keys for TVD */
+    AKEYCODE_TV_SYSTEM       = 10000,
+    AKEYCODE_GOTO            = 10001,
+    AKEYCODE_SUBTITLE        = 10002,
+    AKEYCODE_AUDIO           = 10003,
+    AKEYCODE_ZOOM            = 10004,
+    AKEYCODE_FAVOURITE       = 10006,
+    AKEYCODE_LOOP            = 10007,
+    AKEYCODE_EXPAND          = 10008,
+    AKEYCODE_MOUSE           = 10009,
+    AKEYCODE_MOVIE           = 10010,
+    AKEYCODE_APPS            = 10011,
+    AKEYCODE_BROWSER         = 10012,
+    AKEYCODE_SCREENSHOT      = 10013,
+    /* add by Gary. end   -----------------------------------}} */
 
     // NOTE: If you add a new keycode here you must also add it to several other files.
     //       Refer to frameworks/base/core/java/android/view/KeyEvent.java for the full list.
diff -ur ../aosp/frameworks/native/include/gui/BufferQueueConsumer.h ../Desktop/android/frameworks/native/include/gui/BufferQueueConsumer.h
--- ../aosp/frameworks/native/include/gui/BufferQueueConsumer.h	2018-08-06 15:41:16.775855577 +0200
+++ ../Desktop/android/frameworks/native/include/gui/BufferQueueConsumer.h	2017-11-23 05:21:51.000000000 +0100
@@ -133,6 +133,9 @@
     // NATIVE_WINDOW_TRANSFORM_ROT_90.  The default is 0 (no transform).
     virtual status_t setTransformHint(uint32_t hint);
 
+	// checkin the next expectedPresent of consumer for producer to drop buffer
+	virtual status_t setNextExpectedPresent(nsecs_t expectedPresent);
+
     // Retrieve the sideband buffer stream, if any.
     virtual sp<NativeHandle> getSidebandStream() const;
 
diff -ur ../aosp/frameworks/native/include/gui/BufferQueueCore.h ../Desktop/android/frameworks/native/include/gui/BufferQueueCore.h
--- ../aosp/frameworks/native/include/gui/BufferQueueCore.h	2018-08-06 15:41:16.775855577 +0200
+++ ../Desktop/android/frameworks/native/include/gui/BufferQueueCore.h	2017-11-23 05:21:51.000000000 +0100
@@ -324,6 +324,7 @@
 
     const uint64_t mUniqueId;
 
+    nsecs_t mConsumerNextExpectedPresent;
 }; // class BufferQueueCore
 
 } // namespace android
diff -ur ../aosp/frameworks/native/include/gui/GLConsumer.h ../Desktop/android/frameworks/native/include/gui/GLConsumer.h
--- ../aosp/frameworks/native/include/gui/GLConsumer.h	2018-08-06 15:41:16.775855577 +0200
+++ ../Desktop/android/frameworks/native/include/gui/GLConsumer.h	2017-11-23 05:21:51.000000000 +0100
@@ -187,6 +187,8 @@
     // ready to be read from.
     sp<Fence> getCurrentFence() const;
 
+    android_dataspace_t getCurrentDataSpace() const;
+
     // doGLFenceWait inserts a wait command into the OpenGL ES command stream
     // to ensure that it is safe for future OpenGL ES commands to access the
     // current texture buffer.
@@ -398,6 +400,8 @@
     // mCurrentFence is the fence received from BufferQueue in updateTexImage.
     sp<Fence> mCurrentFence;
 
+    android_dataspace_t mCurrentDataSpace;
+
     // mCurrentTransformMatrix is the transform matrix for the current texture.
     // It gets computed by computeTransformMatrix each time updateTexImage is
     // called.
diff -ur ../aosp/frameworks/native/include/gui/IGraphicBufferConsumer.h ../Desktop/android/frameworks/native/include/gui/IGraphicBufferConsumer.h
--- ../aosp/frameworks/native/include/gui/IGraphicBufferConsumer.h	2018-08-06 15:41:16.775855577 +0200
+++ ../Desktop/android/frameworks/native/include/gui/IGraphicBufferConsumer.h	2017-11-23 05:21:51.000000000 +0100
@@ -268,6 +268,8 @@
     // dump state into a string
     virtual void dump(String8& result, const char* prefix) const = 0;
 
+    virtual status_t setNextExpectedPresent(nsecs_t expectedPresent) = 0;
+
 public:
     DECLARE_META_INTERFACE(GraphicBufferConsumer);
 };
diff -ur ../aosp/frameworks/native/include/input/InputEventLabels.h ../Desktop/android/frameworks/native/include/input/InputEventLabels.h
--- ../aosp/frameworks/native/include/input/InputEventLabels.h	2018-08-06 15:41:16.779855628 +0200
+++ ../Desktop/android/frameworks/native/include/input/InputEventLabels.h	2017-11-23 05:21:51.000000000 +0100
@@ -319,7 +319,45 @@
     DEFINE_KEYCODE(CUT),
     DEFINE_KEYCODE(COPY),
     DEFINE_KEYCODE(PASTE),
+	DEFINE_KEYCODE(MIC_VOLUME_UP),
+    DEFINE_KEYCODE(MIC_VOLUME_DOWN),
+    DEFINE_KEYCODE(KOUT_VOLUME_UP),
+    DEFINE_KEYCODE(KOUT_VOLUME_DOWN),
 
+
+    //HISENSE SECTION,RANG 4201-4300
+    DEFINE_KEYCODE(HISENSE_FAC_NEC_OK),
+    DEFINE_KEYCODE(HISENSE_FAC_NEC_MAC),
+    DEFINE_KEYCODE(HISENSE_FAC_NEC_IP),
+    DEFINE_KEYCODE(HISENSE_FAC_NEC_M),
+    DEFINE_KEYCODE(HISENSE_FAC_NEC_AGING),
+    DEFINE_KEYCODE(HISENSE_FAC_NEC_DMP),
+    DEFINE_KEYCODE(PRE),
+    DEFINE_KEYCODE(NEXT),
+    DEFINE_KEYCODE(HISENSE_FAVOURITE_APP),
+    DEFINE_KEYCODE(HISENSE_MEDIA_CENTRE),
+    DEFINE_KEYCODE(HISENSE_EDUCATION),
+    DEFINE_KEYCODE(HISENSE_SHOPPING),
+
+
+    /* add by Gary. start {{----------------------------------- */
+    /* 2011-10-27 */
+    /* add some new keys for TVD */
+    DEFINE_KEYCODE(TV_SYSTEM),
+    DEFINE_KEYCODE(GOTO),
+    DEFINE_KEYCODE(SUBTITLE),
+    DEFINE_KEYCODE(AUDIO),
+    DEFINE_KEYCODE(ZOOM),
+    DEFINE_KEYCODE(FAVOURITE),
+    DEFINE_KEYCODE(LOOP),
+    DEFINE_KEYCODE(EXPAND),
+    DEFINE_KEYCODE(MOUSE),
+    DEFINE_KEYCODE(MOVIE),
+    DEFINE_KEYCODE(APPS),
+    DEFINE_KEYCODE(BROWSER),
+    DEFINE_KEYCODE(SCREENSHOT),
+    DEFINE_KEYCODE(MOUSE),
+    DEFINE_KEYCODE(SCREENSHOT),
     { NULL, 0 }
 };
 
diff -ur ../aosp/frameworks/native/include/media/openmax/OMX_Video.h ../Desktop/android/frameworks/native/include/media/openmax/OMX_Video.h
--- ../aosp/frameworks/native/include/media/openmax/OMX_Video.h	2018-08-06 15:41:16.791855782 +0200
+++ ../Desktop/android/frameworks/native/include/media/openmax/OMX_Video.h	2017-11-23 05:21:51.000000000 +0100
@@ -66,6 +66,18 @@
 #include <OMX_IVCommon.h>
 
 
+#define AW_VIDEO_AFBC_FLAG  (0x01)
+#define AW_VIDEO_HDR_FLAG   (0x02)
+#define AW_VIDEO_10BIT_FLAG (0x04)
+
+//* extend by aw
+typedef struct AW_OMX_VIDEO_HDR_INFO{
+    OMX_U32 nExtVideoFullRangeFlag;
+    OMX_U32 nExtTransferCharacteristics;
+    OMX_U32 nExtMatrixCoeffs;
+}AW_OMX_VIDEO_HDR_INFO;
+
+
 /**
  * Enumeration used to define the possible video compression codings.
  * NOTE:  This essentially refers to file extensions. If the coding is
@@ -89,8 +101,21 @@
     OMX_VIDEO_CodingVP9,        /**< Google VP9 */
     OMX_VIDEO_CodingHEVC,       /**< ITU H.265/HEVC */
     OMX_VIDEO_CodingDolbyVision,/**< Dolby Vision */
+
     OMX_VIDEO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
     OMX_VIDEO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+
+    OMX_VIDEO_CodingVP6,
+    OMX_VIDEO_CodingMPEG1,
+    OMX_VIDEO_CodingS263,
+    OMX_VIDEO_CodingMSMPEG4V1,
+    OMX_VIDEO_CodingMSMPEG4V2,
+    OMX_VIDEO_CodingDIVX,
+    OMX_VIDEO_CodingXVID,
+    OMX_VIDEO_CodingRXG2,
+    OMX_VIDEO_CodingWMV1,
+    OMX_VIDEO_CodingWMV2,
+
     OMX_VIDEO_CodingMax = 0x7FFFFFFF
 } OMX_VIDEO_CODINGTYPE;
 
diff -ur ../aosp/frameworks/native/libs/binder/ProcessState.cpp ../Desktop/android/frameworks/native/libs/binder/ProcessState.cpp
--- ../aosp/frameworks/native/libs/binder/ProcessState.cpp	2018-08-06 15:41:16.803855936 +0200
+++ ../Desktop/android/frameworks/native/libs/binder/ProcessState.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -42,7 +42,7 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 
-#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2))
+#define BINDER_VM_SIZE ((5*1024*1024) - (4096 *2))
 #define DEFAULT_MAX_BINDER_THREADS 15
 
 // -------------------------------------------------------------------------
diff -ur ../aosp/frameworks/native/libs/gui/BufferQueueConsumer.cpp ../Desktop/android/frameworks/native/libs/gui/BufferQueueConsumer.cpp
--- ../aosp/frameworks/native/libs/gui/BufferQueueConsumer.cpp	2018-08-06 15:41:16.827856245 +0200
+++ ../Desktop/android/frameworks/native/libs/gui/BufferQueueConsumer.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -732,4 +732,11 @@
     }
 }
 
+status_t BufferQueueConsumer::setNextExpectedPresent(nsecs_t expectedPresent) {
+    BQ_LOGV("setNextExpectedPresent: %" PRId64, expectedPresent);
+    Mutex::Autolock lock(mCore->mMutex);
+    mCore->mConsumerNextExpectedPresent = expectedPresent;
+    return NO_ERROR;
+}
+
 } // namespace android
diff -ur ../aosp/frameworks/native/libs/gui/BufferQueueCore.cpp ../Desktop/android/frameworks/native/libs/gui/BufferQueueCore.cpp
--- ../aosp/frameworks/native/libs/gui/BufferQueueCore.cpp	2018-08-06 15:41:16.827856245 +0200
+++ ../Desktop/android/frameworks/native/libs/gui/BufferQueueCore.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -89,7 +89,8 @@
     mSharedBufferSlot(INVALID_BUFFER_SLOT),
     mSharedBufferCache(Rect::INVALID_RECT, 0, NATIVE_WINDOW_SCALING_MODE_FREEZE,
             HAL_DATASPACE_UNKNOWN),
-    mUniqueId(getUniqueId())
+    mUniqueId(getUniqueId()),
+    mConsumerNextExpectedPresent(0)
 {
     if (allocator == NULL) {
         sp<ISurfaceComposer> composer(ComposerService::getComposerService());
diff -ur ../aosp/frameworks/native/libs/gui/BufferQueueProducer.cpp ../Desktop/android/frameworks/native/libs/gui/BufferQueueProducer.cpp
--- ../aosp/frameworks/native/libs/gui/BufferQueueProducer.cpp	2018-08-06 15:41:16.831856296 +0200
+++ ../Desktop/android/frameworks/native/libs/gui/BufferQueueProducer.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -888,6 +888,94 @@
                 mCore->mQueue.push_back(item);
                 frameAvailableListener = mCore->mConsumerListener;
             }
+
+            if (mCore->mConsumerNextExpectedPresent != 0 && !mCore->mQueue.empty()) {
+                BufferQueueCore::Fifo::iterator front(mCore->mQueue.begin());
+                const int MAX_REASONABLE_NSEC = 1000000000ULL; // 1 second
+                const nsecs_t expectedPresent = mCore->mConsumerNextExpectedPresent;
+
+                while (mCore->mQueue.size() > 1 && !mCore->mQueue[0].mIsAutoTimestamp) {
+                    const BufferItem& bufferItem(mCore->mQueue[1]);
+                    nsecs_t desiredPresent = bufferItem.mTimestamp;
+
+                    if (desiredPresent < expectedPresent - MAX_REASONABLE_NSEC ||
+                            desiredPresent > expectedPresent) {
+                        // This buffer is set to display in the near future, or
+                        // desiredPresent is garbage. Either way we don't want to drop
+                        // the previous buffer just to get this on the screen sooner.
+                        BQ_LOGV("queueBuffer: nodrop desire=%" PRId64 " expect=%"
+                                PRId64 " (%" PRId64 ") now=%" PRId64,
+                                desiredPresent, expectedPresent,
+                                desiredPresent - expectedPresent,
+                                systemTime(CLOCK_MONOTONIC));
+                        break;
+                    }
+
+                    BQ_LOGV("queueBuffer: drop desire=%" PRId64 " expect=%" PRId64
+                            " size=%zu",
+                            desiredPresent, expectedPresent, mCore->mQueue.size());
+
+                    if (!front->mIsStale) {
+                        // Front buffer is still in mSlots, so mark the slot as free
+                        mSlots[front->mSlot].mBufferState.freeQueued();
+
+                        // After leaving shared buffer mode, the shared buffer will
+                        // still be around. Mark it as no longer shared if this
+                        // operation causes it to be free.
+                        if (!mCore->mSharedBufferMode &&
+                                mSlots[front->mSlot].mBufferState.isFree()) {
+                            mSlots[front->mSlot].mBufferState.mShared = false;
+                        }
+
+                        // Don't put the shared buffer on the free list
+                        if (!mSlots[front->mSlot].mBufferState.isShared()) {
+                            mCore->mActiveBuffers.erase(front->mSlot);
+
+                            // mCore->mFreeBuffers.push_back(front->mSlot);
+                            auto iter = mCore->mFreeBuffers.begin();
+                            mCore->mFreeBuffers.insert(iter, front->mSlot);
+                        }
+                    }
+                    mCore->mQueue.erase(front);
+                    front = mCore->mQueue.begin();
+                    slot = mCore->mQueue[mCore->mQueue.size() - 1].mSlot;
+                }
+            }
+
+            if (mCore->mQueue.size() > 1 && !mCore->mQueue[0].mIsAutoTimestamp) {
+                BufferQueueCore::Fifo::iterator lastIter2(mCore->mQueue.begin() + mCore->mQueue.size() - 2);
+                BufferQueueCore::Fifo::iterator lastIter1(mCore->mQueue.begin() + mCore->mQueue.size() - 1);
+
+                if ((lastIter1->mTimestamp - lastIter2->mTimestamp) < 100000UL) {
+
+                    BQ_LOGV("drop same timestamp: %" PRId64 " - %" PRId64 ".",
+                            lastIter1->mTimestamp, lastIter2->mTimestamp);
+
+                    if (!lastIter2->mIsStale) {
+                        // Front buffer is still in mSlots, so mark the slot as free
+                        mSlots[lastIter2->mSlot].mBufferState.freeQueued();
+
+                        // After leaving shared buffer mode, the shared buffer will
+                        // still be around. Mark it as no longer shared if this
+                        // operation causes it to be free.
+                        if (!mCore->mSharedBufferMode &&
+                                mSlots[lastIter2->mSlot].mBufferState.isFree()) {
+                            mSlots[lastIter2->mSlot].mBufferState.mShared = false;
+                        }
+
+                        // Don't put the shared buffer on the free list
+                        if (!mSlots[lastIter2->mSlot].mBufferState.isShared()) {
+                            mCore->mActiveBuffers.erase(lastIter2->mSlot);
+
+                            // mCore->mFreeBuffers.push_back(lastIter2->mSlot);
+                            auto iter = mCore->mFreeBuffers.begin();
+                            mCore->mFreeBuffers.insert(iter, lastIter2->mSlot);
+                        }
+                    }
+                    mCore->mQueue.erase(lastIter2);
+                    slot = mCore->mQueue[mCore->mQueue.size() - 1].mSlot;
+                }
+            }
         }
 
         mCore->mBufferHasBeenQueued = true;
diff -ur ../aosp/frameworks/native/libs/gui/GLConsumer.cpp ../Desktop/android/frameworks/native/libs/gui/GLConsumer.cpp
--- ../aosp/frameworks/native/libs/gui/GLConsumer.cpp	2018-08-06 15:41:16.835856347 +0200
+++ ../Desktop/android/frameworks/native/libs/gui/GLConsumer.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -156,6 +156,7 @@
     mCurrentTransform(0),
     mCurrentScalingMode(NATIVE_WINDOW_SCALING_MODE_FREEZE),
     mCurrentFence(Fence::NO_FENCE),
+    mCurrentDataSpace(HAL_DATASPACE_UNKNOWN),
     mCurrentTimestamp(0),
     mCurrentFrameNumber(0),
     mDefaultWidth(1),
@@ -184,6 +185,7 @@
     mCurrentTransform(0),
     mCurrentScalingMode(NATIVE_WINDOW_SCALING_MODE_FREEZE),
     mCurrentFence(Fence::NO_FENCE),
+    mCurrentDataSpace(HAL_DATASPACE_UNKNOWN),
     mCurrentTimestamp(0),
     mCurrentFrameNumber(0),
     mDefaultWidth(1),
@@ -322,6 +324,7 @@
         mCurrentTransform = 0;
         mCurrentTimestamp = 0;
         mCurrentFence = Fence::NO_FENCE;
+        mCurrentDataSpace = HAL_DATASPACE_UNKNOWN;
 
         if (mAttached) {
             // This binds a dummy buffer (mReleasedTexImage).
@@ -487,6 +490,7 @@
     mCurrentScalingMode = item.mScalingMode;
     mCurrentTimestamp = item.mTimestamp;
     mCurrentFence = item.mFence;
+    mCurrentDataSpace = item.mDataSpace;
     mCurrentFrameNumber = item.mFrameNumber;
 
     computeCurrentTransformMatrixLocked();
@@ -980,6 +984,11 @@
     return mCurrentFence;
 }
 
+android_dataspace_t GLConsumer::getCurrentDataSpace() const {
+    Mutex::Autolock lock(mMutex);
+    return mCurrentDataSpace;
+}
+
 status_t GLConsumer::doGLFenceWait() const {
     Mutex::Autolock lock(mMutex);
     return doGLFenceWaitLocked();
diff -ur ../aosp/frameworks/native/libs/gui/IGraphicBufferConsumer.cpp ../Desktop/android/frameworks/native/libs/gui/IGraphicBufferConsumer.cpp
--- ../aosp/frameworks/native/libs/gui/IGraphicBufferConsumer.cpp	2018-08-06 15:41:16.835856347 +0200
+++ ../Desktop/android/frameworks/native/libs/gui/IGraphicBufferConsumer.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -52,6 +52,7 @@
     SET_TRANSFORM_HINT,
     GET_SIDEBAND_STREAM,
     DUMP,
+    SET_NEXT_EXPECTEDPRESENT,
 };
 
 
@@ -268,6 +269,17 @@
         remote()->transact(DUMP, data, &reply);
         reply.readString8();
     }
+
+    virtual status_t setNextExpectedPresent(nsecs_t expectedPresent) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IGraphicBufferConsumer::getInterfaceDescriptor());
+        data.writeInt64(expectedPresent);
+        status_t result = remote()->transact(SET_NEXT_EXPECTEDPRESENT, data, &reply);
+        if (result != NO_ERROR) {
+            return result;
+        }
+        return reply.readInt32();
+    }
 };
 
 // Out-of-line virtual method definition to trigger vtable emission in this
@@ -417,6 +429,13 @@
             reply->writeString8(result);
             return NO_ERROR;
         }
+        case SET_NEXT_EXPECTEDPRESENT: {
+            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
+            int64_t presentWhen = data.readInt64();
+            status_t result = setNextExpectedPresent(presentWhen);
+            reply->writeInt32(result);
+            return NO_ERROR;
+        };
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
diff -ur ../aosp/frameworks/native/services/inputflinger/InputReader.cpp ../Desktop/android/frameworks/native/services/inputflinger/InputReader.cpp
--- ../aosp/frameworks/native/services/inputflinger/InputReader.cpp	2018-08-06 15:41:16.915857374 +0200
+++ ../Desktop/android/frameworks/native/services/inputflinger/InputReader.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -257,6 +257,24 @@
 
     { // acquire lock
         AutoMutex _l(mLock);
+        mKeySynced = true;
+        mKeyInMouseMode =false;
+        mDistance   = 10;
+        mKeyDeviceId = 0;
+        mVirtualMouseCreated = false;
+        mMouseDeviceId = 0x0fff0fff;
+        mTouchDeviceId = 0x0fff0ffe;
+        mVirtualTouchCreated = false;
+        for(int i= 0;i < MAX_MOUSE_SIZE;i++)
+        {
+            mRealMouseDeviceId[i] = -1;
+        }
+
+        mRealTouchDeviceId = -1;
+        mLeft = 0;
+        mRight = 0;
+        mTop = 0;
+        mBottom = 0;
 
         refreshConfigurationLocked(0);
         updateGlobalMetaStateLocked();
@@ -349,7 +367,11 @@
 #if DEBUG_RAW_EVENTS
             ALOGD("BatchSize: %d Count: %d", batchSize, count);
 #endif
-            processEventsForDeviceLocked(deviceId, rawEvent, batchSize);
+            convertEvent(rawEvent,batchSize);
+            if(batchSize > 0) {
+                int32_t convertdeviceId = mConvertEventBuffer[0].deviceId;
+                processEventsForDeviceLocked(convertdeviceId, mConvertEventBuffer, batchSize);
+            }
         } else {
             switch (rawEvent->type) {
             case EventHubInterface::DEVICE_ADDED:
@@ -370,8 +392,44 @@
         rawEvent += batchSize;
     }
 }
+//support virtual mouse
+InputDevice* InputReader::createVirtualMouse(const InputDeviceIdentifier& identifier,uint32_t classes)
+{
+    InputDevice* device = new InputDevice(&mContext, 0, mMouseDeviceId, bumpGenerationLocked(),identifier,classes);        // External devices.
+    if (classes & INPUT_DEVICE_CLASS_EXTERNAL)
+    {
+        device->setExternal(true);
+    }    // Mouse-like devices.
+
+    device->addMapper(new CursorInputMapper(device));
+
+    return device;
+}
+
+void InputReader::addVirtualMouseDevice(const InputDeviceIdentifier& identifier,nsecs_t when,uint32_t classes){
+    InputDevice* device = createVirtualMouse(identifier,classes);
+    device->configure(when, &mConfig, 0);
+    device->reset(when);
+    if (device->isIgnored()){
+        ALOGI("Device added: id=0x%x", mMouseDeviceId);
+    } else {
+        ALOGI("Device added: id=0x%x,sources=%08x", mMouseDeviceId,
+                device->getSources());
+    }
+
+    ssize_t deviceIndex = mDevices.indexOfKey(mMouseDeviceId);
+    if (deviceIndex < 0){
+        mDevices.add(mMouseDeviceId, device);
+    } else {
+        ALOGW("Ignoring spurious device added event for deviceId %d.", mMouseDeviceId);
+
+        delete device;
+        return;
+    }
+}
 
 void InputReader::addDeviceLocked(nsecs_t when, int32_t deviceId) {
+    ALOGD("addDeviceLocked deviceId = %d ", deviceId);
     ssize_t deviceIndex = mDevices.indexOfKey(deviceId);
     if (deviceIndex >= 0) {
         ALOGW("Ignoring spurious device added event for deviceId %d.", deviceId);
@@ -382,6 +440,25 @@
     uint32_t classes = mEventHub->getDeviceClasses(deviceId);
     int32_t controllerNumber = mEventHub->getDeviceControllerNumber(deviceId);
 
+    if(mVirtualMouseCreated == false){
+        addVirtualMouseDevice(identifier,when,INPUT_DEVICE_CLASS_CURSOR | INPUT_DEVICE_CLASS_EXTERNAL);
+
+        mVirtualMouseCreated = true;
+    }
+
+    if (classes & INPUT_DEVICE_CLASS_CURSOR){
+        for(int i= 0;i < MAX_MOUSE_SIZE;i++){
+            if(mRealMouseDeviceId[i] == -1){
+                mRealMouseDeviceId[i] = deviceId;
+                break;
+            }
+        }
+    }
+
+    if(mVirtualTouchCreated == false){
+        addVirtualTouchDevice(identifier,when,classes);
+        mVirtualTouchCreated = true;
+    }
     InputDevice* device = createDeviceLocked(deviceId, controllerNumber, identifier, classes);
     device->configure(when, &mConfig, 0);
     device->reset(when);
@@ -401,6 +478,52 @@
         notifyExternalStylusPresenceChanged();
     }
 }
+//support mouse mode
+void InputReader::keyEnterMouseMode(){
+    ALOGD("Enter mouse mode!");
+    mKeyInMouseMode = true;
+    ssize_t deviceIndex = mDevices.indexOfKey(mMouseDeviceId);
+    if (deviceIndex < 0){
+        ALOGW("Discarding event for unknown deviceId %d.", mMouseDeviceId);
+        return;
+    }
+    InputDevice* device = mDevices.valueAt(deviceIndex);
+    if (device->isIgnored()){
+        return;
+    }
+}
+
+void InputReader::keyExitMouseMode(){
+    ALOGD("Exit mouse mode!");
+    mKeyInMouseMode = false;
+    ssize_t deviceIndex = mDevices.indexOfKey(mMouseDeviceId);
+    if (deviceIndex < 0){
+        ALOGE("Discarding event for unknown deviceId %d.", mMouseDeviceId);
+        return;
+    }
+    InputDevice* device = mDevices.valueAt(deviceIndex);
+    if (device->isIgnored()){
+        return;
+    }
+    device->fadePointer();
+}
+
+void InputReader::keySetMouseDistance(int distance){
+    mDistance = distance;
+}
+
+void InputReader::keySetMouseMoveCode(int left,int right,int top,int bottom){
+    mLeft   = left;
+    mRight  = right;
+    mTop    = top;
+    mBottom = bottom;
+}
+
+void InputReader::keySetMouseBtnCode(int leftbtn,int midbtn,int rightbtn){
+    mLeftBtn    = leftbtn;
+    mRightBtn   = midbtn;
+    mMidBtn     = midbtn;
+}
 
 void InputReader::removeDeviceLocked(nsecs_t when, int32_t deviceId) {
     InputDevice* device = NULL;
@@ -410,6 +533,13 @@
         return;
     }
 
+    for(int i= 0;i < MAX_MOUSE_SIZE;i++) {
+        if(mRealMouseDeviceId[i] == deviceId) {
+            mRealMouseDeviceId[i] = -1;
+            break;
+        }
+    }
+
     device = mDevices.valueAt(deviceIndex);
     mDevices.removeItemsAt(deviceIndex, 1);
     bumpGenerationLocked();
@@ -504,6 +634,127 @@
 
     return device;
 }
+//support mouse mode
+void InputReader::convertEvent(const RawEvent* rawEvents,size_t count) {
+    RawEvent *tmpRawEvent = mConvertEventBuffer;
+
+    for (const RawEvent* rawEvent = rawEvents; count--; rawEvent++,tmpRawEvent++){
+#if DEBUG_RAW_EVENTS
+        ALOGD("Input event: device=%d type=0x%04x scancode=0x%04x "
+                "keycode=0x%04x value=0x%08x",
+                rawEvent->deviceId, rawEvent->type, rawEvent->code, rawEvent->code,
+                rawEvent->value);
+#endif
+        tmpRawEvent->deviceId   = rawEvent->deviceId;
+        tmpRawEvent->code       = rawEvent->code;
+        tmpRawEvent->type       = rawEvent->type;
+        tmpRawEvent->value      = rawEvent->value;
+        tmpRawEvent->when       = rawEvent->when;
+
+#if 0
+        for(int i= 0;i < MAX_MOUSE_SIZE;i++){
+            if(mRealMouseDeviceId[i] == tmpRawEvent->deviceId){
+                tmpRawEvent->deviceId  = mMouseDeviceId;
+            }
+        }
+#endif
+
+        if(mKeyInMouseMode){
+            if(true){//tmpRawEvent->deviceId == mKeyDeviceId
+                if(rawEvent->type == EV_KEY) {
+                    if(rawEvent->code == mLeft && rawEvent->value != 0) {
+                        tmpRawEvent->deviceId  = mMouseDeviceId;
+                        tmpRawEvent->type      = EV_REL;
+                        tmpRawEvent->code      = REL_X;
+                        tmpRawEvent->value     = -mDistance;
+
+                        mKeySynced             = false;
+                    }
+                    else if(rawEvent->code == mRight && rawEvent->value != 0){
+                        tmpRawEvent->deviceId  = mMouseDeviceId;
+                        tmpRawEvent->type      = EV_REL;
+                        tmpRawEvent->code      = REL_X;
+                        tmpRawEvent->value     = mDistance;
+
+                        mKeySynced             = false;
+                    }
+                    else if(rawEvent->code == mTop && rawEvent->value != 0){
+                        tmpRawEvent->deviceId   = mMouseDeviceId;
+                        tmpRawEvent->type      = EV_REL;
+                        tmpRawEvent->code      = REL_Y;
+                        tmpRawEvent->value     = -mDistance;
+
+                        mKeySynced             = false;
+                    } else if(rawEvent->code == mBottom && rawEvent->value != 0){
+                        tmpRawEvent->deviceId  = mMouseDeviceId;
+                        tmpRawEvent->type      = EV_REL;
+                        tmpRawEvent->code  = REL_Y;
+                        tmpRawEvent->value     = mDistance;
+
+                        mKeySynced             = false;
+                    } else if(rawEvent->code == mLeftBtn){
+                        tmpRawEvent->deviceId  = mMouseDeviceId;
+                        tmpRawEvent->type      = EV_KEY;
+                        tmpRawEvent->code  = BTN_LEFT;
+
+                        mKeySynced             = false;
+                    } else if(rawEvent->code == mMidBtn){
+                        tmpRawEvent->deviceId  = mMouseDeviceId;
+                        tmpRawEvent->type      = EV_KEY;
+                        tmpRawEvent->code  = BTN_MIDDLE;
+
+                        mKeySynced             = false;
+                    } else if(rawEvent->code == mRightBtn){
+                        tmpRawEvent->deviceId  = mMouseDeviceId;
+                        tmpRawEvent->type      = EV_KEY;
+                        tmpRawEvent->code  = BTN_RIGHT;
+
+                        mKeySynced             = false;
+                    }
+                } else if(rawEvent->type == EV_SYN){
+                    if(mKeySynced == false){
+                        tmpRawEvent->deviceId  = mMouseDeviceId;
+
+                        mKeySynced = true;
+                    }
+                }
+            }
+        }
+    }
+}
+
+InputDevice* InputReader::createVirtualTouch(const InputDeviceIdentifier& identifier,uint32_t classes) {
+    InputDevice* device = new InputDevice(&mContext, 0, mMouseDeviceId, bumpGenerationLocked(),identifier,classes);
+
+    // Mouse-like devices.
+    device->addMapper(new MultiTouchInputMapper(device));
+
+    return device;
+}
+
+void InputReader::addVirtualTouchDevice(const InputDeviceIdentifier& identifier,nsecs_t when,uint32_t classes){
+    InputDevice* device = createVirtualTouch(identifier,classes);
+    device->configure(when, &mConfig, 0);
+    device->reset(when);
+
+    if (device->isIgnored()) {
+        ALOGV("Device added: id=0x%x", mTouchDeviceId);
+    }else{
+        ALOGV("Device added: id=0x%x,sources=%08x", mTouchDeviceId,
+                device->getSources());
+    }
+
+    ssize_t deviceIndex = mDevices.indexOfKey(mTouchDeviceId);
+    if (deviceIndex < 0) {
+
+        ALOGV("Device added success: id=0x%x", mTouchDeviceId);
+        mDevices.add(mTouchDeviceId, device);
+    } else {
+        ALOGV("Ignoring spurious device added event for deviceId %d.", mTouchDeviceId);
+        delete device;
+        return;
+    }
+}
 
 void InputReader::processEventsForDeviceLocked(int32_t deviceId,
         const RawEvent* rawEvents, size_t count) {
@@ -1277,7 +1528,7 @@
         result |= AMOTION_EVENT_BUTTON_PRIMARY;
     }
     if (mBtnRight) {
-        result |= AMOTION_EVENT_BUTTON_SECONDARY;
+        result |= AMOTION_EVENT_BUTTON_BACK;
     }
     if (mBtnMiddle) {
         result |= AMOTION_EVENT_BUTTON_TERTIARY;
@@ -2113,6 +2364,11 @@
         uint32_t source, int32_t keyboardType) :
         InputMapper(device), mSource(source),
         mKeyboardType(keyboardType) {
+        mIsRepeatMode = true;
+        for(int i= 0;i < MAX_KEYDOWNNUM;i++){
+            mCurrentDown[i]  = false;
+            mCurrentScanCode[i] = 0;
+        }
 }
 
 KeyboardInputMapper::~KeyboardInputMapper() {
@@ -2202,6 +2458,95 @@
 void KeyboardInputMapper::process(const RawEvent* rawEvent) {
     switch (rawEvent->type) {
     case EV_KEY: {
+        bool   find = false;
+        bool   down = false;
+        bool   currentindex = 0;
+
+        if(mIsRepeatMode)
+        {
+            if(rawEvent->value != 0)
+            {
+                for(int i = 0;i < MAX_KEYDOWNNUM;i++)
+                {
+                    if(mCurrentDown[i] == true)
+                    {
+                        down = true;
+                    }
+                }
+
+                if(down == false)
+                {
+                    for(int i = 0;i < MAX_KEYDOWNNUM;i++)
+                    {
+                        if(mCurrentDown[i] == false)
+                        {
+                            currentindex = i;
+
+                            break ;
+                        }
+                    }
+
+                    mCurrentDown[currentindex] = true;
+                    mCurrentScanCode[currentindex] = rawEvent->code;
+                    goto processCurrentEvent;
+                }
+                else
+                {
+                    for(int i = 0;i < MAX_KEYDOWNNUM;i++)
+                    {
+                        if(mCurrentScanCode[i] == rawEvent->code)
+                        {
+                            find = true;
+                        }
+                    }
+
+                    if(find == false)
+                    {
+                        for(int i = 0;i < MAX_KEYDOWNNUM;i++)
+                        {
+                            if(mCurrentDown[i] == false)
+                            {
+                                currentindex = i;
+
+                                break;
+                            }
+                        }
+
+                        mCurrentDown[currentindex] = true;
+                        mCurrentScanCode[currentindex] = rawEvent->code;
+                        goto processCurrentEvent;
+                    }
+                }
+            }
+            else
+            {
+                for(int i = 0;i < MAX_KEYDOWNNUM;i++)
+                {
+                    if(mCurrentScanCode[i] == rawEvent->code)
+                    {
+                        currentindex = i;
+                        find = true;
+
+                        break;
+                    }
+                }
+
+                if(find == true)
+                {
+                    mCurrentDown[currentindex] = false;
+                    mCurrentScanCode[currentindex] = 0;
+
+                    goto processCurrentEvent;
+                }
+            }
+        }
+        else
+        {
+            goto processCurrentEvent;
+        }
+
+        return ;
+processCurrentEvent:
         int32_t scanCode = rawEvent->code;
         int32_t usageCode = mCurrentHidUsage;
         mCurrentHidUsage = 0;
@@ -2305,8 +2650,15 @@
     // For internal keyboards, the key layout file should specify the policy flags for
     // each wake key individually.
     // TODO: Use the input device configuration to control this behavior more finely.
+
     if (down && getDevice()->isExternal()) {
-        policyFlags |= POLICY_FLAG_WAKE;
+	if ((strcmp(getDeviceName().string(), "sunxi-ir-uinput")) == 0) {
+		if (keyCode == AKEYCODE_POWER) {
+			policyFlags |= POLICY_FLAG_WAKE;
+		}
+	} else {
+		policyFlags |= POLICY_FLAG_WAKE;
+	}
     }
 
     if (mParameters.handlesKeyRepeat) {
diff -ur ../aosp/frameworks/native/services/inputflinger/InputReader.h ../Desktop/android/frameworks/native/services/inputflinger/InputReader.h
--- ../aosp/frameworks/native/services/inputflinger/InputReader.h	2018-08-06 15:41:16.919857425 +0200
+++ ../Desktop/android/frameworks/native/services/inputflinger/InputReader.h	2017-11-23 05:21:51.000000000 +0100
@@ -375,6 +375,12 @@
     virtual void vibrate(int32_t deviceId, const nsecs_t* pattern, size_t patternSize,
             ssize_t repeat, int32_t token) = 0;
     virtual void cancelVibrate(int32_t deviceId, int32_t token) = 0;
+    //support mouse mode
+    virtual void keyEnterMouseMode() = 0;
+    virtual void keyExitMouseMode() = 0;
+    virtual void keySetMouseDistance(int distance) = 0;
+    virtual void keySetMouseMoveCode(int left,int right,int top,int bottom) = 0;
+    virtual void keySetMouseBtnCode(int leftbtn,int midbtn,int rightbtn) = 0;
 };
 
 struct StylusState {
@@ -474,6 +480,12 @@
     virtual void vibrate(int32_t deviceId, const nsecs_t* pattern, size_t patternSize,
             ssize_t repeat, int32_t token);
     virtual void cancelVibrate(int32_t deviceId, int32_t token);
+    //support mouse mode
+    virtual void keyEnterMouseMode();
+    virtual void keyExitMouseMode();
+    virtual void keySetMouseDistance(int distance);
+    virtual void keySetMouseMoveCode(int left,int right,int top,int bottom);
+    virtual void keySetMouseBtnCode(int leftbtn,int midbtn,int rightbtn);
 
 protected:
     // These members are protected so they can be instrumented by test cases.
@@ -517,6 +529,7 @@
     // The event queue.
     static const int EVENT_BUFFER_SIZE = 256;
     RawEvent mEventBuffer[EVENT_BUFFER_SIZE];
+    RawEvent mConvertEventBuffer[EVENT_BUFFER_SIZE];
 
     KeyedVector<int32_t, InputDevice*> mDevices;
 
@@ -526,11 +539,29 @@
     void addDeviceLocked(nsecs_t when, int32_t deviceId);
     void removeDeviceLocked(nsecs_t when, int32_t deviceId);
     void processEventsForDeviceLocked(int32_t deviceId, const RawEvent* rawEvents, size_t count);
+    void convertEvent(const RawEvent* rawEvents,size_t count);
     void timeoutExpiredLocked(nsecs_t when);
 
     void handleConfigurationChangedLocked(nsecs_t when);
+    InputDevice* createVirtualMouse(const InputDeviceIdentifier& identifier,uint32_t classes);
+    void addVirtualMouseDevice(const InputDeviceIdentifier& identifier,nsecs_t when,uint32_t classes);
+    InputDevice* createVirtualTouch(const InputDeviceIdentifier& identifier,uint32_t classes);
+    void addVirtualTouchDevice(const InputDeviceIdentifier& identifier,nsecs_t when,uint32_t classes);
 
     int32_t mGlobalMetaState;
+    bool        mKeyInMouseMode;
+    bool        mKeySynced;
+    bool		mVirtualTouchCreated;
+    bool        mVirtualMouseCreated;
+    int32_t     mDistance;
+    int         mKeyDeviceId;
+    int         mMouseDeviceId;
+    static const int MAX_MOUSE_SIZE = 10;
+    int         mRealMouseDeviceId[MAX_MOUSE_SIZE];
+    int 		mTouchDeviceId;
+    int 		mRealTouchDeviceId;
+    int         mLeft,mRight,mTop,mBottom;
+    int         mLeftBtn,mRightBtn,mMidBtn;
     void updateGlobalMetaStateLocked();
     int32_t getGlobalMetaStateLocked();
 
@@ -1139,7 +1170,10 @@
     Vector<KeyDown> mKeyDowns; // keys that are down
     int32_t mMetaState;
     nsecs_t mDownTime; // time of most recent key down
-
+    static const int MAX_KEYDOWNNUM = 10;
+    bool    mIsRepeatMode;
+    bool    mCurrentDown[MAX_KEYDOWNNUM];
+    int32_t mCurrentScanCode[MAX_KEYDOWNNUM];
     int32_t mCurrentHidUsage; // most recent HID usage seen this packet, or 0 if none
 
     struct LedState {
diff -ur ../aosp/frameworks/native/services/surfaceflinger/Android.mk ../Desktop/android/frameworks/native/services/surfaceflinger/Android.mk
--- ../aosp/frameworks/native/services/surfaceflinger/Android.mk	2018-08-06 15:41:16.923857476 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/Android.mk	2017-11-23 05:21:51.000000000 +0100
@@ -46,7 +46,7 @@
 LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES
 #LOCAL_CFLAGS += -DENABLE_FENCE_TRACKING
 
-USE_HWC2 := false
+USE_HWC2 := true
 ifeq ($(USE_HWC2),true)
     LOCAL_CFLAGS += -DUSE_HWC2
     LOCAL_SRC_FILES += \
diff -ur ../aosp/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.cpp ../Desktop/android/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.cpp
--- ../aosp/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.cpp	2018-08-06 15:41:16.927857527 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -91,6 +91,7 @@
     mDump(nullptr),
     mGetMaxVirtualDisplayCount(nullptr),
     mRegisterCallback(nullptr),
+    mQuery(nullptr),
     mAcceptDisplayChanges(nullptr),
     mCreateLayer(nullptr),
     mDestroyLayer(nullptr),
@@ -186,6 +187,11 @@
     return std::string(buffer.data(), buffer.size());
 }
 
+int32_t Device::query(int32_t what, int32_t* value)
+{
+    return mQuery(mHwcDevice, what, value);
+}
+
 uint32_t Device::getMaxVirtualDisplayCount() const
 {
     return mGetMaxVirtualDisplayCount(mHwcDevice);
@@ -321,7 +327,7 @@
     // For all of these early returns, we log an error message inside
     // loadFunctionPointer specifying which function failed to load
 
-    // Display function pointers
+    // Device function pointers
     if (!loadFunctionPointer(FunctionDescriptor::CreateVirtualDisplay,
             mCreateVirtualDisplay)) return;
     if (!loadFunctionPointer(FunctionDescriptor::DestroyVirtualDisplay,
@@ -331,8 +337,10 @@
             mGetMaxVirtualDisplayCount)) return;
     if (!loadFunctionPointer(FunctionDescriptor::RegisterCallback,
             mRegisterCallback)) return;
+    if (!loadFunctionPointer(FunctionDescriptor::Query,
+            mQuery)) return;
 
-    // Device function pointers
+    // Display function pointers
     if (!loadFunctionPointer(FunctionDescriptor::AcceptDisplayChanges,
             mAcceptDisplayChanges)) return;
     if (!loadFunctionPointer(FunctionDescriptor::CreateLayer,
@@ -666,9 +674,21 @@
             &intType);
     auto error = static_cast<Error>(intError);
     if (error != Error::None) {
+        if (error == Error::BadDisplay) {
+            /*
+             * On hotplug out event received, HWC2On1Adapter had already
+             * close the HWC2On1Adapter::Display object, So the mGetDisplayType()
+             * will return BadDisplay always, That will lead to HWComposer::disconnectDisplay()
+             * failed with "disconnectDisplay: Failed to determine type of display..."
+             */
+            ALOGE("call getType() on plugout device!");
+            intType = static_cast<int32_t>(HWC2::DisplayType::Physical);
+            goto __out;
+        }
         return error;
     }
 
+__out:
     *outType = static_cast<DisplayType>(intType);
     return Error::None;
 }
diff -ur ../aosp/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.h ../Desktop/android/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.h
--- ../aosp/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.h	2018-08-06 15:41:16.927857527 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.h	2017-11-23 05:21:51.000000000 +0100
@@ -93,6 +93,8 @@
 
     bool hasCapability(HWC2::Capability capability) const;
 
+    int32_t query(int32_t what, int32_t* value);
+
 private:
     // Initialization methods
 
@@ -138,6 +140,7 @@
     HWC2_PFN_DUMP mDump;
     HWC2_PFN_GET_MAX_VIRTUAL_DISPLAY_COUNT mGetMaxVirtualDisplayCount;
     HWC2_PFN_REGISTER_CALLBACK mRegisterCallback;
+    HWC2_PFN_QUERY mQuery;
 
     // Display function pointers
     HWC2_PFN_ACCEPT_DISPLAY_CHANGES mAcceptDisplayChanges;
diff -ur ../aosp/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2On1Adapter.cpp ../Desktop/android/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2On1Adapter.cpp
--- ../aosp/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2On1Adapter.cpp	2018-08-06 15:41:16.927857527 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2On1Adapter.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -86,6 +86,7 @@
         for (size_t l = 0; l < contents->numHwLayers; ++l) {
             auto& layer = contents->hwLayers[l];
             std::free(const_cast<hwc_rect_t*>(layer.visibleRegionScreen.rects));
+            std::free(const_cast<hwc_rect_t*>(layer.surfaceDamage.rects));
         }
     }
     std::free(contents);
@@ -193,6 +194,8 @@
                     getMaxVirtualDisplayCountHook);
         case FunctionDescriptor::RegisterCallback:
             return asFP<HWC2_PFN_REGISTER_CALLBACK>(registerCallbackHook);
+        case FunctionDescriptor::Query:
+            return asFP<HWC2_PFN_QUERY>(queryHook);
 
         // Display functions
         case FunctionDescriptor::AcceptDisplayChanges:
@@ -454,6 +457,13 @@
     return mHwc1SupportsVirtualDisplays ? 1 : 0;
 }
 
+int32_t HWC2On1Adapter::query(int32_t what, int32_t* value)
+{
+    if (mHwc1Device->query)
+        return mHwc1Device->query(mHwc1Device, what, value);
+    return 0;
+}
+
 static bool isValid(Callback descriptor) {
     switch (descriptor) {
         case Callback::Hotplug: // Fall-through
@@ -793,6 +803,20 @@
     return Error::None;
 }
 
+Error HWC2On1Adapter::Display::clearReleaseFences()
+{
+    std::unique_lock<std::recursive_mutex> lock(mStateMutex);
+
+    for (const auto& layer : mLayers) {
+        layer->clearReleaseFence();
+        layer->clearAcquireFence();
+    }
+    mClientTarget.setFence(-1);
+    mOutputBuffer.setFence(-1);
+    ALOGD("drop fence on total %d layers", mLayers.size());
+    return Error::None;
+}
+
 Error HWC2On1Adapter::Display::getRequests(int32_t* outDisplayRequests,
         uint32_t* outNumElements, hwc2_layer_t* outLayers,
         int32_t* outLayerRequests)
@@ -1525,6 +1549,14 @@
     return std::string(buffer, bytesWritten);
 }
 
+static std::string dataspaceString(android_dataspace_t dataspace)
+{
+    const size_t BUFFER_SIZE = 16;
+    char buffer[BUFFER_SIZE] = {};
+    auto bytesWritten = snprintf(buffer, BUFFER_SIZE, "0x%08x", dataspace);
+    return std::string(buffer, bytesWritten);
+}
+
 static std::string to_string(const hwc_layer_1_t& hwcLayer,
         int32_t hwc1MinorVersion)
 {
@@ -1946,6 +1978,7 @@
     hwc1Target.displayFrame = {0, 0, width, height};
     hwc1Target.planeAlpha = 255;
     hwc1Target.visibleRegionScreen.numRects = 1;
+    std::free(const_cast<hwc_rect_t*>(hwc1Target.visibleRegionScreen.rects));
     auto rects = static_cast<hwc_rect_t*>(std::malloc(sizeof(hwc_rect_t)));
     rects[0].left = 0;
     rects[0].top = 0;
@@ -1970,6 +2003,7 @@
     mBlendMode(*this, BlendMode::None),
     mColor(*this, {0, 0, 0, 0}),
     mCompositionType(*this, Composition::Invalid),
+    mDataspace(*this, HAL_DATASPACE_UNKNOWN),
     mDisplayFrame(*this, {0, 0, -1, -1}),
     mPlaneAlpha(*this, 0.0f),
     mSidebandStream(*this, nullptr),
@@ -2042,7 +2076,9 @@
 
 Error HWC2On1Adapter::Layer::setDataspace(android_dataspace_t dataspace)
 {
-    mHasUnsupportedDataspace = (dataspace != HAL_DATASPACE_UNKNOWN);
+    //mHasUnsupportedDataspace = (dataspace != HAL_DATASPACE_UNKNOWN);
+    //ALOGD("%s: dataspace=%d", __FUNCTION__, dataspace);
+    mDataspace.setPending(dataspace);
     return Error::None;
 }
 
@@ -2096,6 +2132,16 @@
     mReleaseFence.add(fenceFd);
 }
 
+void HWC2On1Adapter::Layer::clearReleaseFence()
+{
+    mReleaseFence.clear();
+}
+
+void HWC2On1Adapter::Layer::clearAcquireFence()
+{
+    mBuffer.setFence(-1);
+}
+
 const sp<Fence>& HWC2On1Adapter::Layer::getReleaseFence() const
 {
     return mReleaseFence.get();
@@ -2172,6 +2218,10 @@
         if (mPlaneAlpha.getValue() != 1.0f) {
             output << "  Alpha: " <<
                 alphaString(mPlaneAlpha.getValue()) << '\n';
+        }
+        if (mDataspace.getValue() != HAL_DATASPACE_UNKNOWN) {
+            output << "  Dataspace: " <<
+                dataspaceString(mDataspace.getValue()) << '\n';
         } else {
             output << '\n';
         }
@@ -2203,7 +2253,7 @@
     }
     if (applyAllState || mPlaneAlpha.isDirty()) {
         auto pendingAlpha = mPlaneAlpha.getPendingValue();
-        if (minorVersion < 2) {
+        if (minorVersion < 1) {
             mHasUnsupportedPlaneAlpha = pendingAlpha < 1.0f;
         } else {
             hwc1Layer.planeAlpha =
@@ -2245,6 +2295,11 @@
         hwc1VisibleRegion.numRects = pending.size();
         mVisibleRegion.latch();
     }
+    if (applyAllState || mDataspace.isDirty()) {
+        hwc1Layer.dataspace =
+                static_cast<int32_t>(mDataspace.getPendingValue());
+        mDataspace.latch();
+    }
 }
 
 void HWC2On1Adapter::Layer::applySolidColorState(hwc_layer_1_t& hwc1Layer,
@@ -2474,7 +2529,8 @@
 
     // Return the received contents to their respective displays
     for (size_t hwc1Id = 0; hwc1Id < mHwc1Contents.size(); ++hwc1Id) {
-        if (mHwc1Contents[hwc1Id] == nullptr) {
+        if ((mHwc1Contents[hwc1Id] == nullptr)
+                || (0 == mHwc1DisplayMap.count(hwc1Id))) {
             continue;
         }
 
@@ -2494,7 +2550,13 @@
 
     // Make sure we're ready to validate
     for (size_t hwc1Id = 0; hwc1Id < mHwc1Contents.size(); ++hwc1Id) {
-        if (mHwc1Contents[hwc1Id] == nullptr) {
+        if ((mHwc1Contents[hwc1Id] == nullptr)
+                || (0 == mHwc1DisplayMap.count(hwc1Id))) {
+
+            if (mHwc1Contents[hwc1Id] != nullptr) {
+                mHwc1Contents.erase(mHwc1Contents.cbegin() + hwc1Id);
+                ALOGE("Clear disconnected display contents");
+            }
             continue;
         }
 
@@ -2517,7 +2579,8 @@
 
     // Add retire and release fences
     for (size_t hwc1Id = 0; hwc1Id < mHwc1Contents.size(); ++hwc1Id) {
-        if (mHwc1Contents[hwc1Id] == nullptr) {
+        if ((mHwc1Contents[hwc1Id] == nullptr)
+                || (0 == mHwc1DisplayMap.count(hwc1Id))) {
             continue;
         }
 
@@ -2603,6 +2666,19 @@
     // If the HWC2-side callback hasn't been registered yet, buffer this until
     // it is registered
     if (mCallbacks.count(Callback::Hotplug) == 0) {
+        ALOGE("Hotplug Callback not install, pending (%d %d)", hwc1DisplayId, connected);
+
+        if (connected && mHwc1DisplayMap.count(hwc1DisplayId) == 0) {
+            // Create a new display on connected
+            hwc2_display_t displayId = UINT64_MAX;
+            auto display = std::make_shared<HWC2On1Adapter::Display>(*this, HWC2::DisplayType::Physical);
+            display->setHwc1Id(HWC_DISPLAY_EXTERNAL);
+            display->populateConfigs();
+            displayId = display->getId();
+            mHwc1DisplayMap[HWC_DISPLAY_EXTERNAL] = displayId;
+            mDisplays.emplace(displayId, std::move(display));
+        }
+
         mPendingHotplugs.emplace_back(hwc1DisplayId, connected);
         return;
     }
@@ -2628,7 +2704,12 @@
                     "display");
             return;
         }
-
+        {
+            // clear unused release fence fd
+            displayId = mHwc1DisplayMap[hwc1DisplayId];
+            auto& display = mDisplays[displayId];
+            display->clearReleaseFences();
+        }
         // Disconnect an existing display
         displayId = mHwc1DisplayMap[hwc1DisplayId];
         mHwc1DisplayMap.erase(HWC_DISPLAY_EXTERNAL);
diff -ur ../aosp/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2On1Adapter.h ../Desktop/android/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2On1Adapter.h
--- ../aosp/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2On1Adapter.h	2018-08-06 15:41:16.927857527 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/DisplayHardware/HWC2On1Adapter.h	2017-11-23 05:21:51.000000000 +0100
@@ -116,6 +116,12 @@
         return static_cast<int32_t>(error);
     }
 
+    int32_t query(int32_t what, int32_t* value);
+    static int32_t queryHook(hwc2_device_t* device,
+            int32_t what, int32_t* value) {
+        return getAdapter(device)->query(what, value);
+    }
+
     // Display functions
 
     class Layer;
@@ -146,6 +152,11 @@
                 return mFences.front();
             }
 
+            void clear() {
+                while (mFences.size() != 0)
+                mFences.pop();
+            }
+
         private:
             mutable std::mutex mMutex;
             std::queue<sp<Fence>> mFences;
@@ -202,6 +213,7 @@
                     int32_t* outTypes, float* outMaxLuminance,
                     float* outMaxAverageLuminance, float* outMinLuminance);
             HWC2::Error getName(uint32_t* outSize, char* outName);
+            HWC2::Error clearReleaseFences();
             HWC2::Error getReleaseFences(uint32_t* outNumElements,
                     hwc2_layer_t* outLayers, int32_t* outFences);
             HWC2::Error getRequests(int32_t* outDisplayRequests,
@@ -524,7 +536,9 @@
             uint32_t getZ() const { return mZ; }
 
             void addReleaseFence(int fenceFd);
+            void clearReleaseFence();
             const sp<Fence>& getReleaseFence() const;
+            void clearAcquireFence();
 
             void setHwc1Id(size_t id) { mHwc1Id = id; }
             size_t getHwc1Id() const { return mHwc1Id; }
@@ -555,6 +569,7 @@
             LatchedState<HWC2::BlendMode> mBlendMode;
             LatchedState<hwc_color_t> mColor;
             LatchedState<HWC2::Composition> mCompositionType;
+            LatchedState<android_dataspace_t> mDataspace;
             LatchedState<hwc_rect_t> mDisplayFrame;
             LatchedState<float> mPlaneAlpha;
             LatchedState<const native_handle_t*> mSidebandStream;
diff -ur ../aosp/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp ../Desktop/android/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
--- ../aosp/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	2018-08-06 15:41:16.927857527 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -693,6 +693,7 @@
     auto hwcId = displayData.hwcDisplay->getId();
     mHwcDisplaySlots.erase(hwcId);
     displayData.reset();
+    ALOGD("disconnect display (%lld)", hwcId);
 }
 
 status_t HWComposer::setOutputBuffer(int32_t displayId,
@@ -775,6 +776,17 @@
 }
 */
 
+bool HWComposer::isSkipGpuBuffer(
+       const sp<GraphicBuffer>& buf) const {
+    if (buf->handle) {
+        buffer_handle_t handle = buf->handle;
+        int ret = mHwcDevice->query(HWC_IS_SKIP_GPU_BUFFER, (int *)handle);
+        return ret ? true : false;
+    } else {
+        return false;
+    }
+}
+
 void HWComposer::dump(String8& result) const {
     // TODO: In order to provide a dump equivalent to HWC1, we need to shadow
     // all the state going into the layers. This is probably better done in
diff -ur ../aosp/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h ../Desktop/android/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h
--- ../aosp/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h	2018-08-06 15:41:16.927857527 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h	2017-11-23 05:21:51.000000000 +0100
@@ -158,6 +158,8 @@
     std::shared_ptr<const HWC2::Display::Config>
             getActiveConfig(int32_t displayId) const;
 
+    bool isSkipGpuBuffer(const sp<GraphicBuffer>& buf) const;
+
     // for debugging ----------------------------------------------------------
     void dump(String8& out) const;
 
diff -ur ../aosp/frameworks/native/services/surfaceflinger/Layer.cpp ../Desktop/android/frameworks/native/services/surfaceflinger/Layer.cpp
--- ../aosp/frameworks/native/services/surfaceflinger/Layer.cpp	2018-08-06 15:41:16.931857579 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/Layer.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -749,6 +749,9 @@
                 mActiveBuffer->handle, to_string(error).c_str(),
                 static_cast<int32_t>(error));
     }
+
+    auto dataSpace = mSurfaceFlingerConsumer->getCurrentDataSpace();
+    error = hwcLayer->setDataspace(dataSpace);
 }
 #else
 void Layer::setPerFrameData(const sp<const DisplayDevice>& hw,
@@ -911,7 +914,8 @@
         // is probably going to have something visibly wrong.
     }
 
-    bool blackOutLayer = isProtected() || (isSecure() && !hw->isSecure());
+    bool blackOutLayer = isProtected() || (isSecure() && !hw->isSecure())
+            || isSkipRenderEngine();
 
     RenderEngine& engine(mFlinger->getRenderEngine());
 
@@ -1231,6 +1235,15 @@
             (activeBuffer->getUsage() & GRALLOC_USAGE_PROTECTED);
 }
 
+bool Layer::isSkipRenderEngine() const {
+    const HWComposer& hwc = mFlinger->getHwComposer();
+    const sp<GraphicBuffer>& activeBuffer(mActiveBuffer);
+    if (activeBuffer != 0)
+        return hwc.isSkipGpuBuffer(activeBuffer);
+    else
+        return false;
+}
+
 bool Layer::isFixedSize() const {
     return getEffectiveScalingMode() != NATIVE_WINDOW_SCALING_MODE_FREEZE;
 }
@@ -1669,6 +1682,12 @@
     return isDue || !isPlausible;
 }
 
+bool Layer::updateNextExpectedPresent(const DispSync& dispSync) const {
+    Mutex::Autolock lock(mQueueItemLock);
+    mSurfaceFlingerConsumer->updateNextExpectedPresent(dispSync);
+    return true;
+}
+
 bool Layer::onPreComposition() {
     mRefreshPending = false;
     return mQueuedFrames > 0 || mSidebandStreamChanged || mAutoRefresh;
diff -ur ../aosp/frameworks/native/services/surfaceflinger/Layer.h ../Desktop/android/frameworks/native/services/surfaceflinger/Layer.h
--- ../aosp/frameworks/native/services/surfaceflinger/Layer.h	2018-08-06 15:41:16.931857579 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/Layer.h	2017-11-23 05:21:51.000000000 +0100
@@ -210,6 +210,11 @@
     virtual bool isProtected() const;
 
     /*
+     * isSkipRenderEngine - true if the layer cannot be dealed with RenderEngine.
+     */
+    virtual bool isSkipRenderEngine() const;
+
+    /*
      * isVisible - true if this layer is visible, false otherwise
      */
     virtual bool isVisible() const;
@@ -266,6 +271,8 @@
 #endif
 
     bool shouldPresentNow(const DispSync& dispSync) const;
+    bool updateNextExpectedPresent(const DispSync& dispSync) const;
+
 
     /*
      * called before composition.
diff -ur ../aosp/frameworks/native/services/surfaceflinger/RenderEngine/RenderEngine.cpp ../Desktop/android/frameworks/native/services/surfaceflinger/RenderEngine/RenderEngine.cpp
--- ../aosp/frameworks/native/services/surfaceflinger/RenderEngine/RenderEngine.cpp	2018-08-06 15:41:16.931857579 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/RenderEngine/RenderEngine.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -380,6 +380,7 @@
         attribs[EGL_RED_SIZE]                   = 8;
         attribs[EGL_GREEN_SIZE]                 = 8;
         attribs[EGL_BLUE_SIZE]                  = 8;
+        attribs[EGL_ALPHA_SIZE]                 = 8;
         wantedAttribute                         = EGL_NONE;
         wantedAttributeValue                    = EGL_NONE;
     } else {
diff -ur ../aosp/frameworks/native/services/surfaceflinger/SurfaceFlingerConsumer.cpp ../Desktop/android/frameworks/native/services/surfaceflinger/SurfaceFlingerConsumer.cpp
--- ../aosp/frameworks/native/services/surfaceflinger/SurfaceFlingerConsumer.cpp	2018-08-06 15:41:16.931857579 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/SurfaceFlingerConsumer.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -187,6 +187,13 @@
     return nextRefresh + extraPadding;
 }
 
+status_t SurfaceFlingerConsumer::updateNextExpectedPresent(const DispSync& dispSync)
+{
+    nsecs_t nextExpectedPresent = dispSync.computeNextRefresh(1);
+    nsecs_t offset = (const_cast<DispSync&>(dispSync)).getPeriod() / 5;
+    return mConsumer->setNextExpectedPresent(nextExpectedPresent - offset);
+}
+
 #ifdef USE_HWC2
 void SurfaceFlingerConsumer::setReleaseFence(const sp<Fence>& fence)
 {
diff -ur ../aosp/frameworks/native/services/surfaceflinger/SurfaceFlingerConsumer.h ../Desktop/android/frameworks/native/services/surfaceflinger/SurfaceFlingerConsumer.h
--- ../aosp/frameworks/native/services/surfaceflinger/SurfaceFlingerConsumer.h	2018-08-06 15:41:16.931857579 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/SurfaceFlingerConsumer.h	2017-11-23 05:21:51.000000000 +0100
@@ -75,6 +75,7 @@
     sp<NativeHandle> getSidebandStream() const;
 
     nsecs_t computeExpectedPresent(const DispSync& dispSync);
+    status_t updateNextExpectedPresent(const DispSync& dispSync);
 
     virtual void setReleaseFence(const sp<Fence>& fence) override;
     sp<Fence> getPrevReleaseFence() const;
diff -ur ../aosp/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp ../Desktop/android/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
--- ../aosp/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2018-08-06 15:41:16.931857579 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2017-11-23 05:21:51.000000000 +0100
@@ -884,6 +884,21 @@
         Mutex::Autolock _l(mStateLock);
         if (connected) {
             createBuiltinDisplayLocked(type);
+#define _CREATE_DEVICE_ON_HOTPLUG
+#ifdef  _CREATE_DEVICE_ON_HOTPLUG
+        wp<IBinder> token = mBuiltinDisplays[type];
+        sp<IGraphicBufferProducer> producer;
+        sp<IGraphicBufferConsumer> consumer;
+        BufferQueue::createBufferQueue(&producer, &consumer,
+            new GraphicBufferAlloc());
+
+        sp<FramebufferSurface> fbs = new FramebufferSurface(*mHwc,
+                DisplayDevice::DISPLAY_EXTERNAL, consumer);
+        sp<DisplayDevice> hw = new DisplayDevice(this,
+                DisplayDevice::DISPLAY_EXTERNAL, disp, false, token, fbs,
+                producer, mRenderEngine->getEGLConfig());
+        mDisplays.add(token, hw);
+#endif
         } else {
             mCurrentState.displays.removeItem(mBuiltinDisplays[type]);
             mBuiltinDisplays[type].clear();
@@ -1433,8 +1448,15 @@
                                 || (state.viewport != draw[i].viewport)
                                 || (state.frame != draw[i].frame))
                         {
+                            Rect frame = state.frame;
+                            if (state.type == DisplayDevice::DISPLAY_PRIMARY) {
+                            } else if (state.type == DisplayDevice::DISPLAY_EXTERNAL) {
+                                frame = Rect(disp->getWidth(), disp->getHeight());
+                                ALOGE("state frame %d x %d, frame from dispdev %d x %d",
+                                state.frame.width(), state.frame.height(), disp->getWidth(), disp->getHeight());
+                            }
                             disp->setProjection(state.orientation,
-                                    state.viewport, state.frame);
+                                    state.viewport, frame);
                         }
                         if (state.width != draw[i].width || state.height != draw[i].height) {
                             disp->setDisplaySize(state.width, state.height);
@@ -1846,6 +1868,12 @@
         invalidateLayerStack(s.layerStack, dirty);
     }
 
+    for (size_t i = 0, count = layers.size(); i<count ; i++) {
+        const sp<Layer>& layer(layers[i]);
+        layer->updateNextExpectedPresent(mPrimaryDispSync);
+    }
+
+
     mVisibleRegionsDirty |= visibleRegions;
 
     // If we will need to wake up at some time in the future to deal with a
@@ -2449,9 +2477,30 @@
     d.width = 0;
     d.height = 0;
     displays.add(d);
+
+    if (mBuiltinDisplays[DisplayDevice::DISPLAY_EXTERNAL] != NULL) {
+        const sp<DisplayDevice> disp(getDisplayDevice(mBuiltinDisplays[DisplayDevice::DISPLAY_PRIMARY]));
+
+        DisplayState external;
+        external.what = DisplayState::eDisplayProjectionChanged |
+                 DisplayState::eLayerStackChanged;
+        external.token = mBuiltinDisplays[DisplayDevice::DISPLAY_EXTERNAL];
+        external.layerStack = 0;
+        external.orientation = DisplayState::eOrientationDefault;
+        external.frame.makeInvalid();
+        external.viewport = Rect(disp->getWidth(), disp->getHeight());
+        external.width = 0;
+        external.height = 0;
+        displays.add(external);
+    }
+
     setTransactionState(state, displays, 0);
     setPowerModeInternal(getDisplayDevice(d.token), HWC_POWER_MODE_NORMAL);
 
+    if (mBuiltinDisplays[DisplayDevice::DISPLAY_EXTERNAL] != NULL) {
+        setPowerModeInternal(getDisplayDevice(mBuiltinDisplays[DisplayDevice::DISPLAY_EXTERNAL]), HWC_POWER_MODE_NORMAL);
+    }
+
     const auto& activeConfig = mHwc->getActiveConfig(HWC_DISPLAY_PRIMARY);
     const nsecs_t period = activeConfig->getVsyncPeriod();
     mAnimFrameTracker.setDisplayRefreshPeriod(period);
diff -ur ../aosp/frameworks/native/services/surfaceflinger/surfaceflinger.rc ../Desktop/android/frameworks/native/services/surfaceflinger/surfaceflinger.rc
--- ../aosp/frameworks/native/services/surfaceflinger/surfaceflinger.rc	2018-08-06 15:41:16.935857631 +0200
+++ ../Desktop/android/frameworks/native/services/surfaceflinger/surfaceflinger.rc	2017-11-23 05:21:51.000000000 +0100
@@ -1,6 +1,7 @@
 service surfaceflinger /system/bin/surfaceflinger
     class core
     user system
+    socket hwcsocket stream 0666 system system
     group graphics drmrpc readproc
     onrestart restart zygote
     writepid /sys/fs/cgroup/stune/foreground/tasks
Only in ../Desktop/android/frameworks/opt/emoji: .emptycommitmark
Only in ../Desktop/android/frameworks/opt/inputconnectioncommon: .emptycommitmark
Only in ../Desktop/android/frameworks/opt/net: pppoe
diff -ur ../aosp/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java ../Desktop/android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java
--- ../aosp/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java	2018-08-06 15:41:26.863985046 +0200
+++ ../Desktop/android/frameworks/opt/net/wifi/service/java/com/android/server/wifi/WifiStateMachine.java	2017-11-23 05:21:52.000000000 +0100
@@ -4216,6 +4216,7 @@
         @Override
         public void enter() {
             mWifiNative.stopHal();
+            mWifiMonitor.killSupplicant(mP2pSupported); //fix android stop start issure.
             mWifiNative.unloadDriver();
             if (mWifiP2pChannel == null) {
                 mWifiP2pChannel = new AsyncChannel();
Only in ../Desktop/android/frameworks/support/v17/leanback/res/drawable: aw_title_time_background.xml
Only in ../Desktop/android/frameworks/support/v17/leanback/res/drawable-xhdpi: lb_bluetooth.png
Only in ../Desktop/android/frameworks/support/v17/leanback/res/drawable-xhdpi: lb_eth.png
Only in ../Desktop/android/frameworks/support/v17/leanback/res/drawable-xhdpi: lb_udisk.png
Only in ../Desktop/android/frameworks/support/v17/leanback/res/drawable-xhdpi: lb_wifi_level1.png
Only in ../Desktop/android/frameworks/support/v17/leanback/res/drawable-xhdpi: lb_wifi_level2.png
Only in ../Desktop/android/frameworks/support/v17/leanback/res/drawable-xhdpi: lb_wifi_level3.png
Only in ../Desktop/android/frameworks/support/v17/leanback/res/drawable-xhdpi: lb_wifi_level4.png
Only in ../Desktop/android/frameworks/support/v17/leanback/res/drawable-xhdpi: lb_wifi.png
Only in ../Desktop/android/frameworks/support/v17/leanback/res/layout: lb_status_bar.xml
diff -ur ../aosp/frameworks/support/v17/leanback/res/layout/lb_title_view.xml ../Desktop/android/frameworks/support/v17/leanback/res/layout/lb_title_view.xml
--- ../aosp/frameworks/support/v17/leanback/res/layout/lb_title_view.xml	2018-08-06 15:41:34.456082471 +0200
+++ ../Desktop/android/frameworks/support/v17/leanback/res/layout/lb_title_view.xml	2017-11-23 05:21:58.000000000 +0100
@@ -22,24 +22,36 @@
         android:maxWidth="@dimen/lb_browse_title_icon_max_width"
         android:adjustViewBounds="true"
         android:layout_height="@dimen/lb_browse_title_icon_height"
-        android:layout_gravity="center_vertical|end"
+        android:layout_gravity="center_vertical|left"
         android:src="@null"
         android:visibility="gone"
         style="?attr/browseTitleIconStyle"/>
 
-    <TextView
-        android:id="@+id/title_text"
+    <!--原来显示logo用的，直接放中间显示时间 -->
+    <TextView  
+        android:id="@+id/title_text"   
         android:layout_width="wrap_content"
-        android:layout_height="@dimen/lb_browse_title_height"
-        android:layout_gravity="center_vertical|end"
+        android:layout_height="@dimen/lb_browse_title_time_text_height"
+        android:layout_gravity="center_vertical|right"
+	android:layout_marginRight="146dp"
+        android:gravity="center_vertical"
+        android:paddingLeft="20dp"
+        android:paddingRight="20dp"
         style="?attr/browseTitleTextStyle"/>
 
+    <android.support.v17.leanback.widget.StatusBarView
+	android:id="@+id/title_status"
+        android:layout_height="wrap_content"
+        android:layout_width="wrap_content"
+	android:layout_marginRight="0dp"
+	android:layout_gravity="center_vertical|right"/>
+
     <android.support.v17.leanback.widget.SearchOrbView
         android:id="@+id/title_orb"
         android:layout_height="wrap_content"
         android:layout_width="wrap_content"
         android:transitionGroup="true"
         android:layout_gravity="center_vertical|start"
-        android:visibility="invisible" />
+        android:visibility="gone" />
 
 </merge>
diff -ur ../aosp/frameworks/support/v17/leanback/res/values/attrs.xml ../Desktop/android/frameworks/support/v17/leanback/res/values/attrs.xml
--- ../aosp/frameworks/support/v17/leanback/res/values/attrs.xml	2018-08-06 15:41:34.520083293 +0200
+++ ../Desktop/android/frameworks/support/v17/leanback/res/values/attrs.xml	2017-11-23 05:21:58.000000000 +0100
@@ -319,6 +319,11 @@
         <!-- Default color for SectionHeader, by default same as defaultSearchColor -->
         <attr name="defaultSectionHeaderColor" format="reference|color" />
 
+        <!-- Style for StatusBarView -->
+        <attr name="statusBarViewStyle" format="reference"/>
+        <attr name="defaultIcon" format="reference" />
+
+
         <!-- Style for searchOrb -->
         <attr name="searchOrbViewStyle" format="reference"/>
         <attr name="defaultSearchIcon" format="reference" />
diff -ur ../aosp/frameworks/support/v17/leanback/res/values/dimens.xml ../Desktop/android/frameworks/support/v17/leanback/res/values/dimens.xml
--- ../aosp/frameworks/support/v17/leanback/res/values/dimens.xml	2018-08-06 15:41:34.520083293 +0200
+++ ../Desktop/android/frameworks/support/v17/leanback/res/values/dimens.xml	2017-11-23 05:21:58.000000000 +0100
@@ -17,10 +17,10 @@
 <resources>
     <dimen name="lb_list_row_height">224dp</dimen>
 
-    <dimen name="lb_browse_padding_start">56dp</dimen>
-    <dimen name="lb_browse_padding_top">27dp</dimen>
-    <dimen name="lb_browse_padding_end">56dp</dimen>
-    <dimen name="lb_browse_padding_bottom">48dp</dimen>
+    <dimen name="lb_browse_padding_start">45dp</dimen>
+    <dimen name="lb_browse_padding_top">30dp</dimen>
+    <dimen name="lb_browse_padding_end">45dp</dimen>
+    <dimen name="lb_browse_padding_bottom">30dp</dimen>
     <dimen name="lb_browse_rows_margin_start">238dp</dimen>
     <dimen name="lb_browse_rows_margin_top">167dp</dimen>
     <dimen name="lb_browse_rows_fading_edge">16dp</dimen>
@@ -30,6 +30,9 @@
     <dimen name="lb_browse_title_icon_max_width">584dp</dimen>
     <dimen name="lb_browse_title_icon_height">60dp</dimen>
     <dimen name="lb_browse_title_text_size">44sp</dimen>
+    
+    <dimen name="lb_browse_title_time_text_height">26dp</dimen>
+    <dimen name="lb_browse_title_time_text_size">16sp</dimen>
 
     <dimen name="lb_browse_headers_width">270dp</dimen>
     <integer name="lb_browse_headers_transition_delay">150</integer>
@@ -59,9 +62,9 @@
     <dimen name="lb_browse_expanded_row_no_hovercard_bottom_padding">28dp</dimen>
 
     <item name="lb_focus_zoom_factor_xsmall" type="fraction">106%</item>
-    <item name="lb_focus_zoom_factor_small" type="fraction">110%</item>
-    <item name="lb_focus_zoom_factor_medium" type="fraction">114%</item>
-    <item name="lb_focus_zoom_factor_large" type="fraction">118%</item>
+    <item name="lb_focus_zoom_factor_small" type="fraction">115%</item>
+    <item name="lb_focus_zoom_factor_medium" type="fraction">125%</item>
+    <item name="lb_focus_zoom_factor_large" type="fraction">130%</item>
 
     <dimen name="lb_details_overview_height_large">274dp</dimen>
     <dimen name="lb_details_overview_height_small">159dp</dimen>
@@ -165,7 +168,7 @@
     <dimen name="lb_error_under_message_baseline_margin">24dp</dimen>
 
     <item name="lb_view_active_level" type="fraction">0%</item>
-    <item name="lb_view_dimmed_level" type="fraction">60%</item>
+    <item name="lb_view_dimmed_level" type="fraction">0%</item>
 
     <!-- Search bar -->
     <dimen name="lb_search_bar_height">60dp</dimen>
diff -ur ../aosp/frameworks/support/v17/leanback/res/values/styles.xml ../Desktop/android/frameworks/support/v17/leanback/res/values/styles.xml
--- ../aosp/frameworks/support/v17/leanback/res/values/styles.xml	2018-08-06 15:41:34.524083344 +0200
+++ ../Desktop/android/frameworks/support/v17/leanback/res/values/styles.xml	2017-11-23 05:21:58.000000000 +0100
@@ -25,7 +25,7 @@
 
     <style name="TextAppearance.Leanback.Title" parent="TextAppearance.Leanback">
         <item name="android:fontFamily">sans-serif-light</item>
-        <item name="android:textSize">@dimen/lb_browse_title_text_size</item>
+        <item name="android:textSize">@dimen/lb_browse_title_time_text_size</item>
         <item name="android:textColor">@color/lb_browse_title_color</item>
     </style>
 
Only in ../Desktop/android/frameworks/support/v17/leanback/src/android/support/v17/leanback/util: DeviceStateMonitor.java
diff -ur ../aosp/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/FocusHighlightHelper.java ../Desktop/android/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/FocusHighlightHelper.java
--- ../aosp/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/FocusHighlightHelper.java	2018-08-06 15:41:34.556083755 +0200
+++ ../Desktop/android/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/FocusHighlightHelper.java	2017-11-23 05:21:58.000000000 +0100
@@ -15,11 +15,14 @@
 
 import android.support.v17.leanback.R;
 import android.support.v17.leanback.graphics.ColorOverlayDimmer;
+import android.util.Log;
 import android.view.View;
 import android.view.animation.AccelerateDecelerateInterpolator;
 import android.view.animation.Interpolator;
 import android.animation.TimeAnimator;
 import android.content.res.Resources;
+import android.graphics.Color;
+
 import static android.support.v17.leanback.widget.FocusHighlight.ZOOM_FACTOR_NONE;
 import static android.support.v17.leanback.widget.FocusHighlight.ZOOM_FACTOR_SMALL;
 import static android.support.v17.leanback.widget.FocusHighlight.ZOOM_FACTOR_XSMALL;
@@ -31,6 +34,7 @@
  */
 public class FocusHighlightHelper {
 
+    private static final String TAG = "FocusHighlightHelper";
     static boolean isValidZoomIndex(int zoomIndex) {
         return zoomIndex == ZOOM_FACTOR_NONE || getResId(zoomIndex) > 0;
     }
@@ -64,6 +68,7 @@
         private final ColorOverlayDimmer mDimmer;
 
         void animateFocus(boolean select, boolean immediate) {
+            
             endAnimation();
             final float end = select ? 1 : 0;
             if (immediate) {
@@ -76,16 +81,19 @@
         }
 
         FocusAnimator(View view, float scale, boolean useDimmer, int duration) {
+            
             mView = view;
             mDuration = duration;
             mScaleDiff = scale - 1f;
             if (view instanceof ShadowOverlayContainer) {
+                
                 mWrapper = (ShadowOverlayContainer) view;
             } else {
                 mWrapper = null;
             }
             mAnimator.setTimeListener(this);
             if (useDimmer) {
+                
                 mDimmer = ColorOverlayDimmer.createDefault(view.getContext());
             } else {
                 mDimmer = null;
@@ -93,11 +101,13 @@
         }
 
         void setFocusLevel(float level) {
+            
             mFocusLevel = level;
             float scale = 1f + mScaleDiff * level;
             mView.setScaleX(scale);
             mView.setScaleY(scale);
             if (mWrapper != null) {
+                
                 mWrapper.setShadowFocusLevel(level);
             } else {
                 ShadowOverlayHelper.setNoneWrapperShadowFocusLevel(mView, level);
@@ -158,16 +168,25 @@
 
         @Override
         public void onItemFocused(View view, boolean hasFocus) {
+            
             view.setSelected(hasFocus);
+            if(hasFocus){
+                view.setBackgroundColor(Color.parseColor("#00ffffff"));
+            }
+            else{
+                view.setBackgroundColor(Color.parseColor("#00000000"));
+            }
             getOrCreateAnimator(view).animateFocus(hasFocus, false);
         }
 
         @Override
         public void onInitializeView(View view) {
+            
             getOrCreateAnimator(view).animateFocus(false, true);
         }
 
         private FocusAnimator getOrCreateAnimator(View view) {
+            
             FocusAnimator animator = (FocusAnimator) view.getTag(R.id.lb_focus_animator);
             if (animator == null) {
                 animator = new FocusAnimator(
@@ -191,6 +210,7 @@
      */
     public static void setupBrowseItemFocusHighlight(ItemBridgeAdapter adapter, int zoomIndex,
             boolean useDimmer) {
+        
         adapter.setFocusHighlight(new BrowseItemFocusHighlight(zoomIndex, useDimmer));
     }
 
diff -ur ../aosp/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/HeaderItem.java ../Desktop/android/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/HeaderItem.java
--- ../aosp/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/HeaderItem.java	2018-08-06 15:41:34.560083806 +0200
+++ ../Desktop/android/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/HeaderItem.java	2017-11-23 05:21:58.000000000 +0100
@@ -14,6 +14,7 @@
 package android.support.v17.leanback.widget;
 
 import static android.support.v17.leanback.widget.ObjectAdapter.NO_ID;
+import android.graphics.drawable.Drawable;
 
 /**
  * A header item describes the metadata of a {@link Row}, such as a category
@@ -23,7 +24,17 @@
 
     private final long mId;
     private final String mName;
+    private Drawable mIcon;
     private CharSequence mContentDescription;
+    /**
+     * Create a header item.  All fields are optional.
+     */
+    public HeaderItem(long id, String name,Drawable icon) {
+        mId = id;
+        mName = name;
+	mIcon = icon;
+    }
+
 
     /**
      * Create a header item.  All fields are optional.
@@ -31,13 +42,14 @@
     public HeaderItem(long id, String name) {
         mId = id;
         mName = name;
+	mIcon = null;
     }
 
     /**
      * Create a header item.
      */
     public HeaderItem(String name) {
-        this(NO_ID, name);
+        this(NO_ID, name , null);
     }
 
     /**
@@ -50,10 +62,13 @@
     /**
      * Returns the name of this header item.
      */
-    public final String getName() {
+    public  String getName() {
         return mName;
     }
 
+    public final Drawable getIcon() {
+	return mIcon;
+    }
     /**
      * Returns optional content description for the HeaderItem.  When it is null, {@link #getName()}
      * should be used for the content description.
diff -ur ../aosp/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/ListRowPresenter.java ../Desktop/android/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/ListRowPresenter.java
--- ../aosp/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/ListRowPresenter.java	2018-08-06 15:41:34.560083806 +0200
+++ ../Desktop/android/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/ListRowPresenter.java	2017-11-23 05:21:58.000000000 +0100
@@ -293,7 +293,7 @@
      * disabled dimming on focus.
      */
     public ListRowPresenter() {
-        this(FocusHighlight.ZOOM_FACTOR_MEDIUM);
+        this(FocusHighlight.ZOOM_FACTOR_SMALL);
     }
 
     /**
@@ -395,6 +395,7 @@
      * set to 1.
      */
     public void setNumRows(int numRows) {
+        
         this.mNumRows = numRows;
     }
 
@@ -406,7 +407,7 @@
         if (mShadowOverlayHelper == null) {
             mShadowOverlayHelper = new ShadowOverlayHelper.Builder()
                     .needsOverlay(needsDefaultListSelectEffect())
-                    .needsShadow(needsDefaultShadow())
+                    .needsShadow(false)//needsDefaultShadow())
                     .needsRoundedCorner(areChildRoundedCornersEnabled())
                     .preferZOrder(isUsingZOrder(context))
                     .keepForegroundDrawable(mKeepChildForeground)
@@ -430,6 +431,7 @@
                 new OnChildSelectedListener() {
             @Override
             public void onChildSelected(ViewGroup parent, View view, int position, long id) {
+                
                 selectChildView(rowViewHolder, view, true);
             }
         });
@@ -485,8 +487,10 @@
      * Perform operations when a child of horizontal grid view is selected.
      */
     private void selectChildView(ViewHolder rowViewHolder, View view, boolean fireEvent) {
+        
         if (view != null) {
             if (rowViewHolder.mSelected) {
+                
                 ItemBridgeAdapter.ViewHolder ibh = (ItemBridgeAdapter.ViewHolder)
                         rowViewHolder.mGridView.getChildViewHolder(view);
 
@@ -495,11 +499,23 @@
                             rowViewHolder.mGridView, view, ibh.mItem);
                 }
                 if (fireEvent && rowViewHolder.getOnItemViewSelectedListener() != null) {
+                    
+////////////////////////////////////
+////////////////////////////////////
+//                    ((RowContainerView) vh.mContainerViewHolder.view).setForegroundColor(
+//                            vh.mColorDimmer.getPaint().getColor());
+//                    
+  ///////////////////////
+                    
+  ///////////////////////
+                    
+                    
                     rowViewHolder.getOnItemViewSelectedListener().onItemSelected(
                             ibh.mHolder, ibh.mItem, rowViewHolder, rowViewHolder.mRow);
                 }
             }
         } else {
+            
             if (mHoverCardPresenterSelector != null) {
                 rowViewHolder.mHoverCardViewSwitcher.unselect();
             }
@@ -588,6 +604,7 @@
 
     @Override
     protected void onRowViewSelected(RowPresenter.ViewHolder holder, boolean selected) {
+        
         super.onRowViewSelected(holder, selected);
         ViewHolder vh = (ViewHolder) holder;
         setVerticalPadding(vh);
diff -ur ../aosp/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/RowHeaderPresenter.java ../Desktop/android/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/RowHeaderPresenter.java
--- ../aosp/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/RowHeaderPresenter.java	2018-08-06 15:41:34.564083858 +0200
+++ ../Desktop/android/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/RowHeaderPresenter.java	2017-11-23 05:21:58.000000000 +0100
@@ -14,12 +14,13 @@
 package android.support.v17.leanback.widget;
 
 import android.graphics.Paint;
+import android.graphics.drawable.Drawable;
 import android.support.v17.leanback.R;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 import android.widget.TextView;
-
+import android.util.Log;
 /**
  * RowHeaderPresenter provides a default presentation for {@link HeaderItem} using a
  * {@link RowHeaderView}. If a subclass creates its own view, the subclass must also override
@@ -108,6 +109,14 @@
         } else {
             viewHolder.view.setVisibility(View.VISIBLE);
             ((RowHeaderView) viewHolder.view).setText(headerItem.getName());
+	     //if(headerItem.getIcon()!=null){
+		Log.d("IKE","set icon now");
+		Drawable icon = headerItem.getIcon();
+		if(icon!=null){
+		    icon.setBounds(0,0,icon.getMinimumWidth(),icon.getMinimumHeight());
+	     	    ((RowHeaderView) viewHolder.view).setCompoundDrawables(icon,null,null,null);
+		}
+	    // }
             viewHolder.view.setContentDescription(headerItem.getContentDescription());
         }
     }
Only in ../Desktop/android/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget: StatusBarView.java
diff -ur ../aosp/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/TitleView.java ../Desktop/android/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/TitleView.java
--- ../aosp/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/TitleView.java	2018-08-06 15:41:34.568083909 +0200
+++ ../Desktop/android/frameworks/support/v17/leanback/src/android/support/v17/leanback/widget/TitleView.java	2017-11-23 05:21:58.000000000 +0100
@@ -17,6 +17,7 @@
 import android.graphics.drawable.Drawable;
 import android.support.v17.leanback.R;
 import android.util.AttributeSet;
+import android.util.Log;
 import android.view.LayoutInflater;
 import android.view.View;
 import android.widget.FrameLayout;
@@ -25,6 +26,9 @@
 
 import static android.support.v17.leanback.widget.TitleViewAdapter.BRANDING_VIEW_VISIBLE;
 import static android.support.v17.leanback.widget.TitleViewAdapter.SEARCH_VIEW_VISIBLE;
+
+import java.security.PrivilegedActionException;
+
 import static android.support.v17.leanback.widget.TitleViewAdapter.FULL_VIEW_VISIBLE;
 
 /**
@@ -32,6 +36,7 @@
  */
 public class TitleView extends FrameLayout implements TitleViewAdapter.Provider {
 
+    private static final String TAG = "TitleView";
     private ImageView mBadgeView;
     private TextView mTextView;
     private SearchOrbView mSearchOrbView;
@@ -95,7 +100,7 @@
     }
 
     public TitleView(Context context, AttributeSet attrs) {
-        this(context, attrs, R.attr.browseTitleViewStyle);
+        this(context, attrs, R.attr.browseTitleViewStyle);//这个应用的style影响着padding的宽高等,在dimens.xml中lb_browse_padding_top
     }
 
     public TitleView(Context context, AttributeSet attrs, int defStyleAttr) {
@@ -117,7 +122,9 @@
      */
     public void setTitle(CharSequence titleText) {
         mTextView.setText(titleText);
-        updateBadgeVisibility();
+        //updateBadgeVisibility();不要一直调用这个
+        if(mTextView.getVisibility() != View.VISIBLE)
+            mTextView.setVisibility(View.VISIBLE);
     }
 
     /**
@@ -149,6 +156,7 @@
     public void setOnSearchClickedListener(View.OnClickListener listener) {
         mHasSearchListener = listener != null;
         mSearchOrbView.setOnOrbClickedListener(listener);
+        
         updateSearchOrbViewVisiblity();
     }
 
@@ -191,7 +199,7 @@
      */
     public void updateComponentsVisibility(int flags) {
         this.flags = flags;
-
+        
         if ((flags & BRANDING_VIEW_VISIBLE) == BRANDING_VIEW_VISIBLE) {
             updateBadgeVisibility();
         } else {
@@ -204,18 +212,19 @@
     private void updateSearchOrbViewVisiblity() {
         int visibility = mHasSearchListener && (flags & SEARCH_VIEW_VISIBLE) == SEARCH_VIEW_VISIBLE
                 ? View.VISIBLE : View.INVISIBLE;
+        
         mSearchOrbView.setVisibility(visibility);
     }
 
     private void updateBadgeVisibility() {
         Drawable drawable = mBadgeView.getDrawable();
+        
         if (drawable != null) {
             mBadgeView.setVisibility(View.VISIBLE);
-            mTextView.setVisibility(View.GONE);
         } else {
             mBadgeView.setVisibility(View.GONE);
-            mTextView.setVisibility(View.VISIBLE);
         }
+        mTextView.setVisibility(View.VISIBLE);//中间显示时间
     }
 
     @Override
