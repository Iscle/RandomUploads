Only in b/external/archive-patcher: .emptycommitmark
diff -ur a/external/boringssl/src/crypto/rsa/rsa.c b/external/boringssl/src/crypto/rsa/rsa.c
--- a/external/boringssl/src/crypto/rsa/rsa.c	2018-08-06 15:35:56.811741813 +0200
+++ b/external/boringssl/src/crypto/rsa/rsa.c	2017-11-23 05:19:22.000000000 +0100
@@ -471,7 +471,7 @@
   return ret;
 }
 
-int RSA_verify(int hash_nid, const uint8_t *msg, size_t msg_len,
+ __attribute__((weak))  int RSA_verify(int hash_nid, const uint8_t *msg, size_t msg_len,
                const uint8_t *sig, size_t sig_len, RSA *rsa) {
   const size_t rsa_size = RSA_size(rsa);
   uint8_t *buf = NULL;
Only in b/external/chromium-webview: AnyBugsReadThis
Only in b/external/donuts: .emptycommitmark
diff -ur a/external/e2fsprogs/lib/blkid/Android.mk b/external/e2fsprogs/lib/blkid/Android.mk
--- a/external/e2fsprogs/lib/blkid/Android.mk	2018-08-06 15:36:49.452419695 +0200
+++ b/external/e2fsprogs/lib/blkid/Android.mk	2017-11-23 05:19:46.000000000 +0100
@@ -13,6 +13,7 @@
 	save.c \
 	tag.c \
 	version.c \
+	probe_exfat.c \
 
 
 libext2_blkid_shared_libraries := libext2_uuid
diff -ur a/external/e2fsprogs/lib/blkid/probe.c b/external/e2fsprogs/lib/blkid/probe.c
--- a/external/e2fsprogs/lib/blkid/probe.c	2018-08-06 15:36:49.476420003 +0200
+++ b/external/e2fsprogs/lib/blkid/probe.c	2017-11-23 05:19:46.000000000 +0100
@@ -36,6 +36,10 @@
 #include "uuid/uuid.h"
 #include "probe.h"
 
+extern int probe_exfat(struct blkid_probe *probe,
+                             struct blkid_magic *id __BLKID_ATTR((unused)),
+                             unsigned char *buf);
+
 static int figure_label_len(const unsigned char *label, int len)
 {
 	const unsigned char *end = label + len - 1;
@@ -85,6 +89,11 @@
 	}
 }
 
+unsigned char *blkid_probe_get_buffer(struct blkid_probe *pr,
+			  blkid_loff_t off, size_t len)
+{
+	return get_buffer(pr, off, len);
+}
 
 /*
  * This is a special case code to check for an MDRAID device.  We do
@@ -1407,6 +1416,7 @@
 /*  type     kboff   sboff len  magic			probe */
   { "oracleasm", 0,	32,  8, "ORCLDISK",		probe_oracleasm },
   { "ntfs",	 0,	 3,  8, "NTFS    ",		probe_ntfs },
+  { "exfat",	 0,	 3,  8, "EXFAT   ",		probe_exfat },
   { "jbd",	 1,   0x38,  2, "\123\357",		probe_jbd },
   { "ext4dev",	 1,   0x38,  2, "\123\357",		probe_ext4dev },
   { "ext4",	 1,   0x38,  2, "\123\357",		probe_ext4 },
Only in b/external/e2fsprogs/lib/blkid: probe_exfat.c
diff -ur a/external/e2fsprogs/lib/blkid/probe.h b/external/e2fsprogs/lib/blkid/probe.h
--- a/external/e2fsprogs/lib/blkid/probe.h	2018-08-06 15:36:49.480420055 +0200
+++ b/external/e2fsprogs/lib/blkid/probe.h	2017-11-23 05:19:46.000000000 +0100
@@ -33,6 +33,9 @@
 typedef int (*blkid_probe_t)(struct blkid_probe *probe,
 			     struct blkid_magic *id, unsigned char *buf);
 
+unsigned char *blkid_probe_get_buffer(struct blkid_probe *pr,
+                      blkid_loff_t off, size_t len);
+
 struct blkid_magic {
 	const char	*bim_type;	/* type name for this magic */
 	long		bim_kboff;	/* kilobyte offset of superblock */
diff -ur a/external/fsck_msdos/check.c b/external/fsck_msdos/check.c
--- a/external/fsck_msdos/check.c	2018-08-06 15:37:03.800604383 +0200
+++ b/external/fsck_msdos/check.c	2017-11-23 05:19:54.000000000 +0100
@@ -54,6 +54,7 @@
  * this whole thing and optimize for less memory
  */
 #define FAT_COMPARE_MAX_KB 4096
+#define FAT_MAX_SECTORS 400000
 
 int
 checkfilesys(const char *fname)
@@ -100,6 +101,12 @@
 		goto out;
 	}
 
+    printf("the udisk capacity is %u*%u,the NumSectors is %u,the NumClusters is %u\n",boot.FATsecs,boot.BytesPerSec,boot.NumSectors,boot.NumClusters);
+    if (boot.FATsecs > FAT_MAX_SECTORS ){
+        printf("FAT32: donot check when the capacity is larger than 2T!\n");
+        ret = 0;
+        goto out;
+    }
         if (((boot.FATsecs * boot.BytesPerSec) / 1024) > FAT_COMPARE_MAX_KB)
             skip_fat_compare = 1;
 
diff -ur a/external/junit/Common.mk b/external/junit/Common.mk
--- a/external/junit/Common.mk	2018-08-06 15:37:42.909107618 +0200
+++ b/external/junit/Common.mk	2017-11-23 05:20:05.000000000 +0100
@@ -21,7 +21,8 @@
 src/junit/framework/TestFailure.java \
 src/junit/framework/TestListener.java \
 src/junit/framework/TestResult.java \
-src/junit/framework/TestSuite.java
+src/junit/framework/TestSuite.java \
+src/junit/framework/TestManager.java
 
 # List of source to build into the android.test.runner library
 #
Only in b/external/junit/src/junit/framework: TestManager.java
diff -ur a/external/junit/src/junit/framework/TestResult.java b/external/junit/src/junit/framework/TestResult.java
--- a/external/junit/src/junit/framework/TestResult.java	2018-08-06 15:37:42.913107668 +0200
+++ b/external/junit/src/junit/framework/TestResult.java	2017-11-23 05:20:05.000000000 +0100
@@ -6,6 +6,7 @@
 import java.util.List;
 import java.util.Vector;
 
+
 /**
  * A <code>TestResult</code> collects the results of executing
  * a test case. It is an instance of the Collecting Parameter pattern.
@@ -23,6 +24,7 @@
 	// END android-changed
 	protected int fRunTests;
 	private boolean fStop;
+	private TestManager fTestManager;
 	
 	public TestResult() {
 		// BEGIN android-changed to Vector
@@ -30,6 +32,7 @@
 		fErrors= new Vector<TestFailure>();
 		fListeners= new Vector<TestListener>();
 		// END android-changed
+		fTestManager = new TestManager();
 		fRunTests= 0;
 		fStop= false;
 	}
@@ -112,6 +115,9 @@
 		startTest(test);
 		Protectable p= new Protectable() {
 			public void protect() throws Throwable {
+				if(fTestManager.isThisCaseOk(test.toString())){
+					return;
+				}
 				test.runBare();
 			}
 		};
diff -ur a/external/libusb/config.h b/external/libusb/config.h
--- a/external/libusb/config.h	2018-08-06 15:38:04.265382320 +0200
+++ b/external/libusb/config.h	2017-11-23 05:20:15.000000000 +0100
@@ -9,7 +9,7 @@
 /* #undef ENABLE_DEBUG_LOGGING */
 
 /* Message logging */
-#define ENABLE_LOGGING 1
+//#define ENABLE_LOGGING 1
 
 /* Define to 1 if you have the <dlfcn.h> header file. */
 #define HAVE_DLFCN_H 1
@@ -18,7 +18,9 @@
 #define HAVE_INTTYPES_H 1
 
 /* Define to 1 if you have the `rt' library (-lrt). */
-/* #undef HAVE_LIBRT */
+#ifdef _SHARED_LIBRARY_	
+#define HAVE_LIBRT 1
+#endif
 
 /* Define to 1 if you have the <memory.h> header file. */
 #define HAVE_MEMORY_H 1
@@ -52,10 +54,10 @@
 /* #undef NO_MINUS_C_MINUS_O */
 
 /* Darwin backend */
-#define OS_DARWIN /**/
+/* #define OS_DARWIN */
 
 /* Linux backend */
-/* #undef OS_LINUX */
+#define OS_LINUX
 
 /* Name of package */
 #define PACKAGE "libusb"
@@ -81,11 +83,16 @@
 /* Define to 1 if you have the ANSI C header files. */
 #define STDC_HEADERS 1
 
+#ifndef _SHARED_LIBRARY_
 /* Backend handles timeout */
 #define USBI_OS_HANDLES_TIMEOUT /**/
 
 /* timerfd headers available */
 /* #undef USBI_TIMERFD_AVAILABLE */
+#else
+#undef USBI_OS_HANDLES_TIMEOUT
+#undef USBI_TIMERFD_AVAILABLE
+#endif
 
 /* Version number of package */
 #define VERSION "1.0.8"
Only in b/external/libusb/libusb: Android.mk
diff -ur a/external/libusb/libusb/core.c b/external/libusb/libusb/core.c
--- a/external/libusb/libusb/core.c	2018-08-06 15:38:04.273382424 +0200
+++ b/external/libusb/libusb/core.c	2017-11-23 05:20:15.000000000 +0100
@@ -32,6 +32,8 @@
 #include "libusb.h"
 #include "libusbi.h"
 
+#include <android/log.h>
+
 #if defined(OS_LINUX)
 const struct usbi_os_backend * const usbi_backend = &linux_usbfs_backend;
 #elif defined(OS_DARWIN)
@@ -1538,7 +1540,11 @@
 {
 	va_list args;
 	FILE *stream = stdout;
+#if defined(__ANDROID__)
+    int prio;
+#else
 	const char *prefix;
+#endif
 
 #ifndef ENABLE_DEBUG_LOGGING
 	USBI_GET_CONTEXT(ctx);
@@ -1550,6 +1556,30 @@
 		return;
 #endif
 
+#if defined(__ANDROID__)
+       switch (level) {
+               case LOG_LEVEL_INFO:
+                       prio = ANDROID_LOG_INFO;
+                       break;
+               case LOG_LEVEL_WARNING:
+                       prio = ANDROID_LOG_WARN;
+                       break;
+               case LOG_LEVEL_ERROR:
+                       prio = ANDROID_LOG_ERROR;
+                       break;
+               case LOG_LEVEL_DEBUG:
+                       prio = ANDROID_LOG_DEBUG;
+                       break;
+               default:
+                       prio = ANDROID_LOG_UNKNOWN;
+                       break;
+       }
+
+       va_start (args, format);
+       __android_log_vprint(prio, "LibUsb", format, args);
+       va_end (args);
+#else
+
 	switch (level) {
 	case LOG_LEVEL_INFO:
 		prefix = "info";
@@ -1579,5 +1609,6 @@
 	va_end (args);
 
 	fprintf(stream, "\n");
+#endif
 }
 
diff -ur a/external/libusb/libusb/io.c b/external/libusb/libusb/io.c
--- a/external/libusb/libusb/io.c	2018-08-06 15:38:04.273382424 +0200
+++ b/external/libusb/libusb/io.c	2017-11-23 05:20:15.000000000 +0100
@@ -36,6 +36,12 @@
 
 #include "libusbi.h"
 
+#define TIMESPEC_TO_TIMEVAL(tv, ts)                                     \
+        do {                                                            \
+                (tv)->tv_sec = (ts)->tv_sec;                            \
+                (tv)->tv_usec = (ts)->tv_nsec / 1000;                   \
+		} while (0)
+
 /**
  * \page io Synchronous and asynchronous device I/O
  *
Only in b/external/lld: .emptycommitmark
Only in b/external: multi_ir
Only in b/external/selinux/prebuilts/lib: libpcre.so.3
diff -ur a/external/tinyalsa/include/tinyalsa/asoundlib.h b/external/tinyalsa/include/tinyalsa/asoundlib.h
--- a/external/tinyalsa/include/tinyalsa/asoundlib.h	2018-08-06 15:39:37.350578870 +0200
+++ b/external/tinyalsa/include/tinyalsa/asoundlib.h	2017-11-23 05:20:52.000000000 +0100
@@ -31,6 +31,8 @@
 
 #include <sys/time.h>
 #include <stddef.h>
+#include <assert.h>
+#include <sound/asound.h>
 
 #if defined(__cplusplus)
 extern "C" {
@@ -68,6 +70,9 @@
 #define	PCM_STATE_SUSPENDED	7
 #define	PCM_STATE_DISCONNECTED	8
 
+typedef struct snd_pcm_info snd_pcm_info_t;
+#define __tinyalsa_alloca(ptr,type) do { *ptr = (type *) alloca(sizeof(type)); memset(*ptr, 0, sizeof(type)); } while (0)
+#define pcm_info_alloca(ptr) __tinyalsa_alloca(ptr, snd_pcm_info_t)
 /* Bit formats */
 enum pcm_format {
     PCM_FORMAT_INVALID = -1,
@@ -93,26 +98,25 @@
     unsigned int period_count;
     enum pcm_format format;
 
-    /* Values to use for the ALSA start, stop and silence thresholds, and
-     * silence size.  Setting any one of these values to 0 will cause the
-     * default tinyalsa values to be used instead.
-     * Tinyalsa defaults are as follows.
+    /* Values to use for the ALSA start, stop and silence thresholds.  Setting
+     * any one of these values to 0 will cause the default tinyalsa values to be
+     * used instead.  Tinyalsa defaults are as follows.
      *
      * start_threshold   : period_count * period_size
      * stop_threshold    : period_count * period_size
      * silence_threshold : 0
-     * silence_size      : 0
      */
     unsigned int start_threshold;
     unsigned int stop_threshold;
     unsigned int silence_threshold;
-    unsigned int silence_size;
 
     /* Minimum number of frames available before pcm_mmap_write() will actually
      * write into the kernel buffer. Only used if the stream is opened in mmap mode
      * (pcm_open() called with PCM_MMAP flag set).   Use 0 for default.
      */
     int avail_min;
+    int raw_flag;
+    unsigned int in_init_channels;//keep the record init channels
 };
 
 /* PCM parameters */
@@ -136,6 +140,14 @@
     PCM_PARAM_BUFFER_BYTES,
     PCM_PARAM_TICK_TIME,
 };
+/** PCM stream (direction) */
+enum pcm_stream {
+	/** Playback stream */
+	PCM_STREAM_PLAYBACK = 0,
+	/** Capture stream */
+	PCM_STREAM_CAPTURE,
+	PCM_STREAM_LAST = PCM_STREAM_CAPTURE
+};
 
 /* Mixer control types */
 enum mixer_ctl_type {
@@ -226,6 +238,7 @@
  */
 int pcm_write(struct pcm *pcm, const void *data, unsigned int count);
 int pcm_read(struct pcm *pcm, void *data, unsigned int count);
+int pcm_read_ex(struct pcm *pcm, void *data, unsigned int count);
 
 /*
  * mmap() support.
@@ -235,7 +248,6 @@
 int pcm_mmap_begin(struct pcm *pcm, void **areas, unsigned int *offset,
                    unsigned int *frames);
 int pcm_mmap_commit(struct pcm *pcm, unsigned int offset, unsigned int frames);
-int pcm_mmap_avail(struct pcm *pcm);
 
 /* Prepare the PCM substream to be triggerable */
 int pcm_prepare(struct pcm *pcm);
@@ -248,12 +260,43 @@
 
 /* Interrupt driven API */
 int pcm_wait(struct pcm *pcm, int timeout);
-int pcm_get_poll_fd(struct pcm *pcm);
 
 /* Change avail_min after the stream has been opened with no need to stop the stream.
  * Only accepted if opened with PCM_MMAP and PCM_NOIRQ flags
  */
 int pcm_set_avail_min(struct pcm *pcm, int avail_min);
+/**
+ *  Set wanted device inside a PCM info container
+ *  param obj PCM info container
+ *  param val Device number
+ **/
+void pcm_info_set_device(snd_pcm_info_t *obj, unsigned int val);
+/**
+ * Set wanted subdevice inside a PCM info container
+ * param obj PCM info container
+ * param val Subdevice number
+ **/
+void pcm_info_set_subdevice(snd_pcm_info_t *obj, unsigned int val);
+
+/**
+ * param obj PCM info container
+ * param val Stream
+ **/
+void pcm_info_set_stream(snd_pcm_info_t *obj, unsigned int val);
+
+/**
+ * Get id from a PCM info container
+ * param obj PCM info container
+ * return short id of PCM
+ **/
+const char *pcm_info_get_id(snd_pcm_info_t *obj);
+
+/**
+ * Get name from a PCM info container
+ * param obj PCM info container
+ * return name of PCM
+ **/
+const char *pcm_info_get_name(snd_pcm_info_t *obj);
 
 /*
  * MIXER API
@@ -303,6 +346,40 @@
 int mixer_ctl_get_range_min(struct mixer_ctl *ctl);
 int mixer_ctl_get_range_max(struct mixer_ctl *ctl);
 
+/**
+ * Try to determine the next card
+ * param rcard pointer to card number
+ * result zero if success, otherwise a negative error code
+ **/
+int mixer_card_next(int *rcard);
+
+/**
+ * Get next PCM device number
+ * param device current device on entry and next device on return
+ * return 0 on success otherwise a negative error code
+ **/
+int mixer_ctl_pcm_next_device(struct mixer *mixer, int *device);
+
+/**
+ * Get info about a PCM device
+ * param info PCM device id/info pointer
+ * return 0 on success otherwise a negative error code
+ **/
+int mixer_ctl_pcm_info(struct mixer *mixer, snd_pcm_info_t *info);
+
+/**
+ * Get card identifier from a CTL card info
+ * param obj CTL card info
+ * return card identifier
+ **/
+const char *mixer_ctl_card_info_get_id(const struct snd_ctl_card_info *obj);
+
+/**
+ * Get card identifier from a CTL card info
+ * param obj CTL card info
+ * return card name
+ **/
+const char *mixer_ctl_card_info_get_name(const struct snd_ctl_card_info *obj);
 #if defined(__cplusplus)
 }  /* extern "C" */
 #endif
diff -ur a/external/tinyalsa/pcm.c b/external/tinyalsa/pcm.c
--- a/external/tinyalsa/pcm.c	2018-08-06 15:39:37.350578870 +0200
+++ b/external/tinyalsa/pcm.c	2017-11-23 05:20:52.000000000 +0100
@@ -25,6 +25,9 @@
 ** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
 ** DAMAGE.
 */
+#define LOG_TAG "alsa_pcm"
+#define LOG_NDEBUG 0
+#include <cutils/log.h>
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -49,6 +52,7 @@
 #include <tinyalsa/asoundlib.h>
 
 #define PARAM_MAX SNDRV_PCM_HW_PARAM_LAST_INTERVAL
+//#define SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP (1<<2)
 
 /* Logs information into a string; follows snprintf() in that
  * offset may be greater than size, and though no characters are copied
@@ -216,6 +220,85 @@
     return 0;
 }
 
+#define DEBUG 0
+#if DEBUG
+static const char *param_name[PARAM_MAX+1] = {
+    [SNDRV_PCM_HW_PARAM_ACCESS] = "access",
+    [SNDRV_PCM_HW_PARAM_FORMAT] = "format",
+    [SNDRV_PCM_HW_PARAM_SUBFORMAT] = "subformat",
+
+    [SNDRV_PCM_HW_PARAM_SAMPLE_BITS] = "sample_bits",
+    [SNDRV_PCM_HW_PARAM_FRAME_BITS] = "frame_bits",
+    [SNDRV_PCM_HW_PARAM_CHANNELS] = "channels",
+    [SNDRV_PCM_HW_PARAM_RATE] = "rate",
+    [SNDRV_PCM_HW_PARAM_PERIOD_TIME] = "period_time",
+    [SNDRV_PCM_HW_PARAM_PERIOD_SIZE] = "period_size",
+    [SNDRV_PCM_HW_PARAM_PERIOD_BYTES] = "period_bytes",
+    [SNDRV_PCM_HW_PARAM_PERIODS] = "periods",
+    [SNDRV_PCM_HW_PARAM_BUFFER_TIME] = "buffer_time",
+    [SNDRV_PCM_HW_PARAM_BUFFER_SIZE] = "buffer_size",
+    [SNDRV_PCM_HW_PARAM_BUFFER_BYTES] = "buffer_bytes",
+    [SNDRV_PCM_HW_PARAM_TICK_TIME] = "tick_time",
+};
+
+static void param_dump(struct snd_pcm_hw_params *p)
+{
+    int n;
+
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_MASK;
+         n <= SNDRV_PCM_HW_PARAM_LAST_MASK; n++) {
+            struct snd_mask *m = param_to_mask(p, n);
+#if defined(__ANDROID__)
+            ALOGV("%s = %08x%08x\n", param_name[n],
+                   m->bits[1], m->bits[0]);
+#endif
+    }
+    for (n = SNDRV_PCM_HW_PARAM_FIRST_INTERVAL;
+         n <= SNDRV_PCM_HW_PARAM_LAST_INTERVAL; n++) {
+            struct snd_interval *i = param_to_interval(p, n);
+#if defined(__ANDROID__)
+            ALOGV("%s = (%d,%d) omin=%d omax=%d int=%d empty=%d\n",
+                   param_name[n], i->min, i->max, i->openmin,
+                   i->openmax, i->integer, i->empty);
+#endif
+    }
+#if defined(__ANDROID__)
+    ALOGV("info = %08x\n", p->info);
+    ALOGV("msbits = %d\n", p->msbits);
+    ALOGV("rate = %d/%d\n", p->rate_num, p->rate_den);
+    ALOGV("fifo = %d\n", (int) p->fifo_size);
+#endif
+}
+
+static void info_dump(struct snd_pcm_info *info)
+{
+#if defined(__ANDROID__)
+    ALOGV("device = %d\n", info->device);
+    ALOGV("subdevice = %d\n", info->subdevice);
+    ALOGV("stream = %d\n", info->stream);
+    ALOGV("card = %d\n", info->card);
+    ALOGV("id = '%s'\n", info->id);
+    ALOGV("name = '%s'\n", info->name);
+    ALOGV("subname = '%s'\n", info->subname);
+    ALOGV("dev_class = %d\n", info->dev_class);
+    ALOGV("dev_subclass = %d\n", info->dev_subclass);
+    ALOGV("subdevices_count = %d\n", info->subdevices_count);
+    ALOGV("subdevices_avail = %d\n", info->subdevices_avail);
+#endif
+}
+#else
+static void param_dump(struct snd_pcm_hw_params *p)
+{
+    if(p != NULL)
+    {}
+}
+static void info_dump(struct snd_pcm_info *info)
+{
+    if(info != NULL)
+    {}
+}
+#endif
+
 static void param_init(struct snd_pcm_hw_params *p)
 {
     int n;
@@ -256,6 +339,10 @@
     void *mmap_buffer;
     unsigned int noirq_frames_per_msec;
     int wait_for_avail_min;
+
+    // star add
+    int capture_channels;
+    short * p_capture_buf;
 };
 
 unsigned int pcm_get_buffer_size(struct pcm *pcm)
@@ -447,7 +534,8 @@
     int frames;
     int rc;
     snd_pcm_uframes_t hw_ptr;
-
+    if (pcm == NULL)
+        return -1;
     if (!pcm_is_ready(pcm))
         return -1;
 
@@ -471,7 +559,7 @@
 
     if (frames < 0)
         frames += pcm->boundary;
-    else if (frames > (int)pcm->boundary)
+    else if (frames >= (int)pcm->boundary)
         frames -= pcm->boundary;
 
     *avail = (unsigned int)frames;
@@ -525,6 +613,74 @@
     if (!(pcm->flags & PCM_IN))
         return -EINVAL;
 
+    x.buf = (void *)pcm->p_capture_buf;
+    x.frames = count / (pcm->config.channels *
+                        pcm_format_to_bits(pcm->config.format) / 8);
+
+    for (;;) {
+        if (!pcm->running) {
+           if (pcm_start(pcm) < 0) {
+                fprintf(stderr, "start error");
+                return -errno;
+            }
+        }
+        if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_READI_FRAMES, &x)) {
+            pcm->running = 0;
+            if (errno == EPIPE) {
+                    /* we failed to make our window -- try to restart */
+                pcm->underruns++;
+                continue;
+            }
+            return oops(pcm, errno, "cannot read stream data");
+        }
+        break;
+    }
+
+    if (((pcm->capture_channels == 1) && (pcm->config.channels == 1)) ||
+        ((pcm->capture_channels == 2) && (pcm->config.channels == 2)))
+    {
+        unsigned int cnt = 0;
+        short * p_out_data = data;
+
+        for (cnt = 0; cnt < (count >> 1); cnt++)
+        {
+            *(p_out_data + cnt) = *(pcm->p_capture_buf + cnt);
+        }
+    }
+    else if ((pcm->capture_channels == 2) && (pcm->config.channels == 1))
+    {
+        unsigned int offset = 0, cnt = 0;
+        short * p_out_data = data;
+
+        for (cnt = 0; cnt < x.frames; cnt++)
+        {
+            offset = cnt << 1;      // short
+            *(p_out_data + cnt) =  (*(pcm->p_capture_buf + offset) >> 1) + (*(pcm->p_capture_buf + offset + 1) >> 1);
+        }
+    }
+    else if ((pcm->capture_channels == 1) && (pcm->config.channels == 2))
+    {
+        unsigned int offset = 0, cnt = 0;
+        short * p_out_data = data;
+        for (cnt = 0; cnt < (count >> 1); cnt++)
+        {
+            offset = cnt * 2;
+            *(p_out_data + offset) = *(pcm->p_capture_buf + cnt);
+            *(p_out_data + offset + 1) = *(pcm->p_capture_buf + cnt);
+        }
+    }
+
+    return 0;
+
+}
+
+int pcm_read_ex(struct pcm *pcm, void *data, unsigned int count)
+{
+    struct snd_xferi x;
+
+    if (!(pcm->flags & PCM_IN))
+        return -EINVAL;
+
     x.buf = data;
     x.frames = count / (pcm->config.channels *
                         pcm_format_to_bits(pcm->config.format) / 8);
@@ -835,9 +991,329 @@
     return 0;
 }
 
+static int pcm_rate[] = {96000,48000,44100,32000,24000,22050,16000,12000,11025,8000};
+
+static int size_rate = sizeof(pcm_rate) / sizeof(pcm_rate[0]);
+
+struct pcm *pcm_open_req(unsigned int card, unsigned int device,
+                     unsigned int flags, struct pcm_config *config, int requested_rate)
+{
+    struct pcm *pcm;
+    struct snd_pcm_info info;
+    struct snd_pcm_hw_params params;
+    struct snd_pcm_sw_params sparams;
+    char fn[256];
+    int rc;
+    int index = 0, cnt = 0;
+    int ret = -1;
+#if defined(__ANDROID__)
+    ALOGD("pcm_open_req, %s card: %d, device: %d, req_rate: %d",
+        (flags & PCM_IN ? "capture" : "playback"), card, device, requested_rate);
+#endif
+    pcm = calloc(1, sizeof(struct pcm));
+    if (!pcm || !config)
+        return &bad_pcm; /* TODO: could support default config here */
+
+    pcm->config = *config;
+
+    snprintf(fn, sizeof(fn), "/dev/snd/pcmC%uD%u%c", card, device,
+             flags & PCM_IN ? 'c' : 'p');
+
+
+    if ((flags & PCM_IN))
+    {
+        pcm->capture_channels = config->channels;//config->in_init_channels;
+        pcm->config.channels = config->channels;
+
+        pcm->p_capture_buf = (short*)calloc(1, 1024 * 8);
+        if (pcm->p_capture_buf == 0)
+        {
+#if defined(__ANDROID__)
+            ALOGE("calloc capture buffer failed");
+#endif
+            goto fail_close;
+        }
+    }
+
+    pcm->flags = flags;
+    pcm->fd = open(fn, O_RDWR);
+    if (pcm->fd < 0) {
+        oops(pcm, errno, "cannot open device '%s'", fn);
+        return pcm;
+    }
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_INFO, &info)) {
+        oops(pcm, errno, "cannot get info");
+        goto fail_close;
+    }
+    info_dump(&info);
+
+    for (index = 0; index < size_rate; index++)
+    {
+        if (pcm_rate[index] == requested_rate)
+        {
+            break;
+        }
+    }
+
+    if (index == size_rate)
+    {
+        if (requested_rate < pcm_rate[0])
+        {
+            config->rate = pcm_rate[0];
+        }
+        else
+        {
+            config->rate = pcm_rate[index - 1];
+        }
+    }
+
+    for (cnt = 0; cnt < size_rate; cnt++)
+    {
+#if defined(__ANDROID__)
+        ALOGV("size rate is %d",size_rate);
+        config->rate = pcm_rate[(index + cnt) % size_rate];
+        ALOGV("pcm_open_req try channels: %d, rate: %d", pcm->capture_channels, config->rate);
+#endif
+        param_init(&params);
+        param_set_mask(&params, SNDRV_PCM_HW_PARAM_FORMAT,
+                       pcm_format_to_alsa(config->format));
+        param_set_mask(&params, SNDRV_PCM_HW_PARAM_SUBFORMAT,
+                       SNDRV_PCM_SUBFORMAT_STD);
+        param_set_min(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, config->period_size);
+        param_set_int(&params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
+                      pcm_format_to_bits(config->format));
+        param_set_int(&params, SNDRV_PCM_HW_PARAM_FRAME_BITS,
+                      pcm_format_to_bits(config->format) * pcm->capture_channels);
+        param_set_int(&params, SNDRV_PCM_HW_PARAM_CHANNELS,
+                      pcm->capture_channels);
+        param_set_int(&params, SNDRV_PCM_HW_PARAM_PERIODS, config->period_count);
+        param_set_int(&params, SNDRV_PCM_HW_PARAM_RATE, config->rate);
+
+        param_dump(&params);
+
+        if (flags & PCM_NOIRQ) {
+
+            if (!(flags & PCM_MMAP)) {
+                oops(pcm, -EINVAL, "noirq only currently supported with mmap().");
+                goto fail;
+            }
+
+            params.flags |= SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP;
+            pcm->noirq_frames_per_msec = config->rate / 1000;
+        }
+
+        if (flags & PCM_MMAP)
+            param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+                       SNDRV_PCM_ACCESS_MMAP_INTERLEAVED);
+        else
+            param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+                       SNDRV_PCM_ACCESS_RW_INTERLEAVED);
+
+        if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_HW_PARAMS, &params)) {
+#if defined(__ANDROID__)
+            ALOGD("cannot set hw params");
+#endif
+        }
+        else
+        {
+#if defined(__ANDROID__)
+            ALOGV("pcm_open_req OK config->rate: %d", config->rate);
+#endif
+            break;
+        }
+    }
+
+    if (cnt == size_rate)
+    {
+        cnt = 0;
+        pcm->capture_channels = 3 - pcm->capture_channels;
+
+        for (index = 0; index < size_rate; index++)
+        {
+            if (pcm_rate[index] == requested_rate)
+            {
+                break;
+            }
+        }
+
+        if (index == size_rate)
+        {
+            if (requested_rate < pcm_rate[0])
+            {
+                config->rate = pcm_rate[0];
+            }
+            else
+            {
+                config->rate = pcm_rate[index - 1];
+            }
+        }
+
+        for (cnt = 0; cnt < size_rate; cnt++)
+        {
+            config->rate = pcm_rate[(index + cnt) % size_rate];
+#if defined(__ANDROID__)
+            ALOGV("pcm_open_req try channels: %d, rate: %d", pcm->capture_channels, config->rate);
+#endif
+            param_init(&params);
+            param_set_mask(&params, SNDRV_PCM_HW_PARAM_FORMAT,
+                       pcm_format_to_alsa(config->format));
+            param_set_mask(&params, SNDRV_PCM_HW_PARAM_SUBFORMAT,
+                       SNDRV_PCM_SUBFORMAT_STD);
+            param_set_min(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE, config->period_size);
+            param_set_int(&params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS,
+                      pcm_format_to_bits(config->format));
+            param_set_int(&params, SNDRV_PCM_HW_PARAM_FRAME_BITS,
+                      pcm_format_to_bits(config->format) * pcm->capture_channels);
+            param_set_int(&params, SNDRV_PCM_HW_PARAM_CHANNELS,
+                      pcm->capture_channels);
+            param_set_int(&params, SNDRV_PCM_HW_PARAM_PERIODS, config->period_count);
+            param_set_int(&params, SNDRV_PCM_HW_PARAM_RATE, config->rate);
+
+            param_dump(&params);
+
+#if defined(__ANDROID__)
+			ALOGD("config->period_size = %d",config->period_size);
+			ALOGD("config->channels = %d",config->channels);
+			ALOGD("config->period_count = %d",config->period_count);
+			ALOGD("config->rate = %d",config->rate);
+#endif
+
+            if (flags & PCM_NOIRQ) {
+
+                if (!(flags & PCM_MMAP)) {
+                    oops(pcm, -EINVAL, "noirq only currently supported with mmap().");
+                    goto fail;
+                }
+
+                params.flags |= SNDRV_PCM_HW_PARAMS_NO_PERIOD_WAKEUP;
+                pcm->noirq_frames_per_msec = config->rate / 1000;
+            }
+
+            if (flags & PCM_MMAP)
+                param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+                       SNDRV_PCM_ACCESS_MMAP_INTERLEAVED);
+            else
+                param_set_mask(&params, SNDRV_PCM_HW_PARAM_ACCESS,
+                       SNDRV_PCM_ACCESS_RW_INTERLEAVED);
+
+            if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_HW_PARAMS, &params)) {
+#if defined(__ANDROID__)
+                ALOGD("cannot set hw params");
+#endif
+            }
+            else
+            {
+#if defined(__ANDROID__)
+                ALOGV("pcm_open_req OK config->rate: %d", config->rate);
+#endif
+                break;
+            }
+        }
+
+        if (cnt == size_rate)
+        {
+            oops(pcm, errno, "pcm_open_req cannot set hw params");
+            goto fail_close;
+        }
+    }
+
+    param_dump(&params);
+
+    /* get our refined hw_params */
+    config->period_size = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
+    config->period_count = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIODS);
+    pcm->buffer_size = config->period_count * config->period_size * (pcm->config.channels * pcm_format_to_bits(pcm->config.format) / 8);
+
+    if (flags & PCM_MMAP) {
+        pcm->mmap_buffer = mmap(NULL, pcm_frames_to_bytes(pcm, pcm->buffer_size),
+                                PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, pcm->fd, 0);
+        if (pcm->mmap_buffer == MAP_FAILED) {
+            oops(pcm, -errno, "failed to mmap buffer %d bytes\n",
+                 pcm_frames_to_bytes(pcm, pcm->buffer_size));
+#if defined(__ANDROID__)
+            ALOGD("failed to mmap buffer %d bytes",pcm_frames_to_bytes(pcm, pcm->buffer_size));
+#endif
+            goto fail_close;
+        }
+    }
+
+    memset(&sparams, 0, sizeof(sparams));
+    sparams.tstamp_mode = SNDRV_PCM_TSTAMP_ENABLE;
+    sparams.period_step = 1;
+
+      if (!config->start_threshold) {
+        if (pcm->flags & PCM_IN)
+            pcm->config.start_threshold = sparams.start_threshold = 1;
+        else
+            pcm->config.start_threshold = sparams.start_threshold =
+                config->period_count * config->period_size / 2;
+    } else
+        sparams.start_threshold = config->start_threshold;
+
+    /* pick a high stop threshold - todo: does this need further tuning */
+    if (!config->stop_threshold) {
+        if (pcm->flags & PCM_IN)
+            pcm->config.stop_threshold = sparams.stop_threshold =
+                config->period_count * config->period_size * 10;
+        else
+            pcm->config.stop_threshold = sparams.stop_threshold =
+                config->period_count * config->period_size;
+    }
+    else
+        sparams.stop_threshold = config->stop_threshold;
+
+    if (!pcm->config.avail_min) {
+        if (pcm->flags & PCM_MMAP)
+            pcm->config.avail_min = sparams.avail_min = pcm->config.period_size;
+        else
+            pcm->config.avail_min = sparams.avail_min = 1;
+    } else
+        sparams.avail_min = config->avail_min;
+
+    sparams.xfer_align = config->period_size / 2; /* needed for old kernels */
+    sparams.silence_size = 0;
+    sparams.silence_threshold = config->silence_threshold;
+    pcm->boundary = sparams.boundary = pcm->buffer_size;
+
+    while (pcm->boundary * 2 <= LONG_MAX - pcm->buffer_size)
+        pcm->boundary *= 2;
+
+    if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_SW_PARAMS, &sparams)) {
+        oops(pcm, errno, "cannot set sw params");
+#if defined(__ANDROID__)
+        ALOGD("cannot set sw params");
+#endif
+        goto fail;
+    }
+
+    rc = pcm_hw_mmap_status(pcm);
+    if (rc < 0) {
+        oops(pcm, rc, "mmap status failed");
+#if defined(__ANDROID__)
+        ALOGD("mmap status failed");
+#endif
+        goto fail;
+    }
+
+    pcm->underruns = 0;
+    return pcm;
+
+fail:
+    if (flags & PCM_MMAP)
+        munmap(pcm->mmap_buffer, pcm_frames_to_bytes(pcm, pcm->buffer_size));
+fail_close:
+    close(pcm->fd);
+    pcm->fd = -1;
+    return pcm;
+}
+
 struct pcm *pcm_open(unsigned int card, unsigned int device,
                      unsigned int flags, struct pcm_config *config)
 {
+#if defined(__ANDROID__)
+    ALOGD("alsa pcm_open");
+#endif
     struct pcm *pcm;
     struct snd_pcm_info info;
     struct snd_pcm_hw_params params;
@@ -880,6 +1356,7 @@
                   config->channels);
     param_set_int(&params, SNDRV_PCM_HW_PARAM_PERIODS, config->period_count);
     param_set_int(&params, SNDRV_PCM_HW_PARAM_RATE, config->rate);
+    //param_set_int(&params, SNDRV_PCM_HW_PARAM_RAW_FLAG, config->raw_flag);
 
     if (flags & PCM_NOIRQ) {
         if (!(flags & PCM_MMAP)) {
@@ -906,8 +1383,11 @@
     /* get our refined hw_params */
     config->period_size = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIOD_SIZE);
     config->period_count = param_get_int(&params, SNDRV_PCM_HW_PARAM_PERIODS);
-    pcm->buffer_size = config->period_count * config->period_size;
-
+    pcm->buffer_size = config->period_count * config->period_size * (pcm->config.channels * pcm_format_to_bits(pcm->config.format) / 8);
+    //config->raw_flag = param_get_int(&params, SNDRV_PCM_HW_PARAM_RAW_FLAG);
+#if defined(__ANDROID__)
+    ALOGD("alsa config->raw_flag = %d", config->raw_flag);
+#endif
     if (flags & PCM_MMAP) {
         pcm->mmap_buffer = mmap(NULL, pcm_frames_to_bytes(pcm, pcm->buffer_size),
                                 PROT_READ | PROT_WRITE, MAP_FILE | MAP_SHARED, pcm->fd, 0);
@@ -952,8 +1432,8 @@
         sparams.avail_min = config->avail_min;
 
     sparams.xfer_align = config->period_size / 2; /* needed for old kernels */
+    sparams.silence_size = 0;
     sparams.silence_threshold = config->silence_threshold;
-    sparams.silence_size = config->silence_size;
     pcm->boundary = sparams.boundary = pcm->buffer_size;
 
     while (pcm->boundary * 2 <= INT_MAX - pcm->buffer_size)
@@ -1017,7 +1497,7 @@
         return prepare_error;
 
     if (pcm->flags & PCM_MMAP)
-	    pcm_sync_ptr(pcm, 0);
+        pcm_sync_ptr(pcm, 0);
 
     if (ioctl(pcm->fd, SNDRV_PCM_IOCTL_START) < 0)
         return oops(pcm, errno, "cannot start channel");
@@ -1044,7 +1524,7 @@
 
     if (avail < 0)
         avail += pcm->boundary;
-    else if (avail > (int)pcm->boundary)
+    else if (avail >= (int)pcm->boundary)
         avail -= pcm->boundary;
 
     return avail;
@@ -1058,7 +1538,7 @@
     return avail;
 }
 
-int pcm_mmap_avail(struct pcm *pcm)
+static inline int pcm_mmap_avail(struct pcm *pcm)
 {
     pcm_sync_ptr(pcm, SNDRV_PCM_SYNC_PTR_HWSYNC);
     if (pcm->flags & PCM_IN)
@@ -1073,7 +1553,7 @@
     appl_ptr += frames;
 
     /* check for boundary wrap */
-    if (appl_ptr > pcm->boundary)
+    if (appl_ptr >= pcm->boundary)
          appl_ptr -= pcm->boundary;
     pcm->mmap_control->appl_ptr = appl_ptr;
 }
@@ -1105,12 +1585,13 @@
     return 0;
 }
 
-int pcm_mmap_commit(struct pcm *pcm, unsigned int offset __attribute__((unused)), unsigned int frames)
+int pcm_mmap_commit(struct pcm *pcm, unsigned int offset, unsigned int frames)
 {
     /* update the application pointer in userspace and kernel */
     pcm_mmap_appl_forward(pcm, frames);
     pcm_sync_ptr(pcm, 0);
-
+    if(offset != 0)
+    {}
     return frames;
 }
 
@@ -1179,11 +1660,6 @@
     return 1;
 }
 
-int pcm_get_poll_fd(struct pcm *pcm)
-{
-    return pcm->fd;
-}
-
 int pcm_mmap_transfer(struct pcm *pcm, const void *buffer, unsigned int bytes)
 {
     int err = 0, frames, avail;
@@ -1204,7 +1680,7 @@
         }
 
         /* start the audio if we reach the threshold */
-	    if (!pcm->running &&
+        if (!pcm->running &&
             (pcm->buffer_size - avail) >= pcm->config.start_threshold) {
             if (pcm_start(pcm) < 0) {
                fprintf(stderr, "start error: hw 0x%x app 0x%x avail 0x%x\n",
@@ -1302,3 +1778,117 @@
 
     return ioctl(pcm->fd, request, arg);
 }
+
+int pcm_get_node_number(char *name)
+{
+    char card[32];
+    char id[32];
+    int i = 0;
+    int j = 0;
+    int fd = 0;
+    int ret = 0;
+
+    for(i = 0; i < 10; i++){
+        memset(card, 0, 32);
+        memset(id, 0, 32);
+
+        /* "/sys/class/sound/cardx" */
+        sprintf(card, "/sys/class/sound/card%d", i);
+        ret = access(card, F_OK);
+        if(ret != 0){
+            continue;
+        }
+
+        /* "/sys/class/sound/cardx/id" */
+        strcat(card, "/id");
+        ret = access(card, F_OK);
+        if(ret != 0){
+            continue;
+        }
+
+        /* compare */
+        fd = open(card, O_RDONLY);
+        if(fd < 0){
+            continue;
+        }
+
+        ret = read(fd, id, 32);
+        if(ret < 0){
+            close(fd);
+            continue;
+        }
+
+        for(j = 0; j < 32; j++){
+            if(id[j] == 0x0a){
+                    id[j] = 0;
+            }
+        }
+
+        if(!strcmp(id, name)){
+            close(fd);
+            return i;
+        }
+
+        close(fd);
+    }
+    return -1;
+}
+
+/**
+ * Transplant from android 4.1 alsa-lib
+ * brief Set wanted device inside a PCM info container
+ * param obj PCM info container
+ * param val Device number
+ **/
+void pcm_info_set_device(snd_pcm_info_t *obj, unsigned int val)
+{
+    assert(obj);
+    obj->device = val;
+}
+
+/**
+ * Transplant from android 4.1 alsa-lib
+ * brief Set wanted subdevice inside a PCM info container
+ * param obj PCM info container
+ * param val Subdevice number
+ **/
+void pcm_info_set_subdevice(snd_pcm_info_t *obj, unsigned int val)
+{
+    assert(obj);
+    obj->subdevice = val;
+}
+
+/**
+ * Transplant from android 4.1 alsa-lib
+ * param obj PCM info container
+ * param val Stream
+ **/
+void pcm_info_set_stream(snd_pcm_info_t *obj, unsigned int val)
+{
+    assert(obj);
+    obj->stream = val;
+}
+
+/**
+ * Transplant from android 4.1 alsa-lib
+ * brief Get id from a PCM info container
+ * param obj PCM info container
+ * return short id of PCM
+ **/
+const char *pcm_info_get_id(snd_pcm_info_t *obj)
+{
+    assert(obj);
+    return (const char *)obj->id;
+}
+
+/**
+ * Transplant from android 4.1 alsa-lib
+ * brief Get name from a PCM info container
+ * param obj PCM info container
+ * return name of PCM
+ **/
+const char *pcm_info_get_name(snd_pcm_info_t *obj)
+{
+    assert(obj);
+    return (const char *)obj->name;
+}
diff -ur a/external/wpa_supplicant_8/hostapd/Android.mk b/external/wpa_supplicant_8/hostapd/Android.mk
--- a/external/wpa_supplicant_8/hostapd/Android.mk	2018-08-06 15:40:10.675006930 +0200
+++ b/external/wpa_supplicant_8/hostapd/Android.mk	2017-11-23 05:21:05.000000000 +0100
@@ -987,6 +987,11 @@
 LOCAL_STATIC_LIBRARIES += libnl_2
 endif
 endif
+ifeq ($(BOARD_WIFI_VENDOR), common)
+L_CFLAGS += -DWIFI_VENDOR_COMMON
+LOCAL_STATIC_LIBRARIES += libwifi_hardware_info
+INCLUDES += hardware/libhardware_legacy/include/hardware_legacy
+endif
 LOCAL_CFLAGS := $(L_CFLAGS)
 LOCAL_SRC_FILES := $(OBJS)
 LOCAL_C_INCLUDES := $(INCLUDES)
diff -ur a/external/wpa_supplicant_8/hostapd/config_file.c b/external/wpa_supplicant_8/hostapd/config_file.c
--- a/external/wpa_supplicant_8/hostapd/config_file.c	2018-08-06 15:40:10.679006981 +0200
+++ b/external/wpa_supplicant_8/hostapd/config_file.c	2017-11-23 05:21:05.000000000 +0100
@@ -21,6 +21,9 @@
 #include "ap/ap_config.h"
 #include "config_file.h"
 
+#ifdef WIFI_VENDOR_COMMON
+#include "wifi_hardware_info.h"
+#endif
 
 #ifndef CONFIG_NO_RADIUS
 #ifdef EAP_SERVER
@@ -3565,6 +3568,10 @@
 		*pos = '\0';
 		pos++;
 		errors += hostapd_config_fill(conf, bss, buf, pos, line);
+#ifdef WIFI_VENDOR_COMMON
+		if(strcmp(get_wifi_vendor_name(), "xradio") == 0)
+			bss->wmm_uapsd = 1;
+#endif
 	}
 
 	fclose(f);
diff -ur a/external/wpa_supplicant_8/wpa_supplicant/Android.mk b/external/wpa_supplicant_8/wpa_supplicant/Android.mk
--- a/external/wpa_supplicant_8/wpa_supplicant/Android.mk	2018-08-06 15:40:10.851009190 +0200
+++ b/external/wpa_supplicant_8/wpa_supplicant/Android.mk	2017-11-23 05:21:05.000000000 +0100
@@ -1587,6 +1587,11 @@
 LOCAL_STATIC_LIBRARIES += libnl_2
 endif
 endif
+ifeq ($(BOARD_WIFI_VENDOR), common)
+L_CFLAGS += -DWIFI_VENDOR_COMMON
+LOCAL_STATIC_LIBRARIES += libwifi_hardware_info
+INCLUDES += hardware/libhardware_legacy/include/hardware_legacy
+endif
 LOCAL_CFLAGS := $(L_CFLAGS)
 LOCAL_SRC_FILES := $(OBJS)
 LOCAL_C_INCLUDES := $(INCLUDES)
diff -ur a/external/wpa_supplicant_8/wpa_supplicant/ctrl_iface.c b/external/wpa_supplicant_8/wpa_supplicant/ctrl_iface.c
--- a/external/wpa_supplicant_8/wpa_supplicant/ctrl_iface.c	2018-08-06 15:40:10.863009345 +0200
+++ b/external/wpa_supplicant_8/wpa_supplicant/ctrl_iface.c	2017-11-23 05:21:05.000000000 +0100
@@ -51,6 +51,9 @@
 #include "offchannel.h"
 #include "drivers/driver.h"
 #include "mesh.h"
+#ifdef WIFI_VENDOR_COMMON
+#include "wifi_hardware_info.h"
+#endif
 
 static int wpa_supplicant_global_iface_list(struct wpa_global *global,
 					    char *buf, int len);
@@ -5027,6 +5030,10 @@
 		if (go_intent < 0 || go_intent > 15)
 			return -1;
 	}
+#ifdef WIFI_VENDOR_COMMON
+	if (strcmp(get_wifi_vendor_name(), "xradio") == 0)
+		go_intent = 14;
+#endif
 
 	pos2 = os_strstr(pos, " freq=");
 	if (pos2) {
@@ -8668,11 +8675,19 @@
 		if (wpas_p2p_group_remove(wpa_s, buf + 17))
 			reply_len = -1;
 	} else if (os_strcmp(buf, "P2P_GROUP_ADD") == 0) {
-		if (p2p_ctrl_group_add(wpa_s, ""))
+#ifdef WIFI_VENDOR_COMMON
+		if (strcmp(get_wifi_vendor_name(), "xradio") == 0)
 			reply_len = -1;
+		else if (p2p_ctrl_group_add(wpa_s, ""))
+			reply_len = -1;
+#endif
 	} else if (os_strncmp(buf, "P2P_GROUP_ADD ", 14) == 0) {
-		if (p2p_ctrl_group_add(wpa_s, buf + 14))
+#ifdef WIFI_VENDOR_COMMON
+		if (strcmp(get_wifi_vendor_name(), "xradio") == 0)
+			reply_len = -1;
+		else if (p2p_ctrl_group_add(wpa_s, buf + 14))
 			reply_len = -1;
+#endif
 	} else if (os_strncmp(buf, "P2P_PROV_DISC ", 14) == 0) {
 		if (p2p_ctrl_prov_disc(wpa_s, buf + 14))
 			reply_len = -1;
diff -ur a/external/wpa_supplicant_8/wpa_supplicant/main.c b/external/wpa_supplicant_8/wpa_supplicant/main.c
--- a/external/wpa_supplicant_8/wpa_supplicant/main.c	2018-08-06 15:40:10.879009551 +0200
+++ b/external/wpa_supplicant_8/wpa_supplicant/main.c	2017-11-23 05:21:05.000000000 +0100
@@ -17,6 +17,9 @@
 #include "driver_i.h"
 #include "p2p_supplicant.h"
 
+#ifdef WIFI_VENDOR_COMMON
+#include "wifi_hardware_info.h"
+#endif
 
 static void usage(void)
 {
@@ -199,9 +202,51 @@
 
 	wpa_supplicant_fd_workaround(1);
 
+#ifdef WIFI_VENDOR_COMMON
+        int argc_custom = 1;
+        char *argv_custom[64] = {NULL};
+        const char *supplicant_para = NULL;
+
+        if(argv[0]) {
+            argv_custom[0] = strdup(argv[0]);
+        }
+        if(argv[1] && strcmp(argv[1], "p2p_supported=false") == 0) {
+            supplicant_para = get_supplicant_para(0);
+        } else {
+            supplicant_para = get_supplicant_para(1);
+        }
+        if(supplicant_para) {
+            char argv_temp[126] = {'\0'};
+            int index = 0;
+            for(; *supplicant_para; supplicant_para++) {
+                if(*supplicant_para == ' ') {
+                    argv_custom[argc_custom] = strdup(argv_temp);
+                    argc_custom++;
+                    index = 0;
+                    memset(argv_temp, 0, sizeof(argv_temp));
+                    if(argc_custom >= 64) {
+                        break;
+                    }
+                } else {
+                    if(index < 125) {
+                        argv_temp[index++] = *supplicant_para;
+                    }
+                }
+            }
+            if(index > 0 && argc_custom < 64) {
+                argv_custom[argc_custom] = strdup(argv_temp);
+                argc_custom++;
+            }
+        }
+#endif
 	for (;;) {
+#ifdef WIFI_VENDOR_COMMON
+		c = getopt(argc_custom, argv_custom,
+			   "b:Bc:C:D:de:f:g:G:hi:I:KLm:No:O:p:P:qsTtuvW");
+#else
 		c = getopt(argc, argv,
-			   "b:Bc:C:D:de:f:g:G:hi:I:KLMm:No:O:p:P:qsTtuvW");
+			   "b:Bc:C:D:de:f:g:G:hi:I:KLm:No:O:p:P:qsTtuvW");
+#endif
 		if (c < 0)
 			break;
 		switch (c) {
@@ -396,6 +441,13 @@
 	fst_global_deinit();
 
 out:
+#ifdef WIFI_VENDOR_COMMON
+        for(i = 0; i < argc_custom; i++) {
+            if(argv_custom[i]) {
+                os_free(argv_custom[i]);
+            }
+        }
+#endif
 	wpa_supplicant_fd_workaround(0);
 	os_free(ifaces);
 #ifdef CONFIG_MATCH_IFACE
