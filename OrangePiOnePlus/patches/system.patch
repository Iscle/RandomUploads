diff -ur ../aosp/system/bt/bta/dm/bta_dm_act.c ../Desktop/android/system/bt/bta/dm/bta_dm_act.c
--- ../aosp/system/bt/bta/dm/bta_dm_act.c	2018-08-06 15:48:49.009738963 +0200
+++ ../Desktop/android/system/bt/bta/dm/bta_dm_act.c	2017-11-23 05:26:57.000000000 +0100
@@ -48,6 +48,9 @@
 #if (GAP_INCLUDED == TRUE)
 #include "gap_api.h"
 #endif
+#include <stdio.h>
+#include <errno.h>
+#include "hcimsgs.h"
 
 static void bta_dm_inq_results_cb (tBTM_INQ_RESULTS *p_inq, UINT8 *p_eir);
 static void bta_dm_inq_cmpl_cb (void * p_result);
@@ -136,7 +139,7 @@
 static void bta_dm_observe_cmpl_cb(void * p_result);
 static void bta_dm_delay_role_switch_cback(void *data);
 extern void sdpu_uuid16_to_uuid128(UINT16 uuid16, UINT8* p_uuid128);
-static void bta_dm_disable_timer_cback(void *data);
+/* static void bta_dm_disable_timer_cback(void *data); */
 
 
 const UINT16 bta_service_id_to_uuid_lkup_tbl [BTA_MAX_SERVICE_ID] =
@@ -452,7 +455,9 @@
 
 }
 
-
+#ifndef HCI_USE_USB
+extern tBTM_STATUS BTM_BleWoLEParamSetup(int action,BD_ADDR p_target, UINT8* MANU_DATA,int manu_data_len);
+#endif
 /*******************************************************************************
 **
 ** Function         bta_dm_disable
@@ -467,6 +472,16 @@
 {
     UNUSED(p_data);
 
+#ifndef HCI_USE_USB
+    BD_ADDR bda;
+    BD_ADDR bda_empty;
+    memset(&bda,0,sizeof(BD_ADDR));
+    memset(&bda_empty,0,sizeof(BD_ADDR));
+    char wake_on_ble[128];
+    UINT8 BDADDR_AND_MANU[32];
+    int n=0,i=0;
+#endif
+
     /* Set l2cap idle timeout to 0 (so BTE immediately disconnects ACL link after last channel is closed) */
     L2CA_SetIdleTimeoutByBdAddr((UINT8 *)BT_BD_ANY, 0, BT_TRANSPORT_BR_EDR);
     L2CA_SetIdleTimeoutByBdAddr((UINT8 *)BT_BD_ANY, 0, BT_TRANSPORT_LE);
@@ -502,10 +517,56 @@
     }
     else
     {
-        alarm_set_on_queue(bta_dm_cb.disable_timer, BTA_DM_DISABLE_TIMER_MS,
+        /* alarm_set_on_queue(bta_dm_cb.disable_timer, BTA_DM_DISABLE_TIMER_MS,
                            bta_dm_disable_timer_cback, UINT_TO_PTR(0),
-                           btu_bta_alarm_queue);
+                           btu_bta_alarm_queue); */
+
+        /* As we send reset before, no need to wait for acl change status*/
+        alarm_set_on_queue(bta_dm_cb.disable_timer, BTA_DISABLE_DELAY,
+                           bta_dm_disable_conn_down_timer_cback, NULL,
+                            btu_bta_alarm_queue);
+    }
+
+#ifndef HCI_USE_USB
+    BTM_BleObserve(FALSE, 0, NULL, NULL);
+    //Issue PCF command to support WoLE and also start LE scan
+    FILE *fp_wole = fopen(WAKE_ON_BLE_CONF,"rt");
+    if(!fp_wole)
+    {
+        APPL_TRACE_ERROR("%s unable to open file '%s': %s", __func__, WAKE_ON_BLE_CONF, strerror(errno));
+	btsnd_hcic_reset(); /* reset controller state */
+        return;
+    }
+    fgets(wake_on_ble, sizeof(wake_on_ble), fp_wole);
+    memset(BDADDR_AND_MANU,'\0',sizeof(BDADDR_AND_MANU));
+    char *p= wake_on_ble;
+
+    while (*p != 0)
+    {
+        while (*p == ' ' || *p == '\t')
+            p++;
+
+        if (sscanf(p, "%02x", (unsigned int *)&BDADDR_AND_MANU[n]) == 0)
+            break;
+        n++;
+        p++;
+        while ( (*p>= '0' && *p<= '9') ||
+                (*p>= 'a' && *p<= 'f') ||
+                (*p>= 'A' && *p<= 'F'))
+            p++;
     }
+
+    int manu_data_len = (int)BDADDR_AND_MANU[6];
+    for(i=0;i<BD_ADDR_LEN;i++)
+        bda[i] = BDADDR_AND_MANU[i];
+
+    btsnd_hcic_reset(); //reset controller state
+
+    btsnd_hcic_write_bdaddr(bda_empty);//set it to empty to prevent direct adv wake system up
+    BTM_BleWoLEParamSetup(0,bda, &BDADDR_AND_MANU[7],manu_data_len);
+    APPL_TRACE_DEBUG("%s Luke:Set BleWoLe enable",__FUNCTION__);
+    BTM_BleObserve(TRUE,0, NULL,NULL);
+#endif
 }
 
 /*******************************************************************************
@@ -520,6 +581,7 @@
 ** Returns          void
 **
 *******************************************************************************/
+#if 0
 static void bta_dm_disable_timer_cback(void *data)
 {
     UINT8 i;
@@ -558,7 +620,7 @@
         bta_dm_cb.p_sec_cback(BTA_DM_DISABLE_EVT, NULL);
     }
 }
-
+#endif
 
 
 
diff -ur ../aosp/system/bt/btif/co/bta_hh_co.c ../Desktop/android/system/bt/btif/co/bta_hh_co.c
--- ../aosp/system/bt/btif/co/bta_hh_co.c	2018-08-06 15:48:49.093740067 +0200
+++ ../Desktop/android/system/bt/btif/co/bta_hh_co.c	2017-11-23 05:26:57.000000000 +0100
@@ -44,6 +44,8 @@
 static tBTA_HH_RPT_CACHE_ENTRY sReportCache[BTA_HH_NV_LOAD_MAX];
 #endif
 
+static int suspend_fd = -1;
+
 void uhid_set_non_blocking(int fd)
 {
     int opts = fcntl(fd, F_GETFL);
@@ -100,8 +102,9 @@
         // ensure we read full event descriptor
         if (ret < (ssize_t)sizeof(ev)) {
             APPL_TRACE_ERROR("%s: Invalid size read from uhid-dev: %ld != %lu",
-                         __FUNCTION__, ret, sizeof(ev.type));
-            return -EFAULT;
+                         __FUNCTION__, ret, sizeof(ev));
+            // We can not return fail here, in order to compatible with the old kernel uhid driver.
+            //return -EFAULT;
         }
     }
 
@@ -391,6 +394,11 @@
             break;
         }
      }
+
+    if (suspend_fd > 0) {
+        close(suspend_fd);
+        suspend_fd = -1;
+    }
 }
 
 
@@ -415,6 +423,7 @@
 {
     btif_hh_device_t *p_dev;
     UNUSED(peer_addr);
+    char buf[1];
 
     APPL_TRACE_DEBUG("%s: dev_handle = %d, subclass = 0x%02X, mode = %d, "
          "ctry_code = %d, app_id = %d",
@@ -426,6 +435,33 @@
         return;
     }
 
+    /*
+    int i;
+    for (i = 0; i < len; i++) {
+        APPL_TRACE_ERROR("%s, rpt[%d]: 0x%x", __FUNCTION__, i, p_rpt[i]);
+    }
+    */
+
+    if (suspend_fd < 0) {
+        suspend_fd = open("/proc/bluetooth/sleep/suspend", O_RDWR);
+        if (suspend_fd < 0) {
+            APPL_TRACE_ERROR("%s, can not open /proc/bluetooth/sleep/suspend, (%s)", __FUNCTION__, strerror(errno));
+        }
+    }
+
+    if ((suspend_fd > 0) && (read(suspend_fd, &buf, sizeof(buf)) > 0)) {
+        if (buf[0] == 1) {
+            /* if ((len == 9) && (p_rpt[0] == 0x1) && (p_rpt[3] == 0x66)) { */
+	    if ((len == 4) && (p_rpt[0] == 0x1) && (p_rpt[1] == 0x30)) {
+                buf[0] = '1';
+                if (write(suspend_fd, &buf[0], 1) < 0)
+                    APPL_TRACE_ERROR("%s, failed to write /proc/bluetooth/sleep/suspend, (%s)", __FUNCTION__, strerror(errno));
+            } else {
+                return;
+            }
+        }
+    }
+
     // Send the HID data to the kernel.
     if ((p_dev->fd >= 0) && p_dev->ready_for_data) {
         bta_hh_co_write(p_dev->fd, p_rpt, len);
diff -ur ../aosp/system/bt/btif/include/btif_common.h ../Desktop/android/system/bt/btif/include/btif_common.h
--- ../aosp/system/bt/btif/include/btif_common.h	2018-08-06 15:48:49.093740067 +0200
+++ ../Desktop/android/system/bt/btif/include/btif_common.h	2017-11-23 05:26:57.000000000 +0100
@@ -169,6 +169,9 @@
 
 #define FACTORY_BT_BDADDR_STORAGE_LEN   17
 
+#define PERSIST_USBBT_PROPERTY         "persist.service.bdroid.usbbt"
+
+#define PERSIST_BTSLEEP_PROPERTY       "persist.service.bdroid.sleep"
 
 /*******************************************************************************
 **  Type definitions for callback functions
diff -ur ../aosp/system/bt/btif/src/bluetooth.c ../Desktop/android/system/bt/btif/src/bluetooth.c
--- ../aosp/system/bt/btif/src/bluetooth.c	2018-08-06 15:48:49.105740225 +0200
+++ ../Desktop/android/system/bt/btif/src/bluetooth.c	2017-11-23 05:26:57.000000000 +0100
@@ -50,6 +50,7 @@
 #include "btif_debug.h"
 #include "btsnoop.h"
 #include "btsnoop_mem.h"
+#include "bt_common.h"
 #include "device/include/interop.h"
 #include "osi/include/allocation_tracker.h"
 #include "osi/include/alarm.h"
@@ -57,6 +58,7 @@
 #include "osi/include/metrics.h"
 #include "osi/include/osi.h"
 #include "osi/include/wakelock.h"
+#include "osi/include/properties.h"
 #include "stack_manager.h"
 #include "btif_config.h"
 #include "btif_storage.h"
@@ -135,6 +137,16 @@
   allocation_tracker_init();
 #endif
 
+  #ifdef HCI_USE_USB
+  if (osi_property_set(PERSIST_USBBT_PROPERTY, "1") < 0)
+    LOG_ERROR(LOG_TAG, "%s(), failed to set property: %s", __func__, PERSIST_USBBT_PROPERTY);
+  #else
+  if (osi_property_set("persist.service.bdroid.uart", "1") < 0)
+    LOG_ERROR(LOG_TAG, "Failed to set bt module info in prop: persist.service.bdroid.uart");
+  if (osi_property_set(PERSIST_BTSLEEP_PROPERTY, "bcm") < 0)
+    LOG_ERROR(LOG_TAG, "Failed to set bt module info in prop: %s", PERSIST_BTSLEEP_PROPERTY);
+  #endif
+
   bt_hal_cbacks = callbacks;
   stack_manager_get_interface()->init_stack();
   btif_debug_init();
@@ -149,6 +161,15 @@
   if (!interface_ready())
     return BT_STATUS_NOT_READY;
 
+  #ifdef HCI_USE_USB
+  char pval[PROPERTY_VALUE_MAX] = {0};
+  osi_property_get("sys.usbbt.inserted", pval, NULL);
+  if (pval[0] != '1') {
+    LOG_ERROR(LOG_TAG, "%s(), USB BT dongle not inserted, ignore enable operation...", __func__);
+    return BT_STATUS_NOT_READY;
+  }
+  #endif
+
   stack_manager_get_interface()->start_up_stack_async();
   return BT_STATUS_SUCCESS;
 }
diff -ur ../aosp/system/bt/btif/src/btif_core.c ../Desktop/android/system/bt/btif/src/btif_core.c
--- ../aosp/system/bt/btif/src/btif_core.c	2018-08-06 15:48:49.105740225 +0200
+++ ../Desktop/android/system/bt/btif/src/btif_core.c	2017-11-23 05:26:57.000000000 +0100
@@ -585,7 +585,10 @@
     BTIF_TRACE_DEBUG("%s", __FUNCTION__);
 
 #if (defined(HCILP_INCLUDED) && HCILP_INCLUDED == TRUE)
+    #ifdef HCI_USE_USB
     bte_main_enable_lpm(FALSE);
+    #endif
+    bte_main_enable_lpm(TRUE);
 #endif
 
      bte_main_disable();
diff -ur ../aosp/system/bt/btif/src/btif_dm.c ../Desktop/android/system/bt/btif/src/btif_dm.c
--- ../aosp/system/bt/btif/src/btif_dm.c	2018-08-06 15:48:49.105740225 +0200
+++ ../Desktop/android/system/bt/btif/src/btif_dm.c	2017-11-23 05:26:57.000000000 +0100
@@ -60,6 +60,9 @@
 #include "osi/include/properties.h"
 #include "stack_config.h"
 #include "stack/btm/btm_int.h"
+#include <bt_target.h>
+#include <ctype.h>
+#include <errno.h>
 
 /******************************************************************************
 **  Constants & Macros
@@ -103,6 +106,13 @@
 
 typedef struct
 {
+    char rc_name[128];
+    unsigned int manu_data[32];
+    unsigned int manu_data_len;
+} RC_CONFIG;
+
+typedef struct
+{
     bt_bond_state_t state;
     bt_bdaddr_t static_bdaddr;
     BD_ADDR bd_addr;
@@ -526,8 +536,103 @@
     return FALSE;
 }
 
+#ifndef HCI_USE_USB
+static BOOLEAN get_remote_name(bt_bdaddr_t *bd_addr,UINT8 *p_remote_name, UINT8 *p_remote_name_len)
+{
+    bt_bdname_t bdname;
+    bt_bdaddr_t remote_bdaddr;
+    bt_property_t prop_name;
+
+    /* check if we already have it in our btif_storage cache */
+    remote_bdaddr = *bd_addr;
+    //bdcpy(remote_bdaddr.address, bd_addr);
+    BTIF_STORAGE_FILL_PROPERTY(&prop_name, BT_PROPERTY_BDNAME,
+            sizeof(bt_bdname_t), &bdname);
+    if (btif_storage_get_remote_device_property(
+                &remote_bdaddr, &prop_name) == BT_STATUS_SUCCESS)
+    {
+        if (p_remote_name && p_remote_name_len)
+        {
+            strcpy((char *)p_remote_name, (char *)bdname.name);
+            *p_remote_name_len = strlen((char *)p_remote_name);
+        }
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static char *trim(char *str)
+{
+    while (isspace(*str))
+        ++str;
+
+    if (!*str)
+        return str;
+
+    char *end_str = str + strlen(str) - 1;
+    while (end_str > str && isspace(*end_str))
+        --end_str;
+
+    end_str[1] = '\0';
+    return str;
+}
+
+static void config_rc_parse(FILE *fp, RC_CONFIG *rc_config)
+{
+    unsigned int line_num = 0,n=0;
+    char line[1024];
+    char *p;
+
+    while (fgets(line, sizeof(line), fp)) {
+        char *line_ptr = trim(line);
+        ++line_num;
+        // Skip blank and comment lines.
+        if (*line_ptr == '\0' || *line_ptr == '#')
+            continue;
+
+        char *split = strchr(line_ptr, '=');
+        if (!split) {
+            ALOGD("%s no key/value separator found on line %d.", __func__, line_num);
+            continue;
+        }
+        *split = '\0';
+        if(!strncmp(line_ptr,"rc_name",sizeof("rc_name")))
+            strcpy(rc_config->rc_name,(split+1));
+        if(!strncmp(line_ptr,"manu_data",sizeof("manu_data")))
+        {
+            p = (split+1);
+            while (*p != 0)
+            {
+                while (*p == ' ' || *p == '\t')
+                    p++;
+
+                if (sscanf(p, "%02x", &rc_config->manu_data[n]) == 0)
+                    break;
+                n++;
+                p++;
+                while ( (*p>= '0' && *p<= '9') ||
+                        (*p>= 'a' && *p<= 'f') ||
+                        (*p>= 'A' && *p<= 'F'))
+                    p++;
+            }
+            rc_config->manu_data_len = n;
+        }
+    }
+    ALOGD("WoLE read rc_name = %s, manu_data = ",rc_config->rc_name);
+    for(n=0;n<rc_config->manu_data_len;n++)
+        ALOGD("%02X ", rc_config->manu_data[n]);
+}
+#endif
+
 static void bond_state_changed(bt_status_t status, bt_bdaddr_t *bd_addr, bt_bond_state_t state)
 {
+#ifndef HCI_USE_USB
+    bt_bdname_t bdname;
+    UINT8 remote_name_len;
+    UINT8 BDADDR_AND_MANU_DATA[32];
+    char wake_on_ble[128];
+    UINT32 i=0;
+#endif
 
     btif_stats_add_bond_event(bd_addr, BTIF_DM_FUNC_BOND_STATE_CHANGED, state);
 
@@ -560,6 +665,94 @@
         else
             BTIF_TRACE_DEBUG("%s: BR-EDR service discovery active", __func__);
     }
+
+#ifndef HCI_USE_USB
+    //Luke
+    if( state == BT_BOND_STATE_BONDED || state == BT_BOND_STATE_NONE)
+    {
+        ALOGE("%s state == BT_BOND_STATE_BONDED || BT_BOND_STATE_NONE", __func__);
+        //open /etc/bluetooth/rc.conf
+        FILE *fp = fopen(RC_CONF,"rt");
+        if(!fp)
+        {
+            ALOGE("%s unable to open file '%s': %s", __func__, RC_CONF, strerror(errno));
+            return;
+        }
+        RC_CONFIG *rc_config = calloc(1,sizeof(RC_CONFIG));
+
+        if(!rc_config)
+        {
+            ALOGE("%s unable to allocate memory for rc_config.", __func__);
+            fclose(fp);
+            return;
+        }
+        config_rc_parse(fp,rc_config);
+        fclose(fp);
+
+        memset(BDADDR_AND_MANU_DATA,'\0',sizeof(BDADDR_AND_MANU_DATA));
+        if( (get_remote_name(bd_addr,bdname.name,&remote_name_len) == TRUE ) &&
+            ( strncmp(rc_config->rc_name,(char *)bdname.name,remote_name_len) == 0 )
+             )
+        {
+
+            ALOGE("Name = %s", bdname.name);
+            if( state == BT_BOND_STATE_BONDED )
+            {
+                ALOGE("%s state == BT_BOND_STATE_BONDED", __func__);
+                //write manufacture data and bd addr into /data/misc/bluedroid/wake_on_ble.conf
+                for(i=0;i<BD_ADDR_LEN;i++)
+                    BDADDR_AND_MANU_DATA[i] = bd_addr->address[i];
+
+                BDADDR_AND_MANU_DATA[BD_ADDR_LEN] = rc_config->manu_data_len;//length
+
+                for(i=0;i<rc_config->manu_data_len;i++)
+                    BDADDR_AND_MANU_DATA[BD_ADDR_LEN+i+1] = rc_config->manu_data[i];
+
+                FILE *fp_wole = fopen(WAKE_ON_BLE_CONF,"w+");
+                if(!fp_wole)
+                {
+                    ALOGE("%s unable to open file '%s': %s", __func__, WAKE_ON_BLE_CONF, strerror(errno));
+                    return;
+                }
+                char *p = wake_on_ble;
+                memset(wake_on_ble,'\0',sizeof(wake_on_ble));
+                for(i=0;i<rc_config->manu_data_len+6+1; i++)
+                {
+                    sprintf(p,"%02x ",BDADDR_AND_MANU_DATA[i]);
+                    p += strlen(p);
+                }
+
+                fprintf(fp_wole,"%s",wake_on_ble);
+                fclose(fp_wole);
+                free(rc_config);
+            }
+            else if( state == BT_BOND_STATE_NONE )
+            {
+                ALOGE("%s state == BT_BOND_STATE_NONE", __func__);
+                FILE *fp_wole = fopen(WAKE_ON_BLE_CONF,"rt");
+                if(!fp_wole)
+                {
+                    ALOGE("%s unable to open file '%s': %s", __func__, WAKE_ON_BLE_CONF, strerror(errno));
+                    return;
+                }
+                memset(wake_on_ble,'\0',sizeof(wake_on_ble));
+                fgets(wake_on_ble, sizeof(wake_on_ble), fp);
+                sscanf(wake_on_ble,"%02x %02x %02x %02x %02x %02x",(unsigned int *)&BDADDR_AND_MANU_DATA[0],
+                    (unsigned int *)&BDADDR_AND_MANU_DATA[1],(unsigned int *)&BDADDR_AND_MANU_DATA[2],(unsigned int *)&BDADDR_AND_MANU_DATA[3],
+                    (unsigned int *)&BDADDR_AND_MANU_DATA[4],(unsigned int *)&BDADDR_AND_MANU_DATA[5]);
+
+                for(i=0;i<BD_ADDR_LEN;i++)
+                    if(BDADDR_AND_MANU_DATA[i] != bd_addr->address[i])
+                        break;
+                if(i == BD_ADDR_LEN )
+                {
+                    ALOGE("%s BD ADDR match, remove wake_on_ble.conf", __func__);
+                    remove(WAKE_ON_BLE_CONF);
+                }
+            }
+        }
+    }
+#endif
 }
 
 /* store remote version in bt config to always have access
diff -ur ../aosp/system/bt/btif/src/btif_gatt_client.c ../Desktop/android/system/bt/btif/src/btif_gatt_client.c
--- ../aosp/system/bt/btif/src/btif_gatt_client.c	2018-08-06 15:48:49.109740276 +0200
+++ ../Desktop/android/system/bt/btif/src/btif_gatt_client.c	2017-11-23 05:26:57.000000000 +0100
@@ -54,6 +54,8 @@
 #include "osi/include/log.h"
 #include "vendor_api.h"
 
+#include "btm_ble_api.h"
+
 /*******************************************************************************
 **  Constants & Macros
 ********************************************************************************/
@@ -595,6 +597,9 @@
                }
             }
 
+            if (p_eir_remote_name)
+                btif_gattc_update_properties(p_btif_cb);
+
              dev_type =  p_btif_cb->device_type;
              BTIF_STORAGE_FILL_PROPERTY(&properties,
                         BT_PROPERTY_TYPE_OF_DEVICE, sizeof(dev_type), &dev_type);
diff -ur ../aosp/system/bt/btif/src/btif_storage.c ../Desktop/android/system/bt/btif/src/btif_storage.c
--- ../aosp/system/bt/btif/src/btif_storage.c	2018-08-06 15:48:49.121740434 +0200
+++ ../Desktop/android/system/bt/btif/src/btif_storage.c	2017-11-23 05:26:57.000000000 +0100
@@ -197,6 +197,7 @@
                                 BTIF_STORAGE_PATH_REMOTE_NAME, value);
             else btif_config_set_str("Adapter",
                                 BTIF_STORAGE_KEY_ADAPTER_NAME, value);
+            btif_config_flush();
             break;
         case BT_PROPERTY_REMOTE_FRIENDLY_NAME:
             strncpy(value, (char*)prop->val, prop->len);
diff -ur ../aosp/system/bt/conf/Android.mk ../Desktop/android/system/bt/conf/Android.mk
--- ../aosp/system/bt/conf/Android.mk	2018-08-06 15:48:49.125740487 +0200
+++ ../Desktop/android/system/bt/conf/Android.mk	2017-11-23 05:26:57.000000000 +0100
@@ -20,3 +20,12 @@
 LOCAL_SRC_FILES := $(LOCAL_MODULE)
 include $(BUILD_PREBUILT)
 
+# Bluetooth rc.conf config file
+# ========================================================
+include $(CLEAR_VARS)
+LOCAL_MODULE := rc.conf
+LOCAL_MODULE_CLASS := ETC
+LOCAL_MODULE_PATH := $(TARGET_OUT)/etc/bluetooth
+LOCAL_MODULE_TAGS := optional
+LOCAL_SRC_FILES := $(LOCAL_MODULE)
+include $(BUILD_PREBUILT)
Only in ../Desktop/android/system/bt/conf: rc.conf
diff -ur ../aosp/system/bt/hci/Android.mk ../Desktop/android/system/bt/hci/Android.mk
--- ../aosp/system/bt/hci/Android.mk	2018-08-06 15:48:49.129740538 +0200
+++ ../Desktop/android/system/bt/hci/Android.mk	2017-11-23 05:26:57.000000000 +0100
@@ -13,13 +13,15 @@
     src/hci_hal.c \
     src/hci_hal_h4.c \
     src/hci_hal_mct.c \
+    src/hci_hal_usb.c \
     src/hci_inject.c \
     src/hci_layer.c \
     src/hci_packet_factory.c \
     src/hci_packet_parser.c \
     src/low_power_manager.c \
     src/packet_fragmenter.c \
-    src/vendor.c
+    src/vendor.c \
+    src/usb.c
 
 LOCAL_C_INCLUDES += \
     $(LOCAL_PATH)/include \
@@ -31,6 +33,12 @@
     $(LOCAL_PATH)/../bta/include \
     $(bluetooth_C_INCLUDES)
 
+LOCAL_C_INCLUDES += \
+    external/libusb
+
+LOCAL_STATIC_LIBRARIES += \
+    libusb
+
 LOCAL_MODULE := libbt-hci
 
 ifeq ($(BLUETOOTH_HCI_USE_MCT),true)
diff -ur ../aosp/system/bt/hci/include/hci_hal.h ../Desktop/android/system/bt/hci/include/hci_hal.h
--- ../aosp/system/bt/hci/include/hci_hal.h	2018-08-06 15:48:49.133740592 +0200
+++ ../Desktop/android/system/bt/hci/include/hci_hal.h	2017-11-23 05:26:57.000000000 +0100
@@ -85,3 +85,5 @@
 
 const hci_hal_t *hci_hal_mct_get_interface(void);
 const hci_hal_t *hci_hal_mct_get_test_interface(vendor_t *vendor_interface);
+
+const hci_hal_t *hci_hal_usb_get_interface();
Only in ../Desktop/android/system/bt/hci/include: usb.h
diff -ur ../aosp/system/bt/hci/src/hci_hal.c ../Desktop/android/system/bt/hci/src/hci_hal.c
--- ../aosp/system/bt/hci/src/hci_hal.c	2018-08-06 15:48:49.133740592 +0200
+++ ../Desktop/android/system/bt/hci/src/hci_hal.c	2017-11-23 05:26:57.000000000 +0100
@@ -19,10 +19,14 @@
 #include "hci_hal.h"
 
 const hci_hal_t *hci_hal_get_interface() {
+
 #if HCI_USE_MCT
   return hci_hal_mct_get_interface();
+#elif HCI_USE_USB
+  return hci_hal_usb_get_interface();
 #else
   return hci_hal_h4_get_interface();
 #endif
+
 }
 
Only in ../Desktop/android/system/bt/hci/src: hci_hal_usb.c
diff -ur ../aosp/system/bt/hci/src/hci_layer.c ../Desktop/android/system/bt/hci/src/hci_layer.c
--- ../aosp/system/bt/hci/src/hci_layer.c	2018-08-06 15:48:49.133740592 +0200
+++ ../Desktop/android/system/bt/hci/src/hci_layer.c	2017-11-23 05:26:57.000000000 +0100
@@ -701,12 +701,18 @@
 
   if (wait_entry) {
     // If it has a callback, it's responsible for freeing the packet
-    if (event_code == HCI_COMMAND_STATUS_EVT || (!wait_entry->complete_callback && !wait_entry->complete_future))
+    if (event_code == HCI_COMMAND_STATUS_EVT || (!wait_entry->complete_callback && !wait_entry->complete_future)) {
+      #ifndef HCI_USE_USB
       buffer_allocator->free(packet);
+      #endif
+    }
 
     // If it has a callback, it's responsible for freeing the command
-    if (event_code == HCI_COMMAND_COMPLETE_EVT || !wait_entry->status_callback)
+    if (event_code == HCI_COMMAND_COMPLETE_EVT || !wait_entry->status_callback) {
+      #ifndef HCI_USE_USB
       buffer_allocator->free(wait_entry->command);
+      #endif
+    }
 
     osi_free(wait_entry);
   } else {
diff -ur ../aosp/system/bt/hci/src/low_power_manager.c ../Desktop/android/system/bt/hci/src/low_power_manager.c
--- ../aosp/system/bt/hci/src/low_power_manager.c	2018-08-06 15:48:49.133740592 +0200
+++ ../Desktop/android/system/bt/hci/src/low_power_manager.c	2017-11-23 05:26:57.000000000 +0100
@@ -141,11 +141,11 @@
       LOG_ERROR(LOG_TAG, "%s still processing prior enable request, ignoring new request to enable.", __func__);
     else
       LOG_WARN(LOG_TAG, "%s still processing prior enable request, cannot disable.", __func__);
-  } else if (state == LPM_ENABLED && enable) {
+  } /* else if (state == LPM_ENABLED && enable) {
     LOG_INFO(LOG_TAG, "%s already enabled.", __func__);
   } else if (state == LPM_DISABLED && !enable) {
     LOG_INFO(LOG_TAG, "%s already disabled.", __func__);
-  } else {
+  } */ else {
     uint8_t command = enable ? BT_VND_LPM_ENABLE : BT_VND_LPM_DISABLE;
     state = enable ? LPM_ENABLING : LPM_DISABLING;
     if (state == LPM_ENABLING)
Only in ../Desktop/android/system/bt/hci/src: usb.c
diff -ur ../aosp/system/bt/hci/src/vendor.c ../Desktop/android/system/bt/hci/src/vendor.c
--- ../aosp/system/bt/hci/src/vendor.c	2018-08-06 15:48:49.133740592 +0200
+++ ../Desktop/android/system/bt/hci/src/vendor.c	2017-11-23 05:26:57.000000000 +0100
@@ -30,7 +30,7 @@
 #include "osi/include/osi.h"
 
 
-static const char *VENDOR_LIBRARY_NAME = "libbt-vendor.so";
+static const char *VENDOR_LIBRARY_NAME = "libbt-vendor-bcm.so";
 static const char *VENDOR_LIBRARY_SYMBOL_NAME = "BLUETOOTH_VENDOR_LIB_INTERFACE";
 
 static const vendor_t interface;
diff -ur ../aosp/system/bt/include/bt_target.h ../Desktop/android/system/bt/include/bt_target.h
--- ../aosp/system/bt/include/bt_target.h	2018-08-06 15:48:49.137740643 +0200
+++ ../Desktop/android/system/bt/include/bt_target.h	2017-11-23 05:26:57.000000000 +0100
@@ -20,6 +20,9 @@
 #ifndef BT_TARGET_H
 #define BT_TARGET_H
 
+#define RC_CONF "/etc/bluetooth/rc.conf"
+#define WAKE_ON_BLE_CONF "/data/misc/bluedroid/wake_on_ble.conf"
+
 #ifndef BUILDCFG
 #define BUILDCFG
 #endif
@@ -91,7 +94,7 @@
 #endif
 
 #ifndef BTA_DISABLE_DELAY
-#define BTA_DISABLE_DELAY 200 /* in milliseconds */
+#define BTA_DISABLE_DELAY 1500 /* in milliseconds */
 #endif
 
 #ifndef SBC_FOR_EMBEDDED_LINUX
@@ -688,7 +691,7 @@
  * resolution, local address rotation etc.
  */
 #ifndef BLE_PRIVACY_SPT
-#define BLE_PRIVACY_SPT         TRUE
+#define BLE_PRIVACY_SPT         FALSE
 #endif
 
 /*
diff -ur ../aosp/system/bt/main/Android.mk ../Desktop/android/system/bt/main/Android.mk
--- ../aosp/system/bt/main/Android.mk	2018-08-06 15:48:49.137740643 +0200
+++ ../Desktop/android/system/bt/main/Android.mk	2017-11-23 05:26:57.000000000 +0100
@@ -79,9 +79,10 @@
     libbt-stack \
     libbt-utils \
     libbtcore \
-    libosi
+    libosi \
+    libusb
 
-LOCAL_MODULE := bluetooth.default
+LOCAL_MODULE := bluetooth.bcm.default
 LOCAL_MODULE_RELATIVE_PATH := hw
 LOCAL_MODULE_TAGS := optional
 LOCAL_MODULE_CLASS := SHARED_LIBRARIES
@@ -99,7 +100,9 @@
     bt_did.conf \
     bt_stack.conf \
     libbt-hci \
-    libbt-vendor
+    libbt-vendor-bcm \
+    libusb \
+    rc.conf
 
 LOCAL_CFLAGS += $(bluetooth_CFLAGS) -DBUILDCFG
 LOCAL_CONLYFLAGS += $(bluetooth_CONLYFLAGS)
diff -ur ../aosp/system/bt/stack/btm/btm_acl.c ../Desktop/android/system/bt/stack/btm/btm_acl.c
--- ../aosp/system/bt/stack/btm/btm_acl.c	2018-08-06 15:48:49.201741485 +0200
+++ ../Desktop/android/system/bt/stack/btm/btm_acl.c	2017-11-23 05:26:57.000000000 +0100
@@ -1299,6 +1299,7 @@
 *******************************************************************************/
 tBTM_STATUS BTM_SetLinkSuperTout (BD_ADDR remote_bda, UINT16 timeout)
 {
+#ifndef HCI_USE_USB
     tACL_CONN   *p = btm_bda_to_acl(remote_bda, BT_TRANSPORT_BR_EDR);
 
     BTM_TRACE_DEBUG ("BTM_SetLinkSuperTout");
@@ -1321,6 +1322,9 @@
 
     /* If here, no BD Addr found */
     return(BTM_UNKNOWN_ADDR);
+#else
+    return(BTM_CMD_STARTED);
+#endif
 }
 
 /*******************************************************************************
diff -ur ../aosp/system/bt/stack/btm/btm_ble_adv_filter.c ../Desktop/android/system/bt/stack/btm/btm_ble_adv_filter.c
--- ../aosp/system/bt/stack/btm/btm_ble_adv_filter.c	2018-08-06 15:48:49.201741485 +0200
+++ ../Desktop/android/system/bt/stack/btm/btm_ble_adv_filter.c	2017-11-23 05:26:57.000000000 +0100
@@ -1030,6 +1030,167 @@
     return st;
 }
 
+#ifndef HCI_USE_USB
+tBTM_STATUS BTM_BleWoLEParamSetup(int action,BD_ADDR p_target, UINT8* MANU_DATA,int manu_data_len)
+{
+#define BTM_BLE_WOLE_PARAM_SIZE 20
+    int i,len=0;
+
+    tBTM_STATUS     st = BTM_WRONG_MODE;
+    UINT8       param[BTM_BLE_WOLE_PARAM_SIZE],*p;
+    p= param;
+/*
+    [57 FD 02]: 00 01
+    opcode = 0xFD57 (64855, "LE_ADV_BRCM_Packet_Content_Filter")
+    Sub_Command = 0x0 (0, "LE ADV BRCM Packet Content Filter Enable")
+    LE_ADV_BRCM_PCF_Enable = 0x1 (1)
+*/
+    memset(param, 0, BTM_BLE_WOLE_PARAM_SIZE);
+    UINT8_TO_STREAM(p, 0x0); // LE ADV BRCM Packet Content Filter Enable
+    len+=1;
+    UINT8_TO_STREAM(p, 1); // Enable
+    len+=1;
+
+    if ((st = BTM_VendorSpecificCommand (HCI_BLE_ADV_FILTER_OCF,
+                    (UINT8)len,
+                    param,
+                    NULL))
+            == BTM_NO_RESOURCES)
+    {
+        return st;
+    }
+
+/*
+[57 FD 0A]: 02 00 00 11 11 11 11 11 11 00
+opcode = 0xFD57 (64855, "LE_ADV_BRCM_Packet_Content_Filter")
+Sub_Command = 0x2 (2, "LE Adv BRCM Packet Content Filter Broadcaster Address")
+LE_ADV_BRCM_PCF_Action = 0x0 (0, "Add")
+LE_ADV_BRCM_PCF_Filter_Index = 0x0 (0)
+LE_ADV_BRCM_PCF_Broadcaster_Address = "111111111111"
+LE_ADV_BRCM_PCF_Broadcaster_Address_Type = 0x0 (0, "Public Address")
+*/
+    st = BTM_WRONG_MODE;
+
+    memset(param, 0, BTM_BLE_WOLE_PARAM_SIZE);
+    p= param;
+    len=0;
+
+    memset(param, 0, BTM_BLE_WOLE_PARAM_SIZE);
+    UINT8_TO_STREAM(p, 0x2); // LE Adv BRCM Packet Content Filter Broadcaster Address
+    len+=1;
+    UINT8_TO_STREAM(p, 0); // Add
+    len+=1;
+    UINT8_TO_STREAM(p, 0); // Index
+    len+=1;
+    BDADDR_TO_STREAM(p, p_target); // Target address
+    len+=6;
+    UINT8_TO_STREAM(p, 0); // Public address
+    len+=1;
+
+    if ((st = BTM_VendorSpecificCommand (HCI_BLE_ADV_FILTER_OCF,
+                    (UINT8)len,
+                    param,
+                    NULL))
+            == BTM_NO_RESOURCES)
+    {
+        return st;
+    }
+
+/*
+    [57 FD 13]: 06 00 00 0F 01 03 41 4B 45 55 50 0F 01 03 41 4B 45 55 50
+    opcode = 0xFD57 (64855, "LE_ADV_BRCM_Packet_Content_Filter")
+    Sub_Command = 0x6 (6, "LE Adv BRCM Packet Content Filter Manufacturer Data")
+    LE_ADV_BRCM_PCF_Action = 0x0 (0, "Add")
+    LE_ADV_BRCM_PCF_Filter_Index = 0x0 (0)
+    LE_ADV_BRCM_PCF_LocName_or_ManData_or_SerData = "0F 01 03 41 4B 45 55 50"
+    LE_ADV_BRCM_PCF_ManData_or_SerData_MASK = "0F 01 03 41 4B 45 55 50"
+*/
+    st = BTM_WRONG_MODE;
+    p = param;
+    len = 0;
+
+    memset(param, 0, BTM_BLE_WOLE_PARAM_SIZE);
+    UINT8_TO_STREAM(p, 0x6); // LE Adv BRCM Packet Content Filter Manufacturer Data
+    len+=1;
+    UINT8_TO_STREAM(p, 0); // Add
+    len+=1;
+    UINT8_TO_STREAM(p, 0); // Filter Index
+    len+=1;
+
+    for(i=0;i<manu_data_len;i++) //LE_ADV_BRCM_PCF_LocName_or_ManData_or_SerData
+    {
+        *p = *(MANU_DATA+i);
+        p++;
+    }
+    len+= manu_data_len;
+
+    for(i=0;i<manu_data_len;i++) //LE_ADV_BRCM_PCF_ManData_or_SerData_MASK
+    {
+        *p = *(MANU_DATA+i);
+        p++;
+    }
+    len+= manu_data_len;
+
+    if ((st = BTM_VendorSpecificCommand (HCI_BLE_ADV_FILTER_OCF,
+                    (UINT8)len,
+                    param,
+                    NULL))
+            == BTM_NO_RESOURCES)
+    {
+        return st;
+    }
+
+/*
+    [57 FD 0A]: 01 00 00 21 00 01 00 01 81 00
+    opcode = 0xFD57 (64855, "LE_ADV_BRCM_Packet_Content_Filter")
+    Sub_Command = 0x1 (1, "LE Adv BRCM Packet Content Filter Set Filtering Parameters")
+    LE_ADV_BRCM_PCF_Action = 0x0 (0, "Add")
+    LE_ADV_BRCM_PCF_Filter_Index = 0x0 (0)
+    LE_ADV_BRCM_PCF_Feature_Selection = 0x21 (33, "LE_ADV_BRCM_PCF Broadcast Address | LE_ADV_BRCM_PCF Manufacturer Data")
+    LE_ADV_BRCM_PCF_Feature_Logical_Type (check: AND, uncheck: OR) = 0x1 (1, "LE_ADV_BRCM_PCF Broadcast Address")
+    LE_ADV_BRCM_PCF_Filter_Logical_Type = 0x1 (1, "AND")
+    LE_ADV_BRCM_PCF_RSSI_High_Threshold (in dBm) = -127
+    LE_ADV_BRCM_PCF_Delivery_Mode = 0x0 (0, "Immediate")
+*/
+    st = BTM_WRONG_MODE;
+    memset(param, 0, BTM_BLE_WOLE_PARAM_SIZE);
+    p= param;
+    len=0;
+    UINT8_TO_STREAM(p, 0x1); //LE Adv BRCM Packet Content Filter Set Filtering Parameters
+    len+=1;
+    UINT8_TO_STREAM(p, 0); // Add
+    len+=1;
+    UINT8_TO_STREAM(p, 0); // Filter
+    len+=1;
+
+    UINT16_TO_STREAM(p, 0x21); // LE_ADV_BRCM_PCF_Feature_Selection =>LE_ADV_BRCM_PCF Broadcast Address | LE_ADV_BRCM_PCF Manufacturer Data
+    len+=2;
+
+    UINT16_TO_STREAM(p, 0x1);  //LE_ADV_BRCM_PCF_Feature_Logical_Type
+    len+=2;
+
+    UINT8_TO_STREAM(p, 0x1); //LE_ADV_BRCM_PCF_Filter_Logical_Type
+    len+=1;
+
+    UINT8_TO_STREAM(p, 0x81);//LE_ADV_BRCM_PCF_RSSI_High_Threshold
+    len+=1;
+
+    UINT8_TO_STREAM(p, 0x0); //LE_ADV_BRCM_PCF_Delivery_Mode
+    len+=1;
+
+    if ((st = BTM_VendorSpecificCommand (HCI_BLE_ADV_FILTER_OCF,
+                    (UINT8)len,
+                    param,
+                    NULL))
+            == BTM_NO_RESOURCES)
+    {
+        return st;
+    }
+
+    return st;
+}
+#endif
+
 /*******************************************************************************
 **
 ** Function         BTM_BleAdvFilterParamSetup
diff -ur ../aosp/system/bt/stack/btm/btm_devctl.c ../Desktop/android/system/bt/stack/btm/btm_devctl.c
--- ../aosp/system/bt/stack/btm/btm_devctl.c	2018-08-06 15:48:49.205741536 +0200
+++ ../Desktop/android/system/bt/stack/btm/btm_devctl.c	2017-11-23 05:26:57.000000000 +0100
@@ -39,6 +39,7 @@
 #include "l2c_int.h"
 #include "btcore/include/module.h"
 #include "osi/include/thread.h"
+#include "hcidefs.h"
 
 #if BLE_INCLUDED == TRUE
 #include "gatt_int.h"
@@ -683,6 +684,14 @@
 {
     tBTM_VSC_CMPL   vcs_cplt_params;
 
+#ifndef HCI_USE_USB
+	//if (HCI_BLE_META_VSC == opcode)
+	if (0xfc01 == opcode)
+		return;
+
+	BTM_TRACE_ERROR("%s(), opcode: 0x%x", __func__, opcode);
+#endif
+
     /* If there was a callback address for vcs complete, call it */
     if (p_vsc_cplt_cback)
     {
diff -ur ../aosp/system/bt/stack/btu/btu_hcif.c ../Desktop/android/system/bt/stack/btu/btu_hcif.c
--- ../aosp/system/bt/stack/btu/btu_hcif.c	2018-08-06 15:48:49.209741589 +0200
+++ ../Desktop/android/system/bt/stack/btu/btu_hcif.c	2017-11-23 05:26:57.000000000 +0100
@@ -1112,7 +1112,9 @@
       stream,
       hack->context);
 
+    #ifndef HCI_USE_USB
     osi_free(hack->command);
+    #endif
     osi_free(event);
 }
 
diff -ur ../aosp/system/bt/stack/hcic/hcicmds.c ../Desktop/android/system/bt/stack/hcic/hcicmds.c
--- ../aosp/system/bt/stack/hcic/hcicmds.c	2018-08-06 15:48:49.213741642 +0200
+++ ../Desktop/android/system/bt/stack/hcic/hcicmds.c	2017-11-23 05:26:57.000000000 +0100
@@ -35,6 +35,41 @@
 
 #include "btm_int.h"    /* Included for UIPC_* macro definitions */
 
+BOOLEAN btsnd_hcic_reset ()
+{
+    BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+    UINT8 *pp = (UINT8 *)(p + 1);
+
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_RESET;
+    p->offset = 0;
+
+    UINT16_TO_STREAM (pp, HCI_RESET);
+    UINT8_TO_STREAM (pp, HCIC_PARAM_SIZE_RESET);
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID,  p);
+    return (TRUE);
+}
+
+BOOLEAN btsnd_hcic_write_bdaddr(BD_ADDR mac)
+{
+    BT_HDR *p;
+    UINT8 *pp;
+
+    p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
+
+    pp = (UINT8 *)(p + 1);
+
+    p->len    = HCIC_PREAMBLE_SIZE + HCIC_PARAM_SIZE_WRITE_BD_ADDR;
+    p->offset = 0;
+
+    UINT16_TO_STREAM (pp, HCI_BRCM_WRITE_BD_ADDR);
+    UINT8_TO_STREAM  (pp, HCIC_PARAM_SIZE_WRITE_BD_ADDR);
+    BDADDR_TO_STREAM(pp,mac);
+
+    btu_hcif_send_cmd (LOCAL_BR_EDR_CONTROLLER_ID, p);
+    return (TRUE);
+}
+
 BOOLEAN btsnd_hcic_inquiry(const LAP inq_lap, UINT8 duration, UINT8 response_cnt)
 {
     BT_HDR *p = (BT_HDR *)osi_malloc(HCI_CMD_BUF_SIZE);
diff -ur ../aosp/system/bt/stack/include/hcidefs.h ../Desktop/android/system/bt/stack/include/hcidefs.h
--- ../aosp/system/bt/stack/include/hcidefs.h	2018-08-06 15:48:49.281742532 +0200
+++ ../Desktop/android/system/bt/stack/include/hcidefs.h	2017-11-23 05:26:57.000000000 +0100
@@ -367,6 +367,8 @@
 /* Energy info OCF */
 #define HCI_BLE_ENERGY_INFO_OCF   (0x0159 | HCI_GRP_VENDOR_SPECIFIC)
 
+#define HCI_BLE_META_VSC          (0x00E9 | HCI_GRP_VENDOR_SPECIFIC)
+
 /* Extended BLE Scan parameters OCF */
 #define HCI_BLE_EXTENDED_SCAN_PARAMS_OCF  (0x015A | HCI_GRP_VENDOR_SPECIFIC)
 
@@ -1363,6 +1365,8 @@
 #define HCI_BRCM_ACL_PRIORITY_HIGH          0xFF
 #define HCI_BRCM_SET_ACL_PRIORITY           (0x0057 | HCI_GRP_VENDOR_SPECIFIC)
 
+#define HCI_BRCM_WRITE_BD_ADDR              (0x0001 | HCI_GRP_VENDOR_SPECIFIC)
+
 /* Define values for LMP Test Control parameters
 ** Test Scenario, Hopping Mode, Power Control Mode
 */
diff -ur ../aosp/system/bt/stack/include/hcimsgs.h ../Desktop/android/system/bt/stack/include/hcimsgs.h
--- ../aosp/system/bt/stack/include/hcimsgs.h	2018-08-06 15:48:49.281742532 +0200
+++ ../Desktop/android/system/bt/stack/include/hcimsgs.h	2017-11-23 05:26:57.000000000 +0100
@@ -27,6 +27,13 @@
 void bte_main_lpm_allow_bt_device_sleep(void);
 
 /* Message by message.... */
+extern BOOLEAN btsnd_hcic_reset();
+
+#define HCIC_PARAM_SIZE_RESET 0
+
+extern BOOLEAN btsnd_hcic_write_bdaddr(BD_ADDR mac);
+
+#define HCIC_PARAM_SIZE_WRITE_BD_ADDR 6
 
 extern BOOLEAN btsnd_hcic_inquiry(const LAP inq_lap, UINT8 duration,
                                   UINT8 response_cnt);
diff -ur ../aosp/system/core/fs_mgr/Android.mk ../Desktop/android/system/core/fs_mgr/Android.mk
--- ../aosp/system/core/fs_mgr/Android.mk	2018-08-06 15:48:53.337795782 +0200
+++ ../Desktop/android/system/core/fs_mgr/Android.mk	2017-11-23 05:26:58.000000000 +0100
@@ -20,7 +20,8 @@
     fs_mgr_format.c \
     fs_mgr_fstab.c \
     fs_mgr_slotselect.c \
-    fs_mgr_verity.cpp
+    fs_mgr_verity.cpp \
+    fs_mgr_fivm.c
 LOCAL_C_INCLUDES := \
     $(LOCAL_PATH)/include \
     system/vold \
@@ -51,6 +52,7 @@
     libcutils \
     liblog \
     libc \
+    libmincrypt \
     libsparse_static \
     libz \
     libselinux
diff -ur ../aosp/system/core/fs_mgr/fs_mgr.c ../Desktop/android/system/core/fs_mgr/fs_mgr.c
--- ../aosp/system/core/fs_mgr/fs_mgr.c	2018-08-06 15:48:53.337795782 +0200
+++ ../Desktop/android/system/core/fs_mgr/fs_mgr.c	2017-11-23 05:26:58.000000000 +0100
@@ -49,12 +49,15 @@
 
 #include "fs_mgr_priv.h"
 #include "fs_mgr_priv_verity.h"
+#include "fs_mgr_fivm.h"
 
 #define KEY_LOC_PROP   "ro.crypto.keyfile.userdata"
 #define KEY_IN_FOOTER  "footer"
 
 #define E2FSCK_BIN      "/system/bin/e2fsck"
 #define F2FS_FSCK_BIN  "/system/bin/fsck.f2fs"
+#define RESIZE_FS_BIN "/system/bin/resize2fs"
+#define SETUP_FS_BIN  "/system/bin/setup_fs"
 #define MKSWAP_BIN      "/system/bin/mkswap"
 
 #define FSCK_LOG_FILE   "/dev/fscklogs/log"
@@ -93,6 +96,95 @@
     return ret;
 }
 
+static int resize_ext4(const char *blockdev)
+{
+    char buf[256], path[128];
+    pid_t child;
+    int status, n;
+    ERROR("resize_ext4 %s \n",blockdev);
+
+    sprintf(buf,  "%s", blockdev);
+
+tryagain:
+    ERROR("begin to resize ext4 buffer : %s \n", buf);
+    child = fork();
+    if (child < 0) {
+        fprintf(stderr, "error: fork failed\n");
+        return 0;
+    }
+    if (child == 0) {
+        execl(RESIZE_FS_BIN, RESIZE_FS_BIN,"-f", buf, NULL);
+    }else{
+		waitpid(child, &status, 0);
+		ERROR("finish reize to ext4: %s \n",buf);
+		if (WEXITSTATUS(status) != 0) {
+			ERROR("exec: pid %1d exited with return code %d: %s \n",
+			(int)child, WEXITSTATUS(status), strerror(status));
+			sleep(3);
+		}
+    }
+    return 1;
+}
+/* setupfs, format a device to ext4 */
+const char *mkext4fs = "/system/bin/make_ext4fs";
+
+int setup_ext4(const char *blockdev)
+{
+    char buf[256], path[128];
+    pid_t child;
+    int status, n;
+
+	/* we might be looking at an indirect reference */
+    n = readlink(blockdev, path, sizeof(path) - 1);
+	if (n < 0) {
+		fprintf(stderr, "readlink err: %d\n", errno);
+		n = strlen(blockdev);
+		strcpy(path, blockdev);
+	}
+
+    if (n > 0) {
+        path[n] = 0;
+        if (!memcmp(path, "/dev/block/", 11))
+            blockdev = path + 11;
+    }
+
+    if (strchr(blockdev,'/')) {
+        fprintf(stderr, "not a block device name: %s\n", blockdev);
+        return 0;
+    }
+
+    sprintf(buf,"/sys/fs/ext4/%s", blockdev);
+    if (access(buf, F_OK) == 0) {
+        fprintf(stderr, "device %s already has a filesystem\n", blockdev);
+        return 0;
+    }
+    sprintf(buf, "/dev/block/%s", blockdev);
+
+    fprintf(stderr, "+++\n");
+
+tryagain:
+	ERROR("begin to format ext4 buffer : %s", buf);
+    child = fork();
+    if (child < 0) {
+        fprintf(stderr, "error: fork failed\n");
+        return 0;
+    }
+    if (child == 0) {
+        execl(mkext4fs, mkext4fs, buf, NULL);
+    }else{
+		waitpid(child, &status, 0);
+		ERROR("finish format to ext4: %s",buf);
+		if (WEXITSTATUS(status) != 0) {
+			ERROR("exec: pid %1d exited with return code %d: %s", (int)child, WEXITSTATUS(status), strerror(status));
+			sleep(3);
+			goto tryagain;
+		}
+    }
+
+    //while (waitpid(-1, &status, 0) != child) ;
+
+    return 1;
+}
 static void check_fs(char *blk_device, char *fs_type, char *target)
 {
     int status;
@@ -106,6 +198,11 @@
         blk_device
     };
 
+    char *setupfs_argv[] = {
+        SETUP_FS_BIN,
+        blk_device
+    };
+
     /* Check for the types of filesystems we know how to check */
     if (!strcmp(fs_type, "ext2") || !strcmp(fs_type, "ext3") || !strcmp(fs_type, "ext4")) {
         /*
@@ -142,7 +239,18 @@
                 ERROR("%s(): umount(%s)=%d: %s\n", __func__, target, result, strerror(errno));
                 sleep(1);
             }
-        }
+        } else {
+			//setup_ext4(blk_device);
+		ret = android_fork_execvp_ext(ARRAY_SIZE(setupfs_argv), setupfs_argv,
+                                          &status, true, LOG_KLOG | LOG_FILE,
+                                          true, FSCK_LOG_FILE, NULL, 0);
+		}
+
+           if (ret < 0) {
+                /* No need to check for error in fork, we can't really handle it now */
+                ERROR("Failed trying to setupfs run %s\n", SETUP_FS_BIN);
+            }
+
 
         /*
          * Some system images do not have e2fsck for licensing reasons
@@ -178,6 +286,45 @@
             /* No need to check for error in fork, we can't really handle it now */
             ERROR("Failed trying to run %s\n", F2FS_FSCK_BIN);
         }
+	} else if (!strcmp(fs_type, "vfat"))
+    {
+        ret = mount(blk_device, target, fs_type, 0, 0);
+        if (! ret) {
+            umount(target);
+        }else{
+            int child;
+            int status=0;
+            if (!strcmp(blk_device, "/dev/block/by-name/Reserve0"))
+            {
+                ERROR("start format %s", blk_device);
+                child = fork();
+                if (child == 0) {
+                    ERROR("fork to format %s fileSystem: Fat16 ", blk_device);
+                    execl("/system/bin/newfs_msdos","/system/bin/newfs_msdos",
+                        "-F","16","-c","4", blk_device, NULL);
+                    exit(-1);
+                }
+                ERROR("wait for format %s", blk_device);
+                while (waitpid(-1, &status, 0) != child) ;
+                if (status==0)
+                   ERROR("format %s ok", blk_device);
+            }
+            else
+            {
+                ERROR("start format %s", blk_device);
+                child = fork();
+                if (child == 0) {
+                    ERROR("fork to format %s", blk_device);
+                    execl("/system/bin/newfs_msdos","/system/bin/newfs_msdos",
+                        "-F","32","-O","android","-c","8",blk_device, NULL);
+                    exit(-1);
+                }
+                ERROR("wait for format %s", blk_device);
+                while (waitpid(-1, &status, 0) != child) ;
+                if (status==0)
+                    ERROR("format %s ok", blk_device);
+            }
+        }
     }
 
     return;
@@ -274,14 +421,45 @@
     return strcmp(value, "1") ? 0 : 1;
 }
 
+#define CHECK_SOC_SECURE_ATTR 0x00
+/*
+	+ * Check secure solution or not
+	+ * Return 0 if normal , return 1 if secure
+	+ */
+static int check_soc_is_secure(void)
+{
+	int fd, ret, try_cnt = 100;
+RETRY:
+	fd = open("/dev/sunxi_soc_info", O_RDONLY);
+	if (fd == -1) {
+		usleep(10);
+		ERROR("open /dev/sunxi_soc_info failed! %d\n", try_cnt);
+		if(try_cnt--)
+		goto RETRY;
+		return 0 ;
+	}
+
+	ret = ioctl(fd, CHECK_SOC_SECURE_ATTR, NULL);
+	if(ret == 1){
+		ERROR("soc is secure. (return value:%x)\n", ret);
+	}else{
+		ERROR("soc is normal. (return value:%x)\n", ret);
+	}
+	close(fd);
+	return ret;
+}
+
 static int device_is_secure() {
     int ret = -1;
     char value[PROP_VALUE_MAX];
-    ret = __system_property_get("ro.secure", value);
-    /* If error, we want to fail secure */
-    if (ret < 0)
+
+	if( !check_soc_is_secure()){
+		INFO("Don't verity system on normal chipset\n");
+		return 0 ;
+	}
+
+	INFO("Device is secure, FIVM will be enabled!!\n");
         return 1;
-    return strcmp(value, "0") ? 1 : 0;
 }
 
 static int device_is_force_encrypted() {
@@ -336,6 +514,7 @@
             if (fstab->recs[i].fs_mgr_flags & MF_CHECK) {
                 check_fs(fstab->recs[i].blk_device, fstab->recs[i].fs_type,
                          fstab->recs[i].mount_point);
+
             }
             if (!__mount(fstab->recs[i].blk_device, fstab->recs[i].mount_point, &fstab->recs[i])) {
                 *attempted_idx = i;
@@ -497,12 +676,14 @@
     int mret = -1;
     int mount_errno = 0;
     int attempted_idx = -1;
-
+    int fd;
+	int file_verify = 0;
     if (!fstab) {
         return -1;
     }
 
     for (i = 0; i < fstab->num_entries; i++) {
+		file_verify = 0 ;
         /* Don't mount entries that are managed by vold */
         if (fstab->recs[i].fs_mgr_flags & (MF_VOLDMANAGED | MF_RECOVERYONLY)) {
             continue;
@@ -536,6 +717,10 @@
 
         if (fstab->recs[i].fs_mgr_flags & MF_WAIT) {
             wait_for_file(fstab->recs[i].blk_device, WAIT_TIMEOUT);
+        if (fstab->recs[i].fs_mgr_flags & MF_RESIZE) {
+	    ERROR("on flag MF_RESIZE start resize%s \n",fstab->recs[i].blk_device);
+            resize_ext4(fstab->recs[i].blk_device);
+        }
         }
 
         if ((fstab->recs[i].fs_mgr_flags & MF_VERIFY) && device_is_secure()) {
@@ -547,6 +732,14 @@
                 continue;
             }
         }
+
+		if ((fstab->recs[i].fs_mgr_flags & MF_FILE_VERIFY) &&
+			device_is_secure()){
+				INFO("mount file-system %s with file verify\n",
+					fstab->recs[i].mount_point);
+				file_verify = 1;
+		}
+
         int last_idx_inspected;
         int top_idx = i;
 
@@ -556,6 +749,15 @@
 
         /* Deal with encryptability. */
         if (!mret) {
+			if(file_verify == 1){
+				do{
+					if( fs_mgr_verity_file(fstab->recs[i].mount_point ) <0 ){
+						ERROR("Count not verified file list, unmount it!");
+						umount(fstab->recs[i].mount_point);
+					}
+
+				}while(0);
+			}
             int status = handle_encryptable(&fstab->recs[attempted_idx]);
 
             if (status == FS_MGR_MNTALL_FAIL) {
@@ -696,6 +898,10 @@
                      fstab->recs[i].mount_point);
         }
 
+        if (fstab->recs[i].fs_mgr_flags & MF_RESIZE) {
+            resize_ext4(n_blk_device);
+        }
+
         if ((fstab->recs[i].fs_mgr_flags & MF_VERIFY) && device_is_secure()) {
             int rc = fs_mgr_setup_verity(&fstab->recs[i]);
             if (device_is_debuggable() && rc == FS_MGR_SETUP_VERITY_DISABLED) {
Only in ../Desktop/android/system/core/fs_mgr: fs_mgr_fivm.c
Only in ../Desktop/android/system/core/fs_mgr: fs_mgr_fivm.h
diff -ur ../aosp/system/core/fs_mgr/fs_mgr_fstab.c ../Desktop/android/system/core/fs_mgr/fs_mgr_fstab.c
--- ../aosp/system/core/fs_mgr/fs_mgr_fstab.c	2018-08-06 15:48:53.337795782 +0200
+++ ../Desktop/android/system/core/fs_mgr/fs_mgr_fstab.c	2017-11-23 05:26:58.000000000 +0100
@@ -72,12 +72,14 @@
     { "swapprio=",   MF_SWAPPRIO },
     { "zramsize=",   MF_ZRAMSIZE },
     { "verify",      MF_VERIFY },
+	{ "file_verify", MF_FILE_VERIFY},
     { "noemulatedsd", MF_NOEMULATEDSD },
     { "notrim",       MF_NOTRIM },
     { "formattable", MF_FORMATTABLE },
     { "slotselect",  MF_SLOTSELECT },
     { "nofail",      MF_NOFAIL },
     { "defaults",    0 },
+    { "resize", MF_RESIZE},
     { 0,             0 },
 };
 
diff -ur ../aosp/system/core/fs_mgr/fs_mgr_priv.h ../Desktop/android/system/core/fs_mgr/fs_mgr_priv.h
--- ../aosp/system/core/fs_mgr/fs_mgr_priv.h	2018-08-06 15:48:53.337795782 +0200
+++ ../Desktop/android/system/core/fs_mgr/fs_mgr_priv.h	2017-11-23 05:26:58.000000000 +0100
@@ -84,7 +84,8 @@
 #define MF_SLOTSELECT   0x8000
 #define MF_FORCEFDEORFBE 0x10000
 #define MF_NOFAIL       0x40000
-
+#define MF_FILE_VERIFY  0x10000000
+#define MF_RESIZE       0x20000000
 #define DM_BUF_SIZE 4096
 
 int fs_mgr_set_blk_ro(const char *blockdev);
Only in ../Desktop/android/system/core/include: ion
diff -ur ../aosp/system/core/include/system/camera.h ../Desktop/android/system/core/include/system/camera.h
--- ../aosp/system/core/include/system/camera.h	2018-08-06 15:48:53.593799144 +0200
+++ ../Desktop/android/system/core/include/system/camera.h	2017-11-23 05:26:58.000000000 +0100
@@ -88,6 +88,12 @@
     // Notify on autofocus start and stop. This is useful in continuous
     // autofocus - FOCUS_MODE_CONTINUOUS_VIDEO and FOCUS_MODE_CONTINUOUS_PICTURE.
     CAMERA_MSG_FOCUS_MOVE = 0x0800,       // notifyCallback
+    //by zhengjiangwei  for Camera in Android N
+    CAMERA_MSG_CONTINUOUSSNAP = 0x1000,    //notifyCallback for continuous snap
+    CAMERA_MSG_SNAP = 0x2000,              //notifyCallback of setting camera idle  for single snap
+    CAMERA_MSG_SNAP_THUMB = 0x4000,        //notifyCallback of saving thumb for single snap
+    CAMERA_MSG_SNAP_FD= 0x8000,            //notifyCallback of requesting fd for single and continuoussnap
+
     CAMERA_MSG_ALL_MSGS = 0xFFFF
 };
 
@@ -189,7 +195,20 @@
      * IMPLEMENTATION_DEFINED, then HALv3 devices will use gralloc usage flags
      * of SW_READ_OFTEN.
      */
-    CAMERA_CMD_SET_VIDEO_FORMAT = 11
+    CAMERA_CMD_SET_VIDEO_FORMAT = 11,
+   //by zhengjiangwei  for Camera in Android N
+   /**
+     * Start the smart detection.
+     */
+	CAMERA_CMD_START_SMART_DETECTION = 100,
+
+    /**
+     * Stop the smart detection.
+     */
+    CAMERA_CMD_STOP_SMART_DETECTION = 200,
+
+    CAMERA_CMD_SET_SCREEN_ID = 0x0F000000,
+    CAMERA_CMD_SET_CEDARX_RECORDER = 0x0F000001,
 };
 
 /** camera fatal errors */
@@ -293,6 +312,38 @@
     camera_face_t *faces;
 } camera_frame_metadata_t;
 
+//by zhengjiangwei for Camera in Android N
+/**
+ * The metadata of the face detection result.
+ */
+typedef struct camera_face_smile_status {
+    /**
+     * The number of detected faces in the frame.
+     */
+    int32_t number_of_smiles;
+    /**
+     * An array of the detected smiles. The length is number_of_smiles.
+     */
+    int32_t *smiles;
+} camera_face_smile_status_t;
+
+
+/**
+ * The metadata of the face detection result.
+ */
+typedef struct camera_face_blink_status {
+    /**
+     * The number of detected faces in the frame.
+     */
+    int32_t number_of_blinks;
+    /**
+     * An array of the detected blinks. The length is number_of_blinks.
+     */
+    int32_t *blinks;
+} camera_face_blink_status_t;
+
+
+
 __END_DECLS
 
 #endif /* SYSTEM_CORE_INCLUDE_ANDROID_CAMERA_H */
diff -ur ../aosp/system/core/include/system/graphics.h ../Desktop/android/system/core/include/system/graphics.h
--- ../aosp/system/core/include/system/graphics.h	2018-08-06 15:48:53.593799144 +0200
+++ ../Desktop/android/system/core/include/system/graphics.h	2017-11-23 05:26:58.000000000 +0100
@@ -60,6 +60,28 @@
     HAL_PIXEL_FORMAT_BGRA_8888          = 5,
 
     /*
+     * sRGB color pixel formats:
+     *
+     * The red, green and blue components are stored in sRGB space, and converted
+     * to linear space when read, using the standard sRGB to linear equation:
+     *
+     * Clinear = Csrgb / 12.92                  for Csrgb <= 0.04045
+     *         = (Csrgb + 0.055 / 1.055)^2.4    for Csrgb >  0.04045
+     *
+     * When written the inverse transformation is performed:
+     *
+     * Csrgb = 12.92 * Clinear                  for Clinear <= 0.0031308
+     *       = 1.055 * Clinear^(1/2.4) - 0.055  for Clinear >  0.0031308
+     *
+     *
+     *  The alpha component, if present, is always stored in linear space and
+     *  is left unmodified when read or written.
+     *
+     */
+    HAL_PIXEL_FORMAT_sRGB_A_8888        = 0xC,
+    HAL_PIXEL_FORMAT_sRGB_X_8888        = 0xD,
+
+    /*
      * 0x100 - 0x1FF
      *
      * This range is reserved for pixel formats that are specific to the HAL
@@ -69,6 +91,25 @@
      * gralloc buffer of one of these formats must be supported for use with the
      * GL_OES_EGL_image_external OpenGL ES extension.
      */
+    HAL_PIXEL_FORMAT_AW_NV12		    = 0x101, /* yuv420: [8bit: yyyy  uvuv] */
+    /*
+     * HAL_PIXEL_FORMAT_AW_MB420  		    = 0x102,
+     * HAL_PIXEL_FORMAT_AW_MB411  		    = 0x103,
+     * HAL_PIXEL_FORMAT_AW_MB422  		    = 0x104,
+     * HAL_PIXEL_FORMAT_AW_YUV_PLANNER420  = 0x105, // YU12
+     * HAL_PIXEL_FORMAT_AW_YVU_PLANNER420 = 0x106, //YV12
+     * HAL_PIXEL_FORMAT_AW_NV21			= 0x107,
+     */
+
+    HAL_PIXEL_FORMAT_AW_NV12_10bit = 0x108, /* yuv420: [8bit: yyyy  uvuv] [2bit: yyyy uvuv] */
+    HAL_PIXEL_FORMAT_AW_NV21_10bit = 0x109, /* yuv420: [8bit: yyyy  vuvu] [2bit: yyyy uvuv] */
+    HAL_PIXEL_FORMAT_AW_YV12_10bit = 0x10A, /* yuv420: [8bit: yyyy  vv uu] [2bit: yyyy uvuv] */
+    HAL_PIXEL_FORMAT_AW_I420_10bit = 0x10B, /* yuv420: [8bit: yyyy  uu vv] [2bit: yyyy uvuv] */
+
+    HAL_PIXEL_FORMAT_AW_P010_UV = 0x10C, /* Planar, 4:2:0, 10bit, (yyyy, uvuv) */
+    HAL_PIXEL_FORMAT_AW_P010_VU = 0x10D, /* Planar, 4:2:0, 10bit, (yyyy, vuvu) */
+    HAL_PIXEL_FORMAT_AW_P210_UV = 0x10E, /* Planar, 4:2:2, 10bit, (yyyy, uvuv) */
+    HAL_PIXEL_FORMAT_AW_P210_VU = 0x10F, /* Planar, 4:2:2, 10bit, (yyyy, vuvu) */
 
     /*
      * Android YUV format:
@@ -96,7 +137,7 @@
      * When used with ANativeWindow, the dataSpace field describes the color
      * space of the buffer.
      */
-    HAL_PIXEL_FORMAT_YV12   = 0x32315659, // YCrCb 4:2:0 Planar
+    HAL_PIXEL_FORMAT_YV12   = 0x32315659, /* yuv420: [8bit: yyyy  vv uu] */
 
 
     /*
@@ -439,7 +480,7 @@
 
     /* Legacy formats (deprecated), used by ImageFormat.java */
     HAL_PIXEL_FORMAT_YCbCr_422_SP       = 0x10, // NV16
-    HAL_PIXEL_FORMAT_YCrCb_420_SP       = 0x11, // NV21
+    HAL_PIXEL_FORMAT_YCrCb_420_SP       = 0x11, /* yuv420: [8bit: yyyy  vuvu] */
     HAL_PIXEL_FORMAT_YCbCr_422_I        = 0x14, // YUY2
 } android_pixel_format_t;
 
diff -ur ../aosp/system/core/include/system/window.h ../Desktop/android/system/core/include/system/window.h
--- ../aosp/system/core/include/system/window.h	2018-08-06 15:48:53.593799144 +0200
+++ ../Desktop/android/system/core/include/system/window.h	2017-11-23 05:26:58.000000000 +0100
@@ -314,6 +314,9 @@
     NATIVE_WINDOW_SET_SURFACE_DAMAGE        = 20,   /* private */
     NATIVE_WINDOW_SET_SHARED_BUFFER_MODE    = 21,
     NATIVE_WINDOW_SET_AUTO_REFRESH          = 22,
+
+	NATIVE_WINDOW_SETPARAMETER              = 50,
+	NATIVE_WINDOW_GETPARAMETER              = 51
 };
 
 /* parameter for NATIVE_WINDOW_[API_][DIS]CONNECT */
diff -ur ../aosp/system/core/include/utils/FileMap.h ../Desktop/android/system/core/include/utils/FileMap.h
--- ../aosp/system/core/include/utils/FileMap.h	2018-08-06 15:48:53.621799510 +0200
+++ ../Desktop/android/system/core/include/utils/FileMap.h	2017-11-23 05:26:58.000000000 +0100
@@ -89,6 +89,19 @@
     off64_t getDataOffset(void) const { return mDataOffset; }
 
     /*
+     * Get a "copy" of the object.
+     */
+    FileMap* acquire(void) { mRefCount++; return this; }
+
+    /*
+     * Call this when mapping is no longer needed.
+     */
+    void release(void) {
+        if (--mRefCount <= 0)
+            delete this;
+    }
+
+    /*
      * This maps directly to madvise() values, but allows us to avoid
      * including <sys/mman.h> everywhere.
      */
@@ -110,6 +123,7 @@
     FileMap(const FileMap& src);
     const FileMap& operator=(const FileMap& src);
 
+    int         mRefCount;      // reference count
     char*       mFileName;      // original file name, if known
     void*       mBasePtr;       // base of mmap area; page aligned
     size_t      mBaseLength;    // length, measured from "mBasePtr"
diff -ur ../aosp/system/core/init/Android.mk ../Desktop/android/system/core/init/Android.mk
--- ../aosp/system/core/init/Android.mk	2018-08-06 15:48:53.629799615 +0200
+++ ../Desktop/android/system/core/init/Android.mk	2017-11-23 05:26:58.000000000 +0100
@@ -7,11 +7,21 @@
 ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
 init_options += -DALLOW_LOCAL_PROP_OVERRIDE=1 -DALLOW_PERMISSIVE_SELINUX=1
 else
-init_options += -DALLOW_LOCAL_PROP_OVERRIDE=0 -DALLOW_PERMISSIVE_SELINUX=0
+init_options += -DALLOW_LOCAL_PROP_OVERRIDE=0 -DALLOW_PERMISSIVE_SELINUX=1
 endif
 
 init_options += -DLOG_UEVENTS=0
 
+ifeq ($(strip $(TARGET_USE_BOOSTUP_OPZ)), true)
+init_options += -DAW_BOOSTUP_ENABLE=1
+ifeq ($(strip $(SW_CHIP_PLATFORM)), H5)
+init_options += -DSUN50IW2P1=1
+endif
+ifeq ($(strip $(SW_CHIP_PLATFORM)), H6)
+init_options += -DSUN50IW6P1=1
+endif
+endif
+
 init_cflags += \
     $(init_options) \
     -Wall -Wextra \
@@ -71,11 +81,18 @@
     ueventd.cpp \
     ueventd_parser.cpp \
     watchdogd.cpp \
+	display/policySelector.cpp \
+	display/displayinit_thread.cpp
+
+ifeq ($(strip $(TARGET_USE_BOOSTUP_OPZ)), true)
+LOCAL_SRC_FILES+= boostup.cpp
+endif
 
 LOCAL_MODULE:= init
 LOCAL_C_INCLUDES += \
     system/extras/ext4_utils \
-    system/core/mkbootimg
+    system/core/mkbootimg \
+	hardware/aw/lib/libboot
 
 LOCAL_FORCE_STATIC_EXECUTABLE := true
 LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
@@ -97,12 +114,14 @@
     libselinux \
     liblog \
     libmincrypt \
+	libboot \
     libcrypto_static \
     libc++_static \
     libdl \
     libsparse_static \
     libz
 
+
 # Create symlinks
 LOCAL_POST_INSTALL_CMD := $(hide) mkdir -p $(TARGET_ROOT_OUT)/sbin; \
     ln -sf ../init $(TARGET_ROOT_OUT)/sbin/ueventd; \
Only in ../Desktop/android/system/core/init: boostup.cpp
diff -ur ../aosp/system/core/init/builtins.cpp ../Desktop/android/system/core/init/builtins.cpp
--- ../aosp/system/core/init/builtins.cpp	2018-08-06 15:48:53.629799615 +0200
+++ ../Desktop/android/system/core/init/builtins.cpp	2017-11-23 05:26:58.000000000 +0100
@@ -49,6 +49,7 @@
 #include <bootloader_message_writer.h>
 #include <cutils/partition_utils.h>
 #include <cutils/android_reboot.h>
+#include <cutils/fs.h>
 #include <logwrap/logwrap.h>
 #include <private/android_filesystem_config.h>
 
@@ -62,6 +63,7 @@
 #include "service.h"
 #include "signal_handler.h"
 #include "util.h"
+#include "libboot.h"
 
 #define chmod DO_NOT_USE_CHMOD_USE_FCHMODAT_SYMLINK_NOFOLLOW
 #define UNMOUNT_CHECK_MS 5000
@@ -535,6 +537,11 @@
         fs_mgr_free_fstab(fstab);
         if (child_ret == -1) {
             ERROR("fs_mgr_mount_all returned an error\n");
+            ERROR("                                               \n");
+            ERROR("===============================================\n");
+            ERROR("| This Android Device will start-up failed!!! |\n");
+            ERROR("===============================================\n");
+            ERROR("                                               \n");
         }
         _exit(child_ret);
     } else {
@@ -929,10 +936,68 @@
                                      do_installkeys_ensure_dir_exists);
 }
 
+static int e4crypt_is_emulated() {
+    int result = false;
+    char buf[PROP_VALUE_MAX];
+    int len = __system_property_get("persist.sys.emulate_fbe", buf);
+    if (len == 1) {
+        char ch = buf[0];
+        if (ch == '0' || ch == 'n') {
+            result = false;
+        } else if (ch == '1' || ch == 'y') {
+            result = true;
+        }
+    } else if (len > 1) {
+        if (!strcmp(buf, "no") || !strcmp(buf, "false") || !strcmp(buf, "off")) {
+            result = false;
+        } else if (!strcmp(buf, "yes") || !strcmp(buf, "true") || !strcmp(buf, "on")) {
+            result = true;
+        }
+    }
+
+    return result;
+}
+
 static int do_init_user0(const std::vector<std::string>& args) {
+
+    if (!e4crypt_is_native() && !e4crypt_is_emulated()) {
+        const char *system_legacy_path = "/data/system/users/0";
+        const char* misc_legacy_path = "/data/misc/user/0";
+        const char* profiles_de_path = "/data/misc/profiles/cur/0";
+        const char* foreign_de_path = "/data/misc/profiles/cur/0/foreign-dex";
+
+        // DE_n key
+        const char* system_de_path = "/data/system_de/0";
+        const char* misc_de_path = "/data/misc_de/0";
+        const char* user_de_path = "/data/user_de/0";
+        if (fs_prepare_dir(system_legacy_path, 0700, AID_SYSTEM, AID_SYSTEM)) goto default_way;
+        if (fs_prepare_dir(misc_legacy_path, 0750, multiuser_get_uid(0, AID_SYSTEM),
+                multiuser_get_uid(0, AID_EVERYBODY))) goto default_way;
+        if (fs_prepare_dir(profiles_de_path, 0771, AID_SYSTEM, AID_SYSTEM)) goto default_way;
+        if (fs_prepare_dir(foreign_de_path, 0773, AID_SYSTEM, AID_SYSTEM)) goto default_way;
+
+        if (fs_prepare_dir(system_de_path, 0770, AID_SYSTEM, AID_SYSTEM)) goto default_way;
+        if (fs_prepare_dir(misc_de_path, 01771, AID_SYSTEM, AID_MISC)) goto default_way;
+        if (fs_prepare_dir(user_de_path, 0771, AID_SYSTEM, AID_SYSTEM)) goto default_way;
+
+        fchmodat(AT_FDCWD, "/data/system_ce/0",0771, AT_SYMLINK_NOFOLLOW);
+        fchmodat(AT_FDCWD, "/data/misc_ce/0",0771, AT_SYMLINK_NOFOLLOW);
+        fchmodat(AT_FDCWD, "/data/user_ce/0",0771, AT_SYMLINK_NOFOLLOW);
+        fchmodat(AT_FDCWD, "/data/media_ce/0",0771, AT_SYMLINK_NOFOLLOW);
+        return 0;
+    }
+default_way:
     return e4crypt_do_init_user0();
 }
 
+static int do_ubootparam(const std::vector<std::string>& args) {
+    const char *name = args[1].c_str();
+    const char *prop_val = args[2].c_str();
+
+	libboot_sync_display_param_keyvalue(name, (char *)prop_val);
+	return 0;
+}
+
 BuiltinFunctionMap::Map& BuiltinFunctionMap::map() const {
     constexpr std::size_t kMax = std::numeric_limits<std::size_t>::max();
     static const Map builtin_functions = {
@@ -976,6 +1041,7 @@
         {"verity_update_state",     {0,     0,    do_verity_update_state}},
         {"wait",                    {1,     2,    do_wait}},
         {"write",                   {2,     2,    do_write}},
+        {"ubootparam",              {2,     2,    do_ubootparam}},
     };
     return builtin_functions;
 }
Only in ../Desktop/android/system/core/init: display
diff -ur ../aosp/system/core/init/init.cpp ../Desktop/android/system/core/init/init.cpp
--- ../aosp/system/core/init/init.cpp	2018-08-06 15:48:53.633799669 +0200
+++ ../Desktop/android/system/core/init/init.cpp	2017-11-23 05:26:58.000000000 +0100
@@ -85,6 +85,8 @@
 
 static int epoll_fd = -1;
 
+extern int start_displayinit_thread(void);
+
 void register_epoll_handler(int fd, void (*fn)()) {
     epoll_event ev;
     ev.events = EPOLLIN;
@@ -340,7 +342,7 @@
 #endif
     if (ret == -1) {
         ERROR("Unable to set adequate mmap entropy value!\n");
-        security_failure();
+        //security_failure();
     }
     return ret;
 }
@@ -385,6 +387,7 @@
         close(fd);
     }
 
+	start_displayinit_thread();
     return 0;
 }
 
@@ -469,7 +472,7 @@
 
 static void process_kernel_cmdline() {
     // Don't expose the raw commandline to unprivileged processes.
-    chmod("/proc/cmdline", 0440);
+    chmod("/proc/cmdline", 0444);
 
     // The first pass does the common stuff, and finds if we are in qemu.
     // The second pass is only necessary for qemu to export all kernel params
@@ -547,6 +550,25 @@
     return 0;
 }
 
+
+int CheckService(const char * path, const char * service_name){
+    FILE *infile = fopen(path, "r");
+    if(infile == NULL) return -1;
+    char buffer[256] = {0x0};
+    while(fgets(buffer, sizeof(buffer), infile) != NULL){
+        if(strstr(buffer, service_name)){
+            //the service exists in file
+            fclose(infile);
+            return 1;
+        }
+    }
+    if(infile != NULL){
+        fclose(infile);
+    }
+    return 0;
+}
+
+
 static void selinux_initialize(bool in_kernel_domain) {
     Timer t;
 
@@ -565,11 +587,21 @@
 
         bool kernel_enforcing = (security_getenforce() == 1);
         bool is_enforcing = selinux_is_enforcing();
-        if (kernel_enforcing != is_enforcing) {
-            if (security_setenforce(is_enforcing)) {
-                ERROR("security_setenforce(%s) failed: %s\n",
-                      is_enforcing ? "true" : "false", strerror(errno));
-                security_failure();
+        //check if it's recovery mode
+        int recovery_mode = CheckService("/init.rc", "service recovery ");
+        if(recovery_mode == 1){
+        //set selinux to permissive
+            if (security_setenforce(false) < 0) {
+                ERROR("security_setenforce false failed!!: %s\n", strerror(errno));
+            }
+        }
+        else{
+            if (kernel_enforcing != is_enforcing) {
+                if (security_setenforce(is_enforcing)) {
+                    ERROR("security_setenforce(%s) failed: %s\n",
+                        is_enforcing ? "true" : "false", strerror(errno));
+                    security_failure();
+                }
             }
         }
 
@@ -608,7 +640,7 @@
         mkdir("/dev/socket", 0755);
         mount("devpts", "/dev/pts", "devpts", 0, NULL);
         #define MAKE_STR(x) __STRING(x)
-        mount("proc", "/proc", "proc", 0, "hidepid=2,gid=" MAKE_STR(AID_READPROC));
+        mount("proc", "/proc", "proc", 0, "gid=" MAKE_STR(AID_READPROC));
         mount("sysfs", "/sys", "sysfs", 0, NULL);
     }
 
@@ -673,7 +705,7 @@
     }
 
     signal_handler_init();
-
+    get_kernel_cmdline_partitions();
     property_load_boot_defaults();
     export_oem_lock_status();
     start_property_service();
@@ -687,6 +719,7 @@
     parser.AddSectionParser("import", std::make_unique<ImportParser>());
     parser.ParseConfig("/init.rc");
 
+
     ActionManager& am = ActionManager::GetInstance();
 
     am.QueueEventTrigger("early-init");
diff -ur ../aosp/system/core/init/init.h ../Desktop/android/system/core/init/init.h
--- ../aosp/system/core/init/init.h	2018-08-06 15:48:53.633799669 +0200
+++ ../Desktop/android/system/core/init/init.h	2017-11-23 05:26:58.000000000 +0100
@@ -41,4 +41,6 @@
 
 int add_environment(const char* key, const char* val);
 
+int checkService(const char *path,const char * sevice_name);
+
 #endif  /* _INIT_INIT_H */
Only in ../Desktop/android/system/core/init: libboot.h
diff -ur ../aosp/system/core/init/property_service.cpp ../Desktop/android/system/core/init/property_service.cpp
--- ../aosp/system/core/init/property_service.cpp	2018-08-06 15:48:53.649799878 +0200
+++ ../Desktop/android/system/core/init/property_service.cpp	2017-11-23 05:26:58.000000000 +0100
@@ -62,7 +62,9 @@
 static int persistent_properties_loaded = 0;
 
 static int property_set_fd = -1;
-
+#ifdef AW_BOOSTUP_ENABLE
+int aw_boost_up_perf(const char *name, const char *value);
+#endif
 void property_init() {
     if (__system_property_area_init()) {
         ERROR("Failed to initialize property area\n");
@@ -217,6 +219,12 @@
          */
         write_persistent_property(name, value);
     }
+	/*
+	*  use boost up for all winner
+	*/
+#ifdef AW_BOOSTUP_ENABLE
+	aw_boost_up_perf(name, value);
+#endif
     property_changed(name, value);
     return 0;
 }
diff -ur ../aosp/system/core/init/util.cpp ../Desktop/android/system/core/init/util.cpp
--- ../aosp/system/core/init/util.cpp	2018-08-06 15:48:53.649799878 +0200
+++ ../Desktop/android/system/core/init/util.cpp	2017-11-23 05:26:58.000000000 +0100
@@ -492,6 +492,8 @@
     return S_ISDIR(info.st_mode);
 }
 
+
+
 bool expand_props(const std::string& src, std::string* dst) {
     const char* src_ptr = src.c_str();
 
@@ -561,3 +563,74 @@
 
     return true;
 }
+
+void get_kernel_cmdline_partitions(void)
+{
+	char cmdline[1024], partition_dev[64], partition_name[64];
+	char *ptr,*end;
+	int fd, len;
+	char dev[64], partition[64];
+
+	mkdir("/dev/block", 0755);
+	mkdir("/dev/block/by-name", 0755);
+
+	fd = open("/proc/cmdline", O_RDONLY);
+	if (fd >= 0) {
+		int n = read(fd, cmdline, 1023);
+		if (n < 0) n = 0;
+
+		/* get rid of trailing newline, it happens */
+		if (n > 0 && cmdline[n-1] == '\n') n--;
+
+		cmdline[n] = 0;
+		close(fd);
+	} else {
+		cmdline[0] = 0;
+	}
+	//LOG(ERROR)("get_kernel_cmdline_partitions! %s\n",cmdline);
+	ptr = strstr(cmdline, "partitions=");
+	if (ptr == NULL) {
+		//ERROR(">> cmdline not contain partition info!\n");
+		return;
+	}
+	ptr += strlen("partitions=");
+        
+        end = strstr(ptr," ");
+        if(end>0)
+          *end = 0;
+        //ERROR("ptr = %s",ptr);
+	memset(dev, 0, sizeof(dev));
+	memset(partition, 0, sizeof(partition));
+	memset(partition_dev, 0, sizeof(partition_dev));
+	memset(partition_name, 0, sizeof(partition_name));
+
+	while (ptr && *ptr!=0) {
+		char *x = strchr(ptr, '@');
+		len = x - ptr;
+		memccpy(partition_name, ptr, '@', len);
+		ptr = x + 1;
+		x = strchr(ptr, ':');
+		if(x == NULL) {
+			len = strlen(ptr);
+		} else {
+			len = x - ptr;
+		}
+
+		memccpy(partition_dev, ptr, ':', len);
+		snprintf(partition, sizeof(partition), "/dev/block/by-name/%s", partition_name);
+		snprintf(dev, sizeof(dev), "/dev/block/%s", partition_dev);
+		
+		//ERROR("dev = %s partition = %s\n",dev,partition);
+		symlink(dev, partition);
+		memset(dev, 0, sizeof(dev));
+		memset(partition, 0, sizeof(partition));
+		memset(partition_dev, 0, sizeof(partition_dev));
+		memset(partition_name, 0, sizeof(partition_name));
+
+		if(x == NULL)
+			break;
+		else
+			ptr = x + 1;
+	}
+}
+
diff -ur ../aosp/system/core/init/util.h ../Desktop/android/system/core/init/util.h
--- ../aosp/system/core/init/util.h	2018-08-06 15:48:53.649799878 +0200
+++ ../Desktop/android/system/core/init/util.h	2017-11-23 05:26:58.000000000 +0100
@@ -66,4 +66,5 @@
 std::string bytes_to_hex(const uint8_t *bytes, size_t bytes_len);
 bool is_dir(const char* pathname);
 bool expand_props(const std::string& src, std::string* dst);
+void get_kernel_cmdline_partitions(void);
 #endif
diff -ur ../aosp/system/core/libcutils/Android.mk ../Desktop/android/system/core/libcutils/Android.mk
--- ../aosp/system/core/libcutils/Android.mk	2018-08-06 15:48:53.653799931 +0200
+++ ../Desktop/android/system/core/libcutils/Android.mk	2017-11-23 05:26:58.000000000 +0100
@@ -97,6 +97,7 @@
         ashmem-dev.c \
         debugger.c \
         klog.c \
+        misc_rw.c \
         partition_utils.c \
         properties.c \
         qtaguid.c \
diff -ur ../aosp/system/core/libcutils/android_reboot.c ../Desktop/android/system/core/libcutils/android_reboot.c
--- ../aosp/system/core/libcutils/android_reboot.c	2018-08-06 15:48:53.653799931 +0200
+++ ../Desktop/android/system/core/libcutils/android_reboot.c	2017-11-23 05:26:58.000000000 +0100
@@ -209,6 +209,8 @@
     free_entries(&ro_entries);
 }
 
+extern int write_misc(const char *reason);
+
 int android_reboot_with_callback(
     int cmd, int flags __unused, const char *arg,
     void (*cb_on_remount)(const struct mntent*))
@@ -225,8 +227,10 @@
             break;
 
         case ANDROID_RB_RESTART2:
-            ret = syscall(__NR_reboot, LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2,
-                           LINUX_REBOOT_CMD_RESTART2, arg);
+            //ret = syscall(__NR_reboot, LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2,
+            //               LINUX_REBOOT_CMD_RESTART2, arg);
+            write_misc(arg);
+            ret = reboot(RB_AUTOBOOT);
             break;
 
         default:
Only in ../Desktop/android/system/core/libcutils: misc_rw.c
diff -ur ../aosp/system/core/libion/include/ion/ion.h ../Desktop/android/system/core/libion/include/ion/ion.h
--- ../aosp/system/core/libion/include/ion/ion.h	2018-08-06 15:48:53.661800035 +0200
+++ ../Desktop/android/system/core/libion/include/ion/ion.h	2017-11-23 05:26:58.000000000 +0100
@@ -40,6 +40,7 @@
             int flags, off_t offset, unsigned char **ptr, int *map_fd);
 int ion_share(int fd, ion_user_handle_t handle, int *share_fd);
 int ion_import(int fd, int share_fd, ion_user_handle_t *handle);
+unsigned long ion_getphyadr(int fd, ion_user_handle_t handle);
 
 __END_DECLS
 
diff -ur ../aosp/system/core/libion/ion.c ../Desktop/android/system/core/libion/ion.c
--- ../aosp/system/core/libion/ion.c	2018-08-06 15:48:53.661800035 +0200
+++ ../Desktop/android/system/core/libion/ion.c	2017-11-23 05:26:58.000000000 +0100
@@ -31,6 +31,18 @@
 #include <linux/ion.h>
 #include <ion/ion.h>
 
+
+#define ION_IOC_SUNXI_FLUSH_RANGE           5
+#define ION_IOC_SUNXI_FLUSH_ALL             6
+#define ION_IOC_SUNXI_PHYS_ADDR             7
+#define ION_IOC_SUNXI_DMA_COPY              8
+
+typedef struct {
+    ion_user_handle_t handle;
+    unsigned int phys_addr;
+    unsigned int size;
+}sunxi_phys_data;
+
 int ion_open()
 {
     int fd = open("/dev/ion", O_RDWR);
@@ -176,3 +188,17 @@
     };
     return ion_ioctl(fd, ION_IOC_SYNC, &data);
 }
+
+unsigned long ion_getphyadr(int fd,ion_user_handle_t handle)
+{
+	int ret = 0;
+	struct ion_custom_data custom_data;
+	sunxi_phys_data phys_data;
+	custom_data.cmd = ION_IOC_SUNXI_PHYS_ADDR;
+    phys_data.handle = handle;
+	custom_data.arg = (unsigned long)&phys_data;
+	ret = ioctl(fd, ION_IOC_CUSTOM, &custom_data);
+	if(ret < 0)
+		return 0;
+    return phys_data.phys_addr;
+}
diff -ur ../aosp/system/core/lmkd/lmkd.c ../Desktop/android/system/core/lmkd/lmkd.c
--- ../aosp/system/core/lmkd/lmkd.c	2018-08-06 15:48:53.745801138 +0200
+++ ../Desktop/android/system/core/lmkd/lmkd.c	2017-11-23 05:26:58.000000000 +0100
@@ -14,7 +14,7 @@
  * limitations under the License.
  */
 
-#define LOG_TAG "lowmemorykiller"
+#define LOG_TAG "lmkd"
 
 #include <arpa/inet.h>
 #include <errno.h>
@@ -576,6 +576,10 @@
           taskname, pid, uid, procp->oomadj, tasksize * page_k,
           first ? "" : "~", other_file * page_k, minfree * page_k, min_score_adj,
           first ? "" : "~", other_free * page_k, other_free >= 0 ? "above" : "below");
+    for(int i=0;i<MAX_TARGETS;i++){
+	ALOGD("lowmem_adj[i] = %d lowmem_minfree[i] = %d",lowmem_adj[i],lowmem_minfree[i]);
+    }
+    ALOGD("\n");
     r = kill(pid, SIGKILL);
     killProcessGroup(uid, pid, SIGKILL);
     pid_remove(pid);
diff -ur ../aosp/system/core/logd/main.cpp ../Desktop/android/system/core/logd/main.cpp
--- ../aosp/system/core/logd/main.cpp	2018-08-06 15:48:53.749801191 +0200
+++ ../Desktop/android/system/core/logd/main.cpp	2017-11-23 05:26:58.000000000 +0100
@@ -371,11 +371,12 @@
 // transitory per-client threads are created for each reader.
 int main(int argc, char *argv[]) {
     int fdPmesg = -1;
-    bool klogd = property_get_bool("logd.kernel",
+    /*bool klogd = property_get_bool("logd.kernel",
                                    BOOL_DEFAULT_TRUE |
                                    BOOL_DEFAULT_FLAG_PERSIST |
                                    BOOL_DEFAULT_FLAG_ENG |
-                                   BOOL_DEFAULT_FLAG_SVELTE);
+                                   BOOL_DEFAULT_FLAG_SVELTE);*/
+    bool klogd = false;
     if (klogd) {
         fdPmesg = open("/proc/kmsg", O_RDONLY | O_NDELAY);
     }
diff -ur ../aosp/system/core/rootdir/init.rc ../Desktop/android/system/core/rootdir/init.rc
--- ../aosp/system/core/rootdir/init.rc	2018-08-06 15:48:53.765801400 +0200
+++ ../Desktop/android/system/core/rootdir/init.rc	2017-11-23 05:26:58.000000000 +0100
@@ -469,6 +469,9 @@
     # set RLIMIT_NICE to allow priorities from 19 to -20
     setrlimit 13 40 40
 
+    start zygote
+    start netd
+
     # Memory management.  Basic kernel parameters, and allow the high
     # level system server to be able to adjust the kernel OOM driver
     # parameters to match how it is managing things.
diff -ur ../aosp/system/core/sdcard/sdcard.c ../Desktop/android/system/core/sdcard/sdcard.c
--- ../aosp/system/core/sdcard/sdcard.c	2018-08-06 15:48:53.769801453 +0200
+++ ../Desktop/android/system/core/sdcard/sdcard.c	2017-11-23 05:26:58.000000000 +0100
@@ -95,6 +95,7 @@
 
 #define PROP_SDCARDFS_DEVICE "ro.sys.sdcardfs"
 #define PROP_SDCARDFS_USER "persist.sys.sdcardfs"
+#define PROP_3RDAPP_WRITE_EXTERNAL_STORAGE "ro.config.writeexternalstorage"
 
 #define FUSE_UNKNOWN_INO 0xffffffff
 
@@ -1896,9 +1897,19 @@
         /* Physical storage is readable by all users on device, but
          * the Android directories are masked off to a single user
          * deep inside attr_from_stat(). */
+        mode_t write_permission;
+        char property_value[PROPERTY_VALUE_MAX];
+        property_get(PROP_3RDAPP_WRITE_EXTERNAL_STORAGE, property_value, "0");
+        if(!strcmp(property_value, "1")){
+            ALOGW("open up write_external_permission to 3rd apps");
+            write_permission = 0002;
+        }else{
+            ALOGW("close write_external_permission to 3rd apps");
+            write_permission = 0022;
+        }
         if (fuse_setup(&fuse_default, AID_SDCARD_RW, 0006)
                 || fuse_setup(&fuse_read, AID_EVERYBODY, full_write ? 0027 : 0022)
-                || fuse_setup(&fuse_write, AID_EVERYBODY, full_write ? 0007 : 0022)) {
+                || fuse_setup(&fuse_write, AID_EVERYBODY, full_write ? 0007 : write_permission)) {
             ERROR("failed to fuse_setup\n");
             exit(1);
         }
diff -ur ../aosp/system/extras/ext4_utils/setup_fs.c ../Desktop/android/system/extras/ext4_utils/setup_fs.c
--- ../aosp/system/extras/ext4_utils/setup_fs.c	2018-08-06 15:48:55.113819097 +0200
+++ ../Desktop/android/system/extras/ext4_utils/setup_fs.c	2017-11-23 05:26:58.000000000 +0100
@@ -2,6 +2,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
+#include <fcntl.h>
 #include <sys/reboot.h>
 #include <sys/wait.h>
 #include <cutils/android_reboot.h>
@@ -36,10 +37,30 @@
     }
     snprintf(buf, sizeof(buf), "/dev/block/%s", blockdev);
 
-    if (!partition_wiped(buf)) {
-        fprintf(stderr,"device %s not wiped, probably encrypted, not wiping\n", blockdev);
-        return 0;
-    }
+    int fd = open("/proc/cmdline", O_RDONLY);
+    char cmdline[1024];
+    char *ptr;
+	if (fd >= 0) {
+		int n = read(fd, cmdline, 1023);
+		if (n < 0) n = 0;
+
+		/* get rid of trailing newline, it happens */
+		if (n > 0 && cmdline[n-1] == '\n') n--;
+
+		cmdline[n] = 0;
+		close(fd);
+	} else {
+		cmdline[0] = 0;
+	}
+	ptr = strstr(cmdline, "boot_type=1");
+	if (ptr == NULL) {//normal start
+		if (!partition_wiped(buf)) {
+            fprintf(stderr,"device %s not wiped, probably encrypted, not wiping\n", blockdev);
+            return 0;
+		}
+    }else{//sdcard start
+        fprintf(stderr,"device is starting from card_num_0,don't check partition_wiped\n");
+	}
 
     fprintf(stderr,"+++\n");
 
@@ -52,7 +73,6 @@
         execl(mkfs, mkfs, buf, NULL);
         exit(-1);
     }
-
     while ((pid=waitpid(-1, &status, 0)) != child) {
         if (pid == -1) {
             fprintf(stderr, "error: setup_fs: waitpid failed!\n");
@@ -61,7 +81,7 @@
     }
 
     fprintf(stderr,"---\n");
-    return 1;
+    return 0;
 }
 
 
diff -ur ../aosp/system/media/audio/include/system/audio.h ../Desktop/android/system/media/audio/include/system/audio.h
--- ../aosp/system/media/audio/include/system/audio.h	2018-08-06 15:48:58.893868717 +0200
+++ ../Desktop/android/system/media/audio/include/system/audio.h	2017-11-23 05:27:03.000000000 +0100
@@ -613,6 +613,8 @@
     AUDIO_MODE_RINGTONE         = 1,
     AUDIO_MODE_IN_CALL          = 2,
     AUDIO_MODE_IN_COMMUNICATION = 3,
+    AUDIO_MODE_MODE_FACTORY_TEST = 4,
+    AUDIO_MODE_FM		= 5,
 
     AUDIO_MODE_CNT,
     AUDIO_MODE_MAX              = AUDIO_MODE_CNT - 1,
@@ -737,6 +739,8 @@
     AUDIO_DEVICE_IN_IP                    = AUDIO_DEVICE_BIT_IN | 0x80000,
     /* audio bus implemented by the audio system (e.g an MOST stereo channel) */
     AUDIO_DEVICE_IN_BUS                   = AUDIO_DEVICE_BIT_IN | 0x100000,
+	AUDIO_DEVICE_IN_AF                    = AUDIO_DEVICE_BIT_IN | 0x1000000,
+    AUDIO_DEVICE_IN_PT71600_REMOTE        = AUDIO_DEVICE_BIT_IN | 0x2000000,
     AUDIO_DEVICE_IN_DEFAULT               = AUDIO_DEVICE_BIT_IN | AUDIO_DEVICE_BIT_DEFAULT,
 
     AUDIO_DEVICE_IN_ALL     = (AUDIO_DEVICE_IN_COMMUNICATION |
@@ -760,6 +764,8 @@
                                AUDIO_DEVICE_IN_LOOPBACK |
                                AUDIO_DEVICE_IN_IP |
                                AUDIO_DEVICE_IN_BUS |
+							   AUDIO_DEVICE_IN_AF |
+                               AUDIO_DEVICE_IN_PT71600_REMOTE |
                                AUDIO_DEVICE_IN_DEFAULT),
     AUDIO_DEVICE_IN_ALL_SCO = AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET,
     AUDIO_DEVICE_IN_ALL_USB  = (AUDIO_DEVICE_IN_USB_ACCESSORY |
@@ -1456,12 +1462,23 @@
     return (audio_format_t)(format & AUDIO_FORMAT_MAIN_MASK);
 }
 
+static inline bool audio_format_is_iec61937(audio_format_t format)
+{
+    return ((format & AUDIO_FORMAT_MAIN_MASK) == AUDIO_FORMAT_AC3 || 
+            (format & AUDIO_FORMAT_MAIN_MASK) == AUDIO_FORMAT_E_AC3 || 
+            (format & AUDIO_FORMAT_MAIN_MASK) == AUDIO_FORMAT_DTS ||
+            (format & AUDIO_FORMAT_MAIN_MASK) == AUDIO_FORMAT_DTS_HD ||
+            (format & AUDIO_FORMAT_MAIN_MASK) == AUDIO_FORMAT_IEC61937);
+}
+
 /**
  * Is the data plain PCM samples that can be scaled and mixed?
  */
 static inline bool audio_is_linear_pcm(audio_format_t format)
 {
-    return (audio_get_main_format(format) == AUDIO_FORMAT_PCM);
+    //Modified by Chengkan
+    //For ac3 and e-ac3 has been packed through over PCM. Details for iec61937
+    return (audio_get_main_format(format) == AUDIO_FORMAT_PCM || audio_format_is_iec61937(format));
 }
 
 /**
@@ -1478,7 +1495,7 @@
 {
     audio_format_t mainFormat = audio_get_main_format(format);
     return (mainFormat == AUDIO_FORMAT_PCM
-            || mainFormat == AUDIO_FORMAT_IEC61937);
+            || mainFormat == AUDIO_FORMAT_IEC61937 || audio_format_is_iec61937(format));
 }
 
 static inline size_t audio_bytes_per_sample(audio_format_t format)
@@ -1495,6 +1512,13 @@
         break;
     case AUDIO_FORMAT_PCM_16_BIT:
     case AUDIO_FORMAT_IEC61937:
+    //Added by Chengkan start
+    //For ac3 and e-ac3 has been packed through over PCM. Details for iec61937
+    case AUDIO_FORMAT_AC3:
+    case AUDIO_FORMAT_E_AC3:
+    case AUDIO_FORMAT_DTS:
+    case AUDIO_FORMAT_DTS_HD:
+    //Added by Chengkan end
         size = sizeof(int16_t);
         break;
     case AUDIO_FORMAT_PCM_8_BIT:
Only in ../Desktop/android/system/nvram: .emptycommitmark
diff -ur ../aosp/system/sepolicy/domain.te ../Desktop/android/system/sepolicy/domain.te
--- ../aosp/system/sepolicy/domain.te	2018-08-06 15:49:02.373914396 +0200
+++ ../Desktop/android/system/sepolicy/domain.te	2017-11-23 05:27:03.000000000 +0100
@@ -158,6 +158,7 @@
   -vold
   -dumpstate
   -system_server
+  -att_policy
   userdebug_or_eng(`-perfprofd')
 } self:capability sys_ptrace;
 
diff -ur ../aosp/system/vold/Android.mk ../Desktop/android/system/vold/Android.mk
--- ../aosp/system/vold/Android.mk	2018-08-06 15:49:04.845946843 +0200
+++ ../Desktop/android/system/vold/Android.mk	2017-11-23 05:27:04.000000000 +0100
@@ -31,6 +31,8 @@
 	KeyStorage.cpp \
 	ScryptParameters.cpp \
 	secontext.cpp \
+	Ntfs.cpp \
+	Exfat.cpp \
 
 common_c_includes := \
 	system/extras/ext4_utils \
@@ -39,7 +41,8 @@
 	frameworks/native/include \
 	system/security/keystore \
 	hardware/libhardware/include/hardware \
-	system/security/softkeymaster/include/keymaster
+	system/security/softkeymaster/include/keymaster \
+	hardware/aw/include
 
 common_shared_libraries := \
 	libsysutils \
@@ -58,6 +61,7 @@
 	libsoftkeymaster \
 	libbase \
 	libkeymaster_messages \
+	libisomountmanagerservice
 
 common_static_libraries := \
 	libbootloader_message_writer \
diff -ur ../aosp/system/vold/cryptfs.c ../Desktop/android/system/vold/cryptfs.c
--- ../aosp/system/vold/cryptfs.c	2018-08-06 15:49:04.905947633 +0200
+++ ../Desktop/android/system/vold/cryptfs.c	2017-11-23 05:27:04.000000000 +0100
@@ -3037,7 +3037,7 @@
     /* The init files are setup to stop the class main and late start when
      * vold sets trigger_shutdown_framework.
      */
-    property_set("vold.decrypt", "trigger_shutdown_framework");
+    //property_set("vold.decrypt", "trigger_shutdown_framework");
     SLOGD("Just asked init to shut down class main\n");
 
     /* Ask vold to unmount all devices that it manages */
diff -ur ../aosp/system/vold/Disk.cpp ../Desktop/android/system/vold/Disk.cpp
--- ../aosp/system/vold/Disk.cpp	2018-08-06 15:49:04.857947000 +0200
+++ ../Desktop/android/system/vold/Disk.cpp	2017-11-23 05:27:04.000000000 +0100
@@ -170,7 +170,6 @@
         vol->destroy();
         vol->setSilent(false);
     }
-
     mVolumes.push_back(vol);
     vol->setDiskId(getId());
     vol->create();
@@ -304,6 +303,7 @@
 
     Table table = Table::kUnknown;
     bool foundParts = false;
+    bool handle = false;
     for (auto line : output) {
         char* cline = (char*) line.c_str();
         char* token = strtok(cline, kSgdiskToken);
@@ -328,13 +328,14 @@
 
             if (table == Table::kMbr) {
                 const char* type = strtok(nullptr, kSgdiskToken);
-
                 switch (strtol(type, nullptr, 16)) {
+                case 0x07: // NTFS and EXFAT
                 case 0x06: // FAT16
                 case 0x0b: // W95 FAT32 (LBA)
                 case 0x0c: // W95 FAT32 (LBA)
                 case 0x0e: // W95 FAT16 (LBA)
                     createPublicVolume(partDevice);
+                    handle = true;
                     break;
                 }
             } else if (table == Table::kGpt) {
@@ -343,15 +344,18 @@
 
                 if (!strcasecmp(typeGuid, kGptBasicData)) {
                     createPublicVolume(partDevice);
+                    handle = true;
                 } else if (!strcasecmp(typeGuid, kGptAndroidExpand)) {
                     createPrivateVolume(partDevice, partGuid);
+                    handle = true;
                 }
             }
         }
     }
 
     // Ugly last ditch effort, treat entire disk as partition
-    if (table == Table::kUnknown || !foundParts) {
+    // NTFS U Disk without partition has to own mbr table.
+    if (table == Table::kUnknown || !foundParts||(table==Table::kMbr&&!handle)) {
         LOG(WARNING) << mId << " has unknown partition table; trying entire device";
 
         std::string fsType;
Only in ../Desktop/android/system/vold: Exfat.cpp
Only in ../Desktop/android/system/vold: Exfat.h
diff -ur ../aosp/system/vold/main.cpp ../Desktop/android/system/vold/main.cpp
--- ../aosp/system/vold/main.cpp	2018-08-06 15:49:04.905947633 +0200
+++ ../Desktop/android/system/vold/main.cpp	2017-11-23 05:27:04.000000000 +0100
@@ -39,10 +39,18 @@
 #include <dirent.h>
 #include <fs_mgr.h>
 
+#include <pthread.h>
+#include <binder/IPCThreadState.h>
+#include <binder/ProcessState.h>
+#include <binder/IServiceManager.h>
+#include "isomount/ISOMountManagerService.h"
+
 static int process_config(VolumeManager *vm);
 static void coldboot(const char *path);
 static void parse_args(int argc, char** argv);
 
+void* startIsoMountService(void*);
+
 struct fstab *fstab;
 
 struct selabel_handle *sehandle;
@@ -131,6 +139,12 @@
         exit(1);
     }
 
+    pthread_t isoThread;
+    if (pthread_create(&isoThread, NULL,startIsoMountService, NULL)) {
+        SLOGE("startIsoMountService create thread fail (%s)", strerror(errno));
+        exit(1);
+    }
+
     // Eventually we'll become the monitoring thread
     while(1) {
         sleep(1000);
@@ -140,6 +154,15 @@
     exit(0);
 }
 
+void* startIsoMountService(void*)
+{
+    android::sp<android::ProcessState> proc(android::ProcessState::self());
+    android::ISOMountManagerService::instantiate();
+    android::ProcessState::self()->startThreadPool();
+    android::IPCThreadState::self()->joinThreadPool();
+    return NULL;
+}
+
 static void parse_args(int argc, char** argv) {
     static struct option opts[] = {
         {"blkid_context", required_argument, 0, 'b' },
Only in ../Desktop/android/system/vold: Ntfs.cpp
Only in ../Desktop/android/system/vold: Ntfs.h
diff -ur ../aosp/system/vold/PublicVolume.cpp ../Desktop/android/system/vold/PublicVolume.cpp
--- ../aosp/system/vold/PublicVolume.cpp	2018-08-06 15:49:04.905947633 +0200
+++ ../Desktop/android/system/vold/PublicVolume.cpp	2017-11-23 05:27:04.000000000 +0100
@@ -15,6 +15,8 @@
  */
 
 #include "fs/Vfat.h"
+#include "Exfat.h"
+#include "Ntfs.h"
 #include "PublicVolume.h"
 #include "Utils.h"
 #include "VolumeManager.h"
@@ -43,7 +45,7 @@
 
 PublicVolume::PublicVolume(dev_t device) :
         VolumeBase(Type::kPublic), mDevice(device), mFusePid(0) {
-    setId(StringPrintf("public:%u,%u", major(device), minor(device)));
+    setId(StringPrintf("public:%u_%u", major(device), minor(device)));
     mDevPath = StringPrintf("/dev/block/vold/%s", getId().c_str());
 }
 
@@ -94,15 +96,22 @@
     // TODO: expand to support mounting other filesystems
     readMetadata();
 
-    if (mFsType != "vfat") {
+    //if (mFsType != "vfat") {
+        //LOG(ERROR) << getId() << " unsupported filesystem " << mFsType;
+        //return -EIO;
+    //}
+    std::string fs("null");
+    
+    if (!vfat::Check(mDevPath)) {
+        fs="vfat";
+    }else if (!Ntfs::check(mDevPath.c_str())) {
+        fs="ntfs";
+    }else if (!Exfat::check(mDevPath.c_str())){
+        fs="exfat";
+    }else{
         LOG(ERROR) << getId() << " unsupported filesystem " << mFsType;
         return -EIO;
-    }
-
-    if (vfat::Check(mDevPath)) {
-        LOG(ERROR) << getId() << " failed filesystem check";
-        return -EIO;
-    }
+    }    
 
     // Use UUID as stable name, if available
     std::string stableName = getId();
@@ -127,11 +136,24 @@
         PLOG(ERROR) << getId() << " failed to create mount points";
         return -errno;
     }
-
-    if (vfat::Mount(mDevPath, mRawPath, false, false, false,
-            AID_MEDIA_RW, AID_MEDIA_RW, 0007, true)) {
-        PLOG(ERROR) << getId() << " failed to mount " << mDevPath;
-        return -EIO;
+    if (fs=="vfat"){
+        if (vfat::Mount(mDevPath, mRawPath, false, false, false,
+                AID_MEDIA_RW, AID_MEDIA_RW, 0007, true)) {
+            PLOG(ERROR) << getId() << " failed to mount " << mDevPath;
+            return -EIO;
+        }
+    }else if(fs=="ntfs"){
+        if (Ntfs::doMount(mDevPath.c_str(), mRawPath.c_str(), false, false, false,
+                AID_MEDIA_RW, AID_MEDIA_RW, 0007, true)) {
+            PLOG(ERROR) << getId() << " failed to mount " << mDevPath;
+            return -EIO;
+        }
+    }else if(fs=="exfat"){
+        if (Exfat::doMount(mDevPath.c_str(), mRawPath.c_str(), false, false, false,
+                    AID_MEDIA_RW, AID_MEDIA_RW, 0007, true)) {
+            PLOG(ERROR) << getId() << " failed to mount " << mDevPath;
+            return -EIO;    
+        }
     }
 
     if (getMountFlags() & MountFlags::kPrimary) {
@@ -140,6 +162,7 @@
 
     if (!(getMountFlags() & MountFlags::kVisible)) {
         // Not visible to apps, so no need to spin up FUSE
+        PLOG(ERROR) << mDevPath << "Direct return,Not visible to apps, so no need to spin up FUSE";
         return OK;
     }
 
diff -ur ../aosp/system/vold/Utils.cpp ../Desktop/android/system/vold/Utils.cpp
--- ../aosp/system/vold/Utils.cpp	2018-08-06 15:49:04.905947633 +0200
+++ ../Desktop/android/system/vold/Utils.cpp	2017-11-23 05:27:04.000000000 +0100
@@ -153,17 +153,17 @@
     if (Process::killProcessesWithOpenFiles(cpath, SIGINT) == 0) {
         return OK;
     }
-    sleep(5);
+    //sleep(5);
 
     if (Process::killProcessesWithOpenFiles(cpath, SIGTERM) == 0) {
         return OK;
     }
-    sleep(5);
+    //sleep(5);
 
     if (Process::killProcessesWithOpenFiles(cpath, SIGKILL) == 0) {
         return OK;
     }
-    sleep(5);
+    //sleep(5);
 
     // Send SIGKILL a second time to determine if we've
     // actually killed everyone with open files
diff -ur ../aosp/system/vold/VolumeManager.cpp ../Desktop/android/system/vold/VolumeManager.cpp
--- ../aosp/system/vold/VolumeManager.cpp	2018-08-06 15:49:04.905947633 +0200
+++ ../Desktop/android/system/vold/VolumeManager.cpp	2017-11-23 05:27:04.000000000 +0100
@@ -276,18 +276,44 @@
     return 0;
 }
 
+void VolumeManager::enhanceUsbStability(NetlinkEvent *evt) {
+        char path[256];
+        const char *tmp = evt->findParam("DEVNAME");
+        char devname[4];
+        FILE *fp;
+        int msecs = 1000;
+
+        if (tmp && !strncmp(tmp, "sd", 2)) {
+           strncpy(devname,tmp,3);
+           devname[3] = '\0';
+           sprintf(path, "/sys/block/%s/events_poll_msecs", devname);
+           //usleep(1000 * 1000);
+           if ((fp = fopen(path, "r+ "))) {
+               if (fprintf(fp, "%d\n", msecs) <= 0) {
+                   SLOGE("Failed to write %s (%s)", path, strerror(errno));
+               }
+               SLOGD("Success to write %d to %s ", msecs, path);
+               fclose(fp);
+           } else {
+               SLOGE("Failed to open %s (%s)", path, strerror(errno));
+           }
+       }
+}
+
 void VolumeManager::handleBlockEvent(NetlinkEvent *evt) {
     std::lock_guard<std::mutex> lock(mLock);
 
-    if (mDebug) {
+    std::string eventPath(evt->findParam("DEVPATH")?evt->findParam("DEVPATH"):"");
+    std::string devType(evt->findParam("DEVTYPE")?evt->findParam("DEVTYPE"):"");
+
+    if (true) {
         LOG(VERBOSE) << "----------------";
         LOG(VERBOSE) << "handleBlockEvent with action " << (int) evt->getAction();
+        LOG(VERBOSE) << "handleBlockEvent with devpath " << eventPath;
+        LOG(VERBOSE) << "handleBlockEvent with devtype " << devType;
         evt->dump();
     }
 
-    std::string eventPath(evt->findParam("DEVPATH")?evt->findParam("DEVPATH"):"");
-    std::string devType(evt->findParam("DEVTYPE")?evt->findParam("DEVTYPE"):"");
-
     if (devType != "disk") return;
 
     int major = atoi(evt->findParam("MAJOR"));
@@ -315,6 +341,7 @@
                         source->getNickname(), flags);
                 disk->create();
                 mDisks.push_back(std::shared_ptr<android::vold::Disk>(disk));
+                enhanceUsbStability(evt);
                 break;
             }
         }
diff -ur ../aosp/system/vold/VolumeManager.h ../Desktop/android/system/vold/VolumeManager.h
--- ../aosp/system/vold/VolumeManager.h	2018-08-06 15:49:04.905947633 +0200
+++ ../Desktop/android/system/vold/VolumeManager.h	2017-11-23 05:27:04.000000000 +0100
@@ -93,6 +93,7 @@
     int stop();
 
     void handleBlockEvent(NetlinkEvent *evt);
+    void enhanceUsbStability(NetlinkEvent *evt);
 
     class DiskSource {
     public:
